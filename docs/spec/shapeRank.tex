\documentclass{article}
\usepackage{epsfig}
\usepackage{hyperref}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{textcomp}

\input{shapeRank.sty}
\begin{document}
\title{ShapeRank Language Specification\\
{\large Version 0.1}
}
\maketitle

\tableofcontents

\section{Introduction}

ShapeRank is a purely functional, decidable, rank-polymorphic statically typed language. It is designed for data analysis, reactive programming and machine learning. 

All values in ShapeRank are hyperstreams [\ref{concepts}]. A {\em hyperstream} is either scalar, [\ref{scalars}] or a sequence [\ref{streams}] of hyperstreams. Hyperstreams may be of a pre-determined size, or they may be unbounded. 

ShapeRank does not support user-defined higher order functions. However, a number of useful higher-order functions are built into the language [\ref{higherOrderFunctions}]. User defined functions [\ref{functions}] may be used as arguments to these.

The language does not permit recursion and has no explicit looping constructs. These are not needed, since all iteration is implicit, dictated by the shape of the data. As a result, a program written in ShapeRank can never diverge or crash. 

ShapeRank has no constructs to create recursive data structures, and so any data a program creates is acyclic. Hence, reference counting is a sufficient strategy for memory reclamation.



\subsection{Conventions}
\label{conventions}

In this specification, normative text appears in roman font. Defined concepts are given in {\em italic font}. Non-normative commentary is given in {\em italic font}.

{\em Commentary is useful for adding explanations, motivations, context etc.}

{\em 
The specification does not detail syntax errors. Syntactically erroneous situations are implicitly defined by the syntax productions herein.
}

Constructs that are syntactically valid but are illegal for other reasons result in compile-time errors. The circumstances leading to such compile-time errors are described on an individual basis in this specification.

{\em
Examples include expressions that do not have a valid type or references to undeclared or multiply declared entities.
}

\subsubsection{Presentation of Syntax}

Syntax productions are given in a form of EBNF. The name of a production is given in {\bf bold}.  All non-terminals are enclosed in angle brackets. The symbol $\rightarrow$ is used to separate a production's left and right sides. Alternatives are separated by the $|$ symbol. Parentheses are used for grouping. The postfix $*$ denotes zero or more repetitions, and postfix $+$ denotes one or more repetitions. Optional items are postfixed by $?$. To distinguish terminals from EBNF notation, terminals appear in {\color{blue} blue}.

{\em Examples:}
\begin{itemize}
\item \BuiltinType
\item  \HyperstreamLiteral
\end{itemize}


Lexical rules are similar, but the names of lexical productions are always given in uppercase, and the left and right hand sides are separated by ::=.


\section{Concepts}
\label{concepts}

A {\em hyperstream} consists of either a scalar, or a sequence, also known as a {\em stream}, whose elements are hyperstreams, along with 
 zero or more {\em dimensions}, a {\em shape} and a {\em rank}. A dimension has a {\em length} (also referred to as its {\em size}), which is either an integer or \QUESTIONMARK.

The shape is a vector of the lengths of the hyperstream's dimensions. The rank is the length of the shape.

{\em
The rank therefore gives the number of dimensions in the hyperstream.
}

\subsection{Scalars}
\label{scalars}

The most elementary hyperstreams are {\em scalar hyperstreams}. These include  booleans [\ref{bool}], numbers [\ref{number}], strings [\ref{string}] and  structs [\ref{structTypes}]. A scalar hyperstream consists of a single scalar value, and has zero dimensions, hence its shape is the empty sequence, $[]$. The rank of a scalar hyperstream is therefore $0$. We will often refer to scalar hyperstreams simply as scalars.

\subsection{Streams}
\label{streams}

A {\em stream} is a sequence of {\em elements}.  A stream may be {\em bounded} or {\em unbounded}. A bounded stream has a fixed length, determined when the stream is created; the length of an unbounded stream varies over time. At any point in time, an unbounded stream has some number $n \gt 0$ of {\em available elements}. The number of available elements of a stream increases monotonically over time. Every stream also has a {\em dynamic size}, distinct from its statically declared length. The dynamic size is the maximum number of available elements during program execution.

{\em One may think of the length of an unbounded stream as potentially infinite. In practice, no stream is infinite, as we do not anticipate ShapeRank programs surviving the death of the universe.
}

A non-scalar hyperstream consists of a stream, $s$, of hyperstreams. All elements of $s$ must have a common type.  

The shape of a non-scalar hyperstream is a vector whose first element is the number of elements of $s$ (if $s$ is bounded) or \QUESTIONMARK if $s$ is unbounded, and
whose remainder is given by the shape of the elements of $s$.

{\em The above implies all elements of $s$ have the same rank and common element type, and each of their dimensions is either the same or \QUESTIONMARK}


\subsection{Reactivity and Synchronicity}
\label{reactivityAndSynchronicity}

A function is {\em reactive} if it may fire whenever the number of available elements [\ref{streams}] of any of its inputs increases. Otherwise it is {\em synchronous}.


\section{Let Bindings}
\label{letBindings}

A {\em let binding} assigns a value to an identifier. 

\LetBinding{}

The expression $\LET{}$ $ID$ \BIND{} $e$ is equivalent to $\LET{}$ $ID$\COLON{} $T$ \BIND{} $e$  where $T$ is the type of $e$.
Let  $l \triangleq $ \LET{} $ID$\COLON{} $T$ \BIND{} $e$

The effect of $l$ is that variable $ID$ is added to the enclosing program's compile-time scope, with type [\ref{types}] $T$.


\section{Functions}
\label{functions}

\FunctionDeclaration

A function declaration defines a transformation of one or more input streams into an output stream. A function declaration has a
{\em function signature} which specifies the name of the function, and the type of each of its parameters.

{\em The type of a parameter will specify its element type and its shape (and therefore its rank). }

If the keyword \SYNC precedes the keyword \FUNC, the function is synchronous [\ref{reactivityAndSynchronicity}], otherwise it is reactive.

\FunctionSignature{}

\FunctionSignatureOptionalReturn{}

\ParameterList{}

\Parameter{}

A function signature has the form  $F\LPAREN{}p_1\COLON T_1\COMMA{} \ldots\COMMA{} p_n\COLON T_n\RPAREN{}\COLON T_r$ where $F$ is an identifier that specifies the name of the function, and $p_i\COLON{} T_i, i \in 1..n$ specify the function's parameters; each $p_i$ is an identifier that names the $i$th parameter, and the corresponding $T_i$ is a type [\ref{types}], which implicitly specifies the parameter's rank.  Finally, $T_r$ specifies the {\em return type}, the type of a call [\ref{calls}] of a function that has said signature. The specification of the return type may be omitted in certain circumstances where it may be inferred, as discussed in section \ref{dexFunctions}.
The signature corresponds to the function type [\ref{functionTypes}] $T_1, \ldots, T_n \to T_r$.

{\em
Note that,  as described in section \ref{typeVariables}, the parameter list may implicitly declare type variables. However, the return type $T_r$ may not. If type variables are introduced, the resulting function type will of course be polymorphic. 
}

Processing a function signature has the following effect:

A new scope, $s_{sig}$, is introduced. The scope $s_{sig}$ is nested in the compile-time scope of the enclosing module definition, $s_m$, yielding a scope $s \triangleq s_m \leftarrow s_{sig}$. The scope $s$ is known as {\em the compile-time scope of the function signature}.
The current compile-time scope is set to $s$, and the types of the formal parameters and the return type are checked in accordance with the rules of section \ref{typeExpressions}. Then the current compile-time scope is set back to $s_m$.

{\em 
The function signature scope is intended to contain bindings for any type variables [\ref{typeVariables}] that are introduced in the parameter list.
}

It is a compile-time error if $p_i = p_j, i \ne j$.

The function declaration \FUNC{}  $F\LPAREN{}p_1\COLON T_1\COMMA{} \ldots\COMMA{} p_n\COLON T_n\RPAREN{}$  \BIND{} $e$ is equivalent to \FUNC{} $F\LPAREN{}p_1\COLON T_1\COMMA{} \ldots\COMMA{} p_n\COLON T_n\RPAREN{}\COLON T_e$  \BIND{} $e$ where $T_e$ is the type of $e$ in the function's compile-time scope.

Let $f \triangleq$ \FUNC{} $F\LPAREN{}p_1\COLON T_1\COMMA{} \ldots\COMMA{} p_n\COLON T_n\RPAREN{}\COLON T_r$  \BIND{} $e$.

Processing of $f$  has the following effect:

A binding of $F$ to $f$ is added to the compile-time scope of the enclosing program with the type schema [\ref{typeGeneralization}] $generalize(T_1, \ldots, T_n \to T_r)$ [\ref{functionTypes}].

{\em
Generalization produces a type schema (aka polymorphic type) for the function, that will be instantiated separately at every call, allowing the function to be used polymorphically. 
}

 Then the function signature is processed. Let $s_0$ be the compile-time scope of the function signature.
A new scope $s$ is created, and is known as the {\em immediate scope of} $f$. The scope $s_0 \leftarrow s$ is known as {\em the compile-time scope of $f$}.

{\em Thus, $s$ is nested in the function signature's scope, which is nested in the enclosing module definition scope.}

The variables $p_i$ are added to $s$, with types $T_i, i \in 1..n$ respectively.

Let $T_e$ be the type of $e$ in $s$. 
It is a compile-time error if  $T_e$ is not a subtype [\ref{subtyping}] of $T_r$.  It is a compile-time error if the compile-time scope of the enclosing program contains another declaration named $F$.

\section{Built-in Functions}
\label{builtinFunctions}


\subsection{Hyperstream Creation}
\label{streamCreation}

Because ShapeRank prohibits recursion, it is not possible to create unbounded hyperstreams from scratch. One must obtain an unbounded hyperstream from input or by calling a function.
However, it is possible to define bounded hyperstreams.

{\em In other words, arrays.}

The function $makeTensor(dims: \ATSIGN{}S, contents: []\DOLLAR{}T):\ATSIGN{}S \DOLLAR{}T$
will produce a hyperstream whose shape is given by a bounded hyperstream, $dims$ and whose contents are given by a hyperstream $contents$.

\subsection{Higher-Order Functions}
\label{higherOrderFunctions}

ShapeRank supports a number of higher-order functions. They treat their function-valued arguments as scalar streams [\ref{scalars}]. We give the signatures of these functions as we do those of normal ShapeRank functions, but extended with the notation for function types.


\subsubsection{Fold}
\label{fold}


The $fold$ function takes a binary function $f$, an initial value $acc$ and a bounded stream $x$ of rank $r \ge 1$ and length $\DOLLAR{}d$. It then computes the rank-polymorphic call [\ref{calls}]
$f(f( \ldots f(acc, x_1), \ldots x_{d-1}), x_d)$, where $d$ is the dynamic size of $x$.

{\em It is worth emphasizing that the calls to f above are rank-polymorphic, and will therefore adapt to the dimensions of x. See the discussion of the signature of fold below.
}

{\em Note that fold only returns a result when $x$ is completed, which is why it is restricted to bounded streams.}

$fold(f: \ATSIGN{}P\DOLLAR{}T \to{}\ATSIGN{}Q\DOLLAR{}S \to{}\ATSIGN{}P\DOLLAR{}T, acc: \ATSIGN{}P\DOLLAR{}T, x:[\DOLLAR{}d\BANG]::\ATSIGN{}R::\ATSIGN{}Q \DOLLAR{}S): \ATSIGN{}R::\ATSIGN{}P \DOLLAR{}T $

{\em
The signature above bears some explanation. The function $f$ expects its second argument to have shape $Q$, with rank $rank(Q)$. The actual stream $x$ is not necessarily a stream of elements of shape $Q$ (whose rank would be $Q+1$); it may have rank $r \gt rank(Q) + 1$. We express this by defining the shape of $x$ to be $[\DOLLAR{}d]::\ATSIGN{}R::\ATSIGN{}Q$, which ensures that $r = 1 + rank(R) + rank(Q)$. Thus $R$ expresses an extra degree of 'padding'.
}



\subsubsection{Inner Product}
\label{innerProduct}

The $innerProduct$ function takes binary functions $f$ and $g$ and hyperstreams $a$ and $b$, and calls [\ref{calls}] $reduce(f, g(s_a, s_b))$ [\ref{reduce}] for all slices $s_a$ along the last dimension of  $a$ and all slices  $s_b$ along the first dimension of $b$.

{\em Define slices. Define reduce w/o explicit acc parameter.}

{\em Inner product can be seen as a generalization of matrix multiplication.  Given matrices $a: [m][n]$ and $b[n][p]$, their product is given by
 $innerProduct(a, b, *, +)$

}

$innerProduct(a: \ATSIGN{}X:: [\DOLLAR{}n]\DOLLAR{}T, b: [\DOLLAR{}n]::\ATSIGN{}Y\DOLLAR{}S,  f: \DOLLAR{}R \to \DOLLAR{}R \to \DOLLAR{}Q, g: \DOLLAR{}T \to \DOLLAR{}S \to \DOLLAR{}R): \ATSIGN{}X::\ATSIGN{}Y\DOLLAR{}Q$

\subsubsection{OuterProduct}
\label{outerProduct}

The $outerProduct$ function calls [\ref{calls}] a binary function $f$ on all applicable pairs of elements of two arguments $a$ and $b$ and aggregates the results.

{\em
The outerProduct function is similar to the concept of outer product in mathematics, but there are important differences. It explicitly abstracts over the 'product' operator, $f$, which need not be a mathematical product in any sense. And of course, it applies to hyperstreams rather than tensors.
}

$outerProduct(f: \ATSIGN{}S_1 \DOLLAR{}T_1 \to{} \ATSIGN{}S_2 \DOLLAR{}T_2 \to{} \ATSIGN{}S_3 \DOLLAR{}T_3, a: [d_1]::\ATSIGN{}S_4::\ATSIGN{}S_1 \DOLLAR{}T_1, b: [d_2]::\ATSIGN{}S_5::\ATSIGN{}S_2 \DOLLAR{}T_2): [d_1]::\ATSIGN{}S_4::[d_2]::\ATSIGN{}S_5::\ATSIGN{}S_3 \DOLLAR{}T_3$

{\em
The signature includes 'padding' much like that of fold above. Here, either the elements of $a$ or of $b$, or both, may have ranks that are strictly greater than what is required by $f$.
Hence, each has its own distinct padding shape ($S_4$ and $S_5$ respectively).
}


\subsubsection{Reduce}
\label{reduce}

The $reduce$ function takes a binary function $f$, an initial value $acc$ and a bounded stream $x$ of rank $r \ge 1$. It then computes
$f(f( \ldots f(acc, x_1), \ldots x_{d-1}), x_d)$, where $d$ is the dynamic size of $x$.

$reduce(f: \ATSIGN{}S \DOLLAR{}T \to{} \ATSIGN{}S \DOLLAR{}T \to{} \ATSIGN{}S \DOLLAR{}T, acc: \ATSIGN{}S \DOLLAR{}T, x:[\DOLLAR{}d\BANG]::\ATSIGN{}R::\ATSIGN{}S \DOLLAR{}T): \ATSIGN{}R::\ATSIGN{}S \DOLLAR{}T$

{\em
Reduce works just like fold, except that we insist that both of the arguments to $f$ must have the same type. This allows us to compute the
value in logarithmic time.

The name reduce is motivated by the fact that it reduces the rank of its input $x$ by 1.
}

\subsubsection{Scan}
\label{scan}

The $scan$ function operates like $fold$, except that it produces all of its interim results, in order, on its output stream. 

{\em 
Therefore, scan, unlike fold, is suitable for application to unbounded hyperstreams. Since scan is inherently sequential, there is no justification for a separate version analogous to reduce.
}

$scan(f: \ATSIGN{}P \DOLLAR{}T \to{} \ATSIGN{}Q \DOLLAR{}T \to{} \ATSIGN{}P \DOLLAR{}T, acc: \ATSIGN{}P \DOLLAR{}T, x:[]::\ATSIGN{}R::\ATSIGN{}Q \DOLLAR{}T):[d]::\ATSIGN{}R::\ATSIGN{}Q \DOLLAR{}T$


\section{Expressions}
\label{expressions}

Expressions evaluate values. Values are computed relative to a runtime scope. When we say that $e$ evaluates to $v$, we mean it evaluates to $v$ in the current runtime scope. 

Every expression in a legal ShapeRank program has a type [\ref{types}] that is determined statically, at compile-time. If no type can be determined for an expression, the expression and its enclosing program are illegal and a compile-time error must result. The process of determining the type of an expression is known as type inference [\ref{typeInference}]. Type inference  is usually dependent on the compile-time scope in which it occurs. When we say that an expression $e$ has type $T$, we mean that $e$ has type $T$ in the current compile-time scope.

\subsection{Identifier Expressions}
\label{identifierExpressions}

An {\em identifier expression} consists of a single identifier.

\IdentifierExpression{}

Let $i \triangleq ID$.
Evaluation of $i$ proceeds as follows:


Let $s$ be the the current runtime scope. Then $ID$ iusd looked up in $s$. $ID$ must be either a variable or a function.
\begin{itemize}
\item If $ID$ is bound to a variable $b$, then if no value is associated with $b$ then the definition of $b$ is executed. The value $v$ of $ID$ is then looked up in $s$. The value of $i$ is $v$.

{\em In the case where no value is associated with the variable, it is necessarily defined via  a \LET{} binding. The above reflects the lazy evaluation of \LET{}.}

\item If $ID$ is bound to a function $f$, then value of $i$ is $f$. 
\end{itemize}

The type of $i$ is the type associated with $ID$ in the enclosing compile-time scope.

It is a compile-time error if $ID$ is bound to a type. 


\subsection{Parenthesized Expressions}
\label{parenthesizedExpressions}

{\bf ParenthesizedExpression} $\rightarrow$ \LPAREN{} Expression \RPAREN{} $|$ \LPAREN{} Expression TypeSigSuffix \RPAREN{}


The expression  $\LPAREN{}e \RPAREN{}$ is equivalent to the expression $\LPAREN{}e \COLON{} T \RPAREN{}$ where $T$ is the type of $e$.

Let $p \triangleq \LPAREN{}e \COLON{} T \RPAREN{}$.

Evaluation of $p$ proceeds as follows:

The expression $e$ is evaluated to $v$. The value of $p$ is $v$.

The type of $p$ is $T$.

\subsection{Calls}
\label{calls}

A {\em call} invokes a function [\ref{functions}]. To understand the semantics of calls, we need the auxiliary concepts of frames, cells and replication.


\subsubsection{Frames and Cells}
\label{framesAndCells}

Hyperstreams can be divided into frames and cells. A {\em frame} is a hyperstream whose elements are also hyperstreams, called {\em cells}.

{\em As an example, the matrix 

2 3 4

5 6 7

 can be viewed as a pair of two 3-vectors:
[[2 3 4] [5 6 7]]

In that case, the frame is a 2-vector and the cells are 3-vectors.  Alternately, we can view it as a matrix, in which case the frame is the entire hyperstream, and the cells are scalars. A third way is to view the hyperstream as a frame of rank 0, which consists of a single cell of rank 2. In general, a hyperstream of rank $n$ can be decomposed into frames and cells in $n+1$ ways: a rank $n$ hyperstream with rank 0 elements, a rank $n-1$ hyperstream with vector elements, …, a rank 1 vector with rank $n-1$ cells, or a rank 0 frame with a single rank $n$ cell.
}

A hyperstream $h$, of shape $[d_1, \ldots, d_n]$ may be divided into a frame, $f_h$ of shape $[d_1, \ldots, d_k]$ and cells of shape $[d_{k+1}, , \ldots, d_n]$, for any $0 > k > n$.
The elements of the $h[1] \ldots [k]$ are known as the cells of of $f_h$.

A function $g(a_1, \ldots, a_k)$ may be {\em mapped} on to a frame $f_h$, written $map(g, f_h)$, producing a new frame, $f_m$ of the same shape as $f_h$ such that for each cell $c_h$ of $f_h$, $f_m$ has a corresponding cell $c_m = g(c_{h_1}, \ldots, c_{h_k})$.

\subsubsection{Zipping}
\label{zipping}

Given hyperstreams $h_i$, each with dynamic size $s_i$ and $n_i$  available elements, $ i \in 1..k, k \ge 0$:

 The function $zip_{sync_k}$ produces a hyperstream $h_{sync} \triangleq (h_{1_1}, \ldots, h_{k_1}), \ldots, (h_{1_n}, \ldots, h_{k_n})$ where $n = min(s_i), i \in 1..k$.
 The number of available elements of $h_sync$ at any time is no more than $min(n_i), i \in 1..k$

{\em
Note that the $h_i$ may include both bounded and unbounded streams. If any of the $h_i$ are bounded, then the result of $zip_{sync_k}$ is bounded, and it's length is that of the shortest of the $h_i$. If all  the $h_i$ are unbounded, then $zip_{sync_k}$ is unbounded, with a dynamic size that is the smallest of the dynamic sizes of the $h_i$.

Of necessity, the number of available elements of $h_sync$ at any time is no more than the

An important property of $zip_{sync_k}$ is that it synchronizes its inputs.
}

The function $zip_{react_k}$  produces a hyperstream $h_{react}$, whose first element is $(h_{1_1}, \ldots, h_{k_1})$. When the number of available elements of any of $h_i$ increases, an element $(h_{1_{n_1}}, \ldots, h_{k_{n_k}})$ may be appended to $h_react$. The precise decision of when to add new elements to $h_{react}$ is up to the
implementation, which should make a best-effort to add elements promptly.

{\em
The value of $h_{react}$ is non-deterministic. The first value is produced when all of the $h_i$ have an available value, just as with $h_sync$. From that point on, however,
new values may be added whenever any one of the $h_i$ has a new available value. No guarantees are made as to whether such a value will be added and when. It is quite possible that some of the $h_i$ will have a new available value, while others do not. In such cases, for any $h_i$ that doesn't have a new value,  the last available value is reused.
It is also possible that multiple new values may have become available on any or all of the $h_i$, in which case some values will be skipped.

The implementation of $zip_{react_k}$ is a best-effort, subject to complex engineering trade-offs, much like garbage-collection.

In an extreme case, $zip_{react_k}$ might produce a single value, but this would be an unacceptably poor implementation. Alternatively, $zip_{react_k}$ could behave just like 
$zip{sync_k}$, and this too would be unacceptable.
}

\subsubsection{Replication}
\label{replication}

A frame $f_0$ of shape $[d_1, \ldots, d_k]$ may be replicated into a larger frame, $f_r$ of shape $[d_1, \ldots, d_n]$ for any $n$ where $n \ge k$. Each cell of $f_r$ is equal to $f_0$.




\subsubsection{Call Evaluation}
\label{callEvaluation}


Let $c \triangleq F\LPAREN{}a_1\COMMA{} \ldots\COMMA{} a_k\RPAREN$. Evaluation of $c$ proceeds as follows. 

Let $ar_i$ be the rank of $a_i$ and let $pr_i$ be the rank of $p_i, i \in 1.. k$. Then  $a_i$ is divided into a frame $f_i$, of rank $ar_i - pr_i$ with cells of rank $p_i$. Let $max\_frame \in \{i \in 1..k | f_i\}$ be a frame such that $rank(max\_frame) \ge rank(f_i), i \in 1 ..k$. Next, $f_i$ is replicated [\ref{replication}] into a frame $af_i$, of shape $shape(max\_frame), i \in 1..k$. 

{\em
Every formal parameter has an expected rank. However, arguments may be of higher rank. An argument of rank $n$ may be passed where a parameter of rank $k$ is expected, provided $n \ge k$. The argument is viewed as a frame of rank $n-k$ with cells of rank $k$. 
}

If $F$ is reactive[\ref{reactivityAndSynchronicity}], let $zip = zip_{react_k}$, otherwise let $zip = zip_{sync_k}$.

{\em
The use of zip serves to combine multiple arguments into one. An alternative formulation might use a $map_k$ function instead.
However, using zip gives us a convenient place to manage reactivity.
It is the use of the different zip functions that determine when a reactive function will fire. 
}

Let $r$ be the value of $map(F, zip(af_1, \ldots, af_k),)$. $c$ evaluates to $r$.



It is a compile-time error if $ar_i < pr_i, i \in 1..k$. It is a compile-time error if $shape(f_i)$ is not a prefix of $shape(max\_frame), i \in 1..k$. 


\subsection{Boolean Literals}
\label{booleanLiterals}

The identifiers \TRUE{} and \FALSE{} are predefined,  denoting the boolean scalars true and false respectively, and have type \BOOL{} [\ref{bool}].

{\bf BoolLiteral} $\rightarrow$ \TRUE{} $|$ \FALSE{}

\subsection{Number Literals}
\label{numberLiterals}

Number literals are either integers literals or floating-point literals.

\NumberLiteral{}

\subsubsection{Integer Literals}
\label{integerLiterals}

An {\em integer literal} represents an integer scalar.  Integer literals have type \INT{}.
Integer literals can be expressed in decimal and hexadecimal systems. The prefix `0x` or `0X` indicates a hexadecimal number literal. 

\subsubsection{Floating Point Literals}
\label{floatingPointLiterals}

A {\em floating-point literal} represents a floating point number scalar conforming to the IEEE floating point standard. Floating-point literals have type \FLOAT{}.

Floating-point decimals may also be expressed in scientific notation using `E` or `e`.

The predefined identifier {\tt system::nan}  denotes an IEEE floating point NaN value and has type \FLOAT{} 
[\ref{number}].
The predefined identifier {\tt system::infinity} denotes IEEE floating point positive infinity and has type \FLOAT{}.

{\em
ShapeRank does not distinguish among NaN values.
}


\subsection{String Literals}
\label{stringLiterals}

A {\em string literal} denotes a string valued scalar, and can be written in one of the following forms:

\StringLiteral{}

\begin{itemize}
\item
Single-line string literals are enclosed in double quotes (\textsf{"}), for example \textsf{"}A single line string\textsf{"}. A backslash ($\backslash$) character is used for conventional character escaping.
\item Multi-line string literals are enclosed in triple double quotes.  {\em No escapes may be used.}
\item Verbatim string literals are enclosed in back-ticks (`). Only back-tick characters must be escaped using another back-tick character.
\end{itemize}

The type of a string literal is \STRING.

\subsection{Hyperstream Literals}
\label{hyperstreamLiterals}

\HyperstreamLiteral

Hyperstream literals denote hyperstreams [\ref{hyperstreams}] of fixed length. 


\subsection{Struct Literals}
\label{structLiterals}

A {\em struct literal} defines a record scalar with named fields.

\StructLiteral{}
\Property{}

Let $s \triangleq \LCURLY{}p_1\COLON{} e_1\COMMA{} \ldots \COMMA{} p_n\COLON{} e_n\RCURLY$.


\subsection{Dot Expressions}
\label{dotExpressions}

A {\em dot expression} provides a way to access a member of a struct [\ref{structTypes}] or builtin type.

\DotExpression{}

Let $m \triangleq e\DOT{}p$.

Evaluation of $m$ proceeds as follows:

The expression $e$ is evaluated to $v$. The value of $m$ is the value $v_p$ of the field $p$ of $v$.

Let $T$ be the type of $e$. If $T = \LCURLY{}p_1\COLON{} T_1\COMMA{} \ldots\COMMA{} p_n\COLON{} T_n\RCURLY$ where $p_k = p$, then the type of $m$ is $T_k$. 

It is a compile-time error if $T$ does not have a member named $p$. 

\subsection{Member Expressions}
\label{memberExpression}

A {\em member expression} is either an identifier expression [\ref{identifierExpressions}], a parenthesized expression [\ref{parenthesizedExpressions}], a function call [\ref{calls}], a literal ([\ref{booleanLiterals}, \ref{numberLiterals}, \ref{stringLiterals}, \ref{structLiterals}], \ref{hyperstreamLiterals}), or a dot expression [\ref{dotExpressions}]]. It serves exclusively as a syntactic grouping.


\subsection{Unary Expressions}
\label{unaryExpressions}

A {\em unary expression} is either a member expression [\ref{memberExpression}] or the application of a unary operator to two unary expressions.
A {\em unary operator} is one of the operators \MINUS{} or  \NOT{}. The \MINUS{} operator implements IEEE floating point negation, with type $T \LT: \NUMBER{} \to T$. The \NOT{} operator implements boolean negation with type $\BOOL{} \to \BOOL$.

\UnaryExpression{}

Let $u \triangleq \theta{} e$.

The expression $\theta e$ where $\theta$ is a unary operator, is equivalent to $\theta\LPAREN{}e\RPAREN{}$.

\subsection{Multiplicative Expressions}
\label{multiplicativeExpressions}

A {\em multiplicative expression} is is either a unary expression or the application of a multiplicative operator to two multiplicative expressions.
A {\em multiplicative operator} is one of the operators \TIMES{}, \DIV{}, \MOD{}. The \TIMES{}, \DIV{}, and \MOD{ operators implement IEEE double multiplication, division and remainder, respectively. 

\MultiplicativeExpression{}
\MultiplicativeOp{}

The expression $e_1 \theta e_2$ where $\theta\LPAREN{}p_1\COLON{} T \LT: \NUMBER\COMMA{} p_2\COLON{} T\RPAREN\COLON{}T$ is a multiplicative operator, is equivalent to $\theta\LPAREN{}e_1\COMMA{} e_2\RPAREN$.

\subsection{Additive Expressions}
\label{additiveExpressions}

An {\em additive expression} is either a multiplicative expression [\ref{multiplicativeExpressions}] or the application of an additive operator to two additive expressions.
An {\em additive operator} is one of the operators \PLUS{}, and \MINUS{}. The \PLUS{} and \MINUS{} operators implement IEEE double addition and subtraction, respectively. 

\AdditiveExpression{}
\AdditiveOp{}


The expression $e_1 \theta e_2$ where $\theta$ is an additive operator, is equivalent to $\theta\LPAREN{}e_1\COMMA{} e_2\RPAREN$, where the signature of $\theta$ is $\theta\LPAREN{}T \LT: \NUMBER\COMMA{}T\RPAREN\COLON{} T$.

\subsection{Relational Expressions}
\label{relationalExpressions}

A {\em relational expression} is either an additive expression [\ref{additiveExpressions}] or the application of a relational operator to two relational expressions.
A {\em relational operator} is one of the operators \EQ{}, \NEQ{}, \LT{}, \GT{}, \LTE{}, \GTE{}.

The operators \EQ{}, \NEQ{}, \LT{}, \GT{}, \LTE{}, \GTE{} implement the equal, not equal,  less than, greater than,  less than or equal, greater or equal operators respectively. The \EQ{} and \LT{} operators are defined by equality and the linear orderings among values of types as given in sections \ref{bool}, \ref{number}, \ref{structTypes}.

Let $v_1 \ne {\tt system::nan}, v_2 \ne {\tt system::nan}$ be scalar values. 

$v_1 \NEQ{} v2$ iff it is not the case that $v_1 = v_2$.

$v_1 \LT{} v_2$ iff $v_1 < v_2$.

$v_1 \LTE{} v_2$ iff either $v_1 = v_2$ or $v_1 < v_2$.

$v_1 \GT{} v_2$ iff $v_1 > v_2$.

$v_1 \GTE{} v_2$ iff either $v_1 = v_2$ or $v_1 > v_2$.

In any other case (i.e, if one or both of $v_1, v2$ are {\tt system::nan}) then all the relational operators return false, per the rules of IEEE floating point.

\RelExpression{}
\RelOp{}

The expression $e_1 \theta e_2$ where $\theta$ is a relational operator, is equivalent to $\theta\LPAREN{}e_1\COMMA{} e_2\RPAREN$. For $\theta{} \in \EQ{}, \NEQ{}, \LT{}, \GT{}, \LTE{}, \GTE{}$ the signature of $\theta$ is $\theta\LPAREN{}p_1\COLON{} \DOLLAR{}T\COMMA{} p_2\COLON{} \DOLLAR{}T\RPAREN\COLON{}\BOOL$.


\subsection{Logical And}
\label{logicalAnd}

A {\em logical and expression} is either a relational expression [\ref{relationalExpressions}] or the application of the logical and operator, \AND{}, to two logical and expressions.

\AndExpression{}

The expression $e_1$ \AND{} $e_2$ is equivalent to the conditional expression [\ref{conditional}] 

\IF{} $e_1$ \THEN{} $e_2$ \ELSE{} \FALSE{}.

{\em While the semantic equivalence must be respected, it is advisable to provide specialized error messages when the types of $e_1$ and $e_2$ disagree,  as the expectation here is that $e_2$ is of type \BOOL{}, rather than that \FALSE{} is not of the same type as $e_2$.
}

{\em
Note that logical and is not commutative.
}

\subsection{Logical Or}
\label{logicalOr}

A {\em logical or expression} is either a logical and expression [\ref{logicalAnd}] or the application of the logical or operator, \AND{}, to two logical or expressions.

\OrExpression{}

The expression $e_1$ \OR{} $e_2$ is equivalent to the conditional expression [\ref{conditional}] 

\IF{} $e_1$ \THEN{} \TRUE{} \ELSE{} $e_2$.

{\em
Note that logical or is not commutative.
}


\subsection{Conditional}
\label{conditional}

A {\em conditional expression} allows for control flow based on the evaluation of a predicate.

\ConditionalExpression{}

Let $c \triangleq $ \IF{} $b$ \THEN{} $t$ \ELSE{} $e$.

Evaluation of $c$ proceeds as follows:

The expression $b$ is evaluated. 
If $b$ evaluates to \TRUE{}, $t$ is evaluated to a value $v_t$. The value of $c$ is $v_t$. Otherwise, $e$ is evaluated to a value $v_e$. The value of $c$ is $v_e$.

Let $B$ be the type of $b$, let $T$ is the type of $t$, let $E$ be the type of $e$, and let $C$ be the least common supertype of $T$ and $E$. The type of $c$ is $C$. 

It is a compile-time error if $B$ is not a subtype of \BOOL{}. It is a compile-time error if $T$ is not a subtype of $E$ or vice versa. 

\subsection{Reranking}
\label{reranking}

{\em
Rerank is not a proper declaration, because it does not introduce a name. 
}

A {\em rerank expression} takes an existing function and produces a new one, whose parameters differ in rank but is otherwise the same.

\RerankExpression

Let $r \triangleq  \RERANK{}$ $f$  $\TO{}$ $r_1, \ldots, r_n$.

where $f$ is a function with signature $f(p_1: S_1 T_1, \ldots, p_n: S_n T_n)$ and let $r_i = rank(S_i), i \in 1..n$. Then

Then $r$ evaluates to a function with body $f(a_1, \ldots, a_n)$ and signature 
$x(a_1: [d_{11}]\ldots [d_{1{r_1}}]), \ldots, a_n: [d_{n1}]\ldots [d_{n{r_n}}]))$, where $x$ is name unique in the program, and the $d_{ij}$ are fresh dimension variables, which are not necessarily distinct from each other.

{\em
The precise bindings of the $d_{ij}$ are determined such that they respect the constraints imposed by the body of $x$.

For example:

\RERANK{} * \TO{} 1, 1

produces

$*_{[1,1]}(a: [\DOLLAR{}d_1] Num, b: [\DOLLAR{}d_1] Num) = a * b$

Here, the fresh type variable is shared across both parameters. In contrast, given  $f(a: T, b: [\DOLLAR{}d] T)$

\RERANK{} f \TO{} 2, 1

 produces

$f_{[2,1]}(a: [\DOLLAR{}d_{11}][\DOLLAR{}d_{12}] T, [\DOLLAR{}d_{21}] T) = f(a, b)$

keeping all dimension variables distinct.

The algorithm for computing the signature of the reranked function needs to be specified.
}

A rerank expression can only be used where a function is expected - as the target of a call, or as an argument to a higher-order function.

\subsection{Casts}
\label{casts}

A {\em shape cast expression} can be used to dynamically test whether the shape of an expression matches a specified shape.

\ShapeCastExpression

Let $sc \triangleq \SHAPECAST{}$ $e$ $\TO{}$ $e$.
Let $s_e T_e$ be the type of $e$, and let $v$ be the value of $e$.
Then, if the shape of $v$ is compatible with $s$, the value of $sc$ is $v$, otherwise a runtime error occurs. The type of $sc$ is $s T_e$. 

It is a compile-time error if the $s_e$ is statically incompatible with $s$.

{\em define what 'statically incompatible' means.}



\section{Types}
\label{types}

ShapeRank is a statically typed language. Types describe the values that are used in the program. Every expression in a valid ShapeRank program must have a fixed type that can be determined at compile-time.

{\em 
ShapeRank has a structural type system. Compatibility and equivalence of types is determined by the type's actual structure or definition, and not by  its name.
}

 \subsection{Type Inference}
  \label{typeInference}
  
 ShapeRank does not always require that the types of entities be explicitly declared.  In many cases, the type can be determined by a process of {\em type inference}. The actual rules of type inference for each construct are given in the section describing that construct. However, these rules depend on a common set of concepts, defined in this section.
 
  
  \subsubsection{Type Substitution}
  \label{typeSubstitution}
  
  A {\em type substitution} is a mapping of type, shape and dimension variables [\ref{typeVariables}] to types, shapes and dimensions respectively. We write $[\DOLLAR{}X_1 \to T_1, \ldots\, \DOLLAR{}X_n \to T_n]$ to denote the substitution that maps $\DOLLAR{}X_i$ to $T_i, i \in 1..n$. A substitution $[\DOLLAR{}X_1 \to T_1, \ldots, \DOLLAR{}X_n \to T_n]$ may be {\em applied} to a type (respectively, shape or dimension) $T$, producing a new type (respectively, shape or dimension) where each occurrence of $\DOLLAR{}X_i$ in $T$ is replaced by $T_i ,\in 1..n$.
  
  {\em 
  In our setting, only type schemas bind type , shape and dimension variables, and we only perform substitution on types, shapes and dimensions, so capture is not an issue.
  }
  
If $\theta$ is a substitution, we write $\theta T$ to denote the application of $\theta$ to $T$.

\subsubsection{bool}
\label{bool}

The predefined type \BOOL{} contains the values true and false.  A boolean value is equal only to itself. The value true is greater than false. The type \BOOL{} is equal only to itself.

\subsubsection{number}
\label{number}

 The predefined type \NUMBER{} consists of the types \INT{} and \FLOAT. The type \NUMBER{} is equal only to itself. 
 
 \paragraph{Int.} The predefined type \INT} consists of the integers. Equality and ordering are as defined for the integers in mathematics. The type \INT{} is equal only to itself.

 \paragraph{Float.} The predefined type \FLOAT{} consists of the set of IEEE double precision floating point values.  Equality and ordering are defined by the IEEE floating point standard.  The type \FLOAT{} is equal only to itself.
 

 
\subsubsection{string}
\label{string}

The predefined type \STRING{} is a sequence of zero or more Unicode code points. Equality and ordering of code points are defined by the Unicode standard. 
The strings, $a = a_1, \ldots, a_n$ and $b = b_1, \ldots, b_n$ are equal iff $a_i = b_i, i \in 1..n$. Strings are ordered lexicographically., i.e., $a_1, \ldots, a_n < b_1, \ldots, b_m$ iff  either $a_1 < b_1$ or $a_1 = b1$ and $a_2, \ldots, a_n < b_2, \ldots, b_m$.

The type \STRING{} is equal only to itself. 

\subsubsection{Hyperstream Types}
\label{hyperstreamTypes}

Hyperstream types describe hyperstreams. A hyperstream type is composed of a shape descriptor and an element type. The shape may be omitted, in which case it defaults to $[]$, the empty shape. The hyperstream type $S$ $T$ denotes the set of hyperstreams of shape $S$ with elements of scalar type $T$.

\paragraph{Dimension Descriptors.}
A dimension descriptor has the form $[d]$ where $d$ is one of:
\begin{itemize}
\item An integer literal $n$ [\ref{integerLiterals}]. This indicates the size of the described dimension is the value of $n$.
\item An optional dimension variable [\ref{typeVariables}] $v$, possibly followed by \BANG. This indicates the size of the described dimension is the value of $v$.
The use of the \BANG{} suffix indicates the the described  dimension must be of fixed size. 
{\em ergo, it must be an array, not a stream.}
If $v$ is omitted, we assume a fresh dimension variable was specified. 
\item  \QUESTIONMARK. This indicates the described dimension's size is unbounded.
 \end{itemize}
 
\paragraph{Shape Descriptors.}
 A shape descriptor denotes a shape vector. It takes one of the following forms:
 \begin{itemize}
 \item  A list $[d_1] \ldots [d_n]$, denoting the shape vector $[d_1, \ldots, d_n]$ where $[d_i], i \in 1..n$ are dimension descriptors.
 \item A shape variable [\ref{typeVariables}], possibly followed by \BANG. The use of the \BANG{} suffix indicates the the shape's  dimensions must all be of fixed size. 
 \item A shape append, of the form $s_1 :: s_2$, where $s_1, s_2$ are shape descriptors, denoting the concatenation of the shape vectors denoted by $s1$ and $s_2$. 
 \end{itemize}
 
\paragraph{Scalar Types.}
 A scalar type is either a type variable [\ref{typeVariables}] or one of \BOOL [\ref{bool}],  \NUMBER,[\ref{number}] \INT, \FLOAT, \STRING [\ref{string}], or a struct type [\ref{structTypes}].

\subsubsection{Struct Types}
\label{structTypes}

A value of a struct type is composed of named values, known as {\em fields}. The type of a struct value is determined by the names and the types of the fields that it contains.

\StructType{}

\PropertySig{}

The type \LCURLY{}$f_1 \COLON{} T_1$\COMMA{} \ldots\COMMA{}  $f_k \COLON{} T_k$\RCURLY{} $, (f_i \ne f_j$ for $i \ne j)$ is equal to another type $X$ iff  $X \triangleq $ \LCURLY{}$f_1 \COLON{} S_1$\COMMA{} \ldots\COMMA{}  $f_k \COLON{} S_k$\RCURLY{} and $T_i = S_i, i \in 1..k$.


{\em
Structs are lexicographically ordered if we view structs as maps from field names to field values. 
}

\subsubsection{Type Identifiers}
\label{typeIdentifiers}

A {\em type identifier} denotes a named type available in the current compile-time scope.

Let $i \triangleq T$. If $t$ is the type bound to $T$ in the current compile-time scope, $i$ denotes $t$. 

It is a compile-time error if $T$ does not denote a type in the current compile-time scope.

\subsubsection{Type Variables}
\label{typeVariables}

A {\em type variable} is either a {\em scalar type variable}, a {\em shape variable} or a {\em dimension variable}. Type variables may abstract over types, shapes and dimensions in the context of a type or function [\ref{functions}] declaration. Scalar type variables abstract over  scalar types. Shape variables abstract over the shapes of types. Dimension variables are used both to abstract over the dimensions in a shape, and over integer values, which are typically used as dimensions.

Scalar type, shape and dimension variables may be referred to as type, shape or dimension parameters respectively.

 A declaration can be {\em parameterized} with one or more type variables. A parameterized declaration can be invoked (or instantiated) with different type arguments, allowing a single parameterized declaration to describe a family of (unparameterized) declarations. 
 
 A type variable $t$ is said to {\em free} in some expression, type expression, type schema, signature or scope $x$ if $t$ is not declared in $x$.  More precisely, we define the {\em free type variables} of $x$ as follows:
 
 $free(ID) = \phi$.
 
 $free(\DOLLAR{}ID) = \{\DOLLAR{}ID\}$ 
 
 $free([T]) = free(T)$.
 
 $free([K \COLON{} V]) = free(K) \cup free(V)$.
 
 $free(\{f_1\COLON{} T_1, \ldots, f_n\COLON{} T_n\}) =  free(T_1) \cup \ldots \cup free(T_n)$.
 
 $free(T_1, \ldots, T_n \to T_r) = (free(T_1) \cup \ldots free(T_n)) \cup free(T_r)$. 
 
 $free(F\LPAREN{} T_1\COMMA{} \ldots\COMMA{} T_n\RPAREN\COLON{}T_r) = free(\forall S_1, \ldots, S_k. T_1, \ldots, T_n \to T_r$ where $S_i \in 1..k$ are the type variables implicitly introduced in by $T_1, \ldots, T_n$.
 
 $free(\forall T_1, \ldots, T_n.T) = free(T) - \{T_1, \ldots, T_n\}$.
 
 
 We say a type variable $\DOLLAR{}X$ is free in a scope $S$, if there exists an identifier $ID$ with type $T$ defined in $S$, and $\DOLLAR{}X$ is free in $T$. The free type variables of $S$ are the set of all type variables that are free in $S$.

\paragraph{Scalar Type Variables.}
 
 Let $p \triangleq \DOLLAR{}T$.
 
 Let $t$ be the type variable bound to $\DOLLAR{}T$ in the current compile-time scope. If $\DOLLAR{}T$ is not bound in the current compile-time scope, then, if $p$ occurs within  the parameter list of a function signature [\ref{functions}],  a binding of $\DOLLAR{}T$ to a fresh type variable $t$ is added to the current compile-time scope. In either case, $p$ denotes  $t$. 
 
 {\em 
No explicit declaration of a type variable is needed. They are declared by their first use, provided the use occurs in a function signature. This restriction reduces the attendant risk of inadvertently introduced parameters; furthermore, since
 actual type arguments are inferred, such inconsistencies are likely to be caught due to a mismatch between actuals and formals.
 } 
 
 It is a compile-time error if $p$ is neither available in the enclosing compile-time scope, nor enclosed in the parameter list of a function signature.
 
 \paragraph{Dimension Variables.}
 
 Let $p \triangleq \DOLLAR{}d$.
 
 Let $t$ be the dimension variable bound to $\DOLLAR{}d$ in the current compile-time scope. If $\DOLLAR{}d$ is not bound in the current compile-time scope, then, if $p$ occurs within the parameter list of a function signature [\ref{functions}],  a binding of $\DOLLAR{}d$ to a fresh dimension variable $t$ is added to the current compile-time scope. In either case, $p$ denotes  $t$. 

 
 It is a compile-time error if $p$ is neither available in the enclosing compile-time scope, nor enclosed in the parameter list of a function signature.
 
 \paragraph{Shape Variables.}


 Let $p \triangleq \ATSIGN{}{}S$.
 
 Let $t$ be the shape variable bound to  $\ATSIGN{}{}S$ in the current compile-time scope. If $\ATSIGN{}{}S$ is not bound in the current compile-time scope, then, if $p$ occurs within the parameter list of a function signature [\ref{functions}],  a binding of  $\ATSIGN{}{}S$ to a fresh shape variable $t$ is added to the current compile-time scope. In either case, $p$ denotes  $t$. 
 
 It is a compile-time error if $p$ is neither available in the enclosing compile-time scope, nor enclosed in the parameter list of a function signature.
 

 
\subsection{Function Types}
\label{functionTypes}

A {\em function type} describes the type of a function [\ref{functions}].

A function type consists of a domain and a range. A {\em domain} is a list of types, composed from the types of the formal parameters of a function, in the order they appear in the function declaration. A {\em range} is a result type of a function. 
We write a  function type as $T_1, \ldots, T_n \to T_r$, where $T_1, \ldots, T_n$ is the domain and $T_r$ is the range.

Function types are used internally in this specification, but have no direct syntactic representation.

{\em 
Naturally, as ShapeRank does not support user-defined higher order functions.

Function types  are derived from function signatures [\ref{functions}].
}



\section{Lexical Rules}
\label{lexicalRules}
\printlexitable

\section{Grammar}
\label{grammar}
\printgrammartable



\end{document}