\documentclass{article}
\usepackage{epsfig}
\usepackage{hyperref}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{textcomp}

\input{shapeRank.sty}
\begin{document}
\title{ShapeRank Language Specification\\
{\large Version 0.1}
}
\maketitle

\tableofcontents

\section{Introduction}

ShapeRank is a purely functional, decidable, rank-polymorphic statically typed language. It is designed for use in data analysis and machine learning. 

All values in ShapeRank are hyperstreams [\ref{concepts}]. A {\em hyperstream} is either a scalar, [\ref{scalars}] or a sequence, also known as a {\em stream} [\ref{streams}], whose elements are hyperstreams. Streams may be of a known finite size, or they may be unbounded. 

ShapeRank does not support user-defined higher order functions. However, a number of useful higher-order functions are built in to the language. User defined functions may be used as arguments to these.

The language does not permit recursion and has no explicit looping constructs. These are not needed, since all iteration is implicit, dictated by the shape of the data. As a result, a program written entirely in ShapeRank can never diverge or crash. 

ShapeRank has no constructs to create recursive data structures, and so any data a program creates is is acyclic. Hence, reference counting is a sufficient strategy for memory reclamation.



\subsection{Conventions}
\label{conventions}

In this specification, normative text appears in roman font. Defined concepts are given in {\em italic font}. Non-normative commentary is given in {\em italic font}.

{\em Commentary is useful for adding explanations, motivations, context etc.}

{\em 
The specification does not detail syntax errors. Syntactically erroneous situations are implicitly defined by the syntax productions herein.
}

Constructs that are syntactically valid but are illegal for other reasons result in compile-time errors. The circumstances leading to such compile-time errors are described on an individual basis in this specification.

{\em
Examples include expressions that do not have a valid type or references to undeclared or multiply declared entities.
}

\subsubsection{Presentation of Syntax}

Syntax productions are given in a form of EBNF. The name of a production is given in {\bf bold}.  All non-terminals are enclosed in angle brackets. The symbol $\rightarrow$ is used to separate a production's left and right sides. Alternatives are separated by the $|$ symbol. Parentheses are used for grouping. The postfix $*$ denotes zero or more repetitions, and postfix $+$ denotes one or more repetitions. Optional items are postfixed by $?$. To distinguish terminals from EBNF notation, terminals appear in {\color{blue} blue}.

{\em Examples:}
\begin{itemize}
\item \BuiltinType
\item  \HyperstreamLiteral
\end{itemize}


Lexical rules are similar, but the names of lexical productions are always given in uppercase, and the left and right hand sides are separated by ::=.


\section{Concepts}
\label{concepts}

A {\em hyperstream} consists of either a scalar, or a sequence, also known as a {\em stream}, whose elements are hyperstreams, along with 
 zero or more {\em dimensions}, a {\em shape} and a {\em rank}. A dimension has a {\em length} (also referred to as its {\em size}), which is either an integer or \QUESTIONMARK.

The shape is a vector of the lengths of the hyperstream's dimensions. The rank is the length of the shape.

{\em
The rank therefore gives the number of dimensions in the hyperstream.
}

\subsection{Scalars}
\label{scalars}

The most elementary hyperstreams are {\em scalar hyperstreams}. These include  booleans [\ref{bool}], numbers [\ref{number}], strings [\ref{string}] and  structs [\ref{structTypes}]. A scalar hyperstream consists of a single scalar value, and has zero dimensions, hence its shape is the empty sequence, $[]$. The rank of a scalar hyperstream is therefore $0$. We will often refer to scalar hyperstreams simply as scalars.

\subsection{Streams}
\label{streams}

A {\em stream} is a sequence of {\em elements}.  A stream may be {\em bounded} or {\em unbounded}. A bounded stream has a known finite length; the length of an unbounded stream, is not known and is potentially infinite.

A non-scalar hyperstream consists of a stream, $s$, of hyperstreams. All elements of $s$ must have a common type.  

The shape of a non-scalar hyperstream is a vector whose first element is the number of elements of $s$ (if $s$ is bounded) or \QUESTIONMARK if $s$ is unbounded, and
whose remainder is given by the shape of the elements of $s$.

{\em The above implies all elements of $s$ have the same rank and common element type, and each of their dimensions is either the same or \QUESTIONMARK}


\subsection{Reactivity and Synchronicity}
\label{reactivityAndSynchronicity}

A function is {\em reactive} if it fires whenever new data is available on any of its inputs. Otherwise it is {\em synchronous}.


\section{Let Bindings}
\label{letBindings}

A {\em let binding} assigns a value to an identifier. 

\LetBinding{}

The expression $\LET{}$ $ID$ \BIND{} $e$ is equivalent to $\LET{}$ $ID$\COLON{} $T$ \BIND{} $e$  where $T$ is the type of $e$.
Let  $l \triangleq $ \LET{} $ID$\COLON{} $T$ \BIND{} $e$

The effect of $l$ is that variable $ID$ is added to the enclosing program's compile-time scope, with type [\ref{types}] $T$.


\section{Functions}
\label{functions}

\FunctionDeclaration

A function declaration defines a transformation of one or more input streams into an output stream. A function declaration has a
{\em function signature} which specifies the name of the function, and the type of each of its parameters.

{\em The type of a parameter will specify its element type and its shape (and therefore its rank). }

If the keyword \SYNC precedes the keyword \FUNC, the function is synchronous [\ref{reactivityAndSynchronicity}], otherwise it is reactive.

\FunctionSignature{}

\FunctionSignatureOptionalReturn{}

\ParameterList{}

\Parameter{}

A function signature has the form  $F\LPAREN{}p_1\COLON T_1\COMMA{} \ldots\COMMA{} p_n\COLON T_n\RPAREN{}\COLON T_r$ where $F$ is an identifier that specifies the name of the function, and $p_i\COLON{} T_i, i \in 1..n$ specify the function's parameters; each $p_i$ is an identifier that names the $i$th parameter, and the corresponding $T_i$ is a type [\ref{types}], which implicitly specifies the parameter's rank.  Finally, $T_r$ specifies the {\em return type}, the type of a call [\ref{calls}] of a function that has said signature. The specification of the return type may be omitted in certain circumstances where it may be inferred, as discussed in section \ref{dexFunctions}.
The signature corresponds to the function type [\ref{functionTypes}] $T_1, \ldots, T_n \to T_r$.

{\em
Note that,  as described in section \ref{typeVariables}, the parameter list may implicitly declare type variables. However, the return type $T_r$ may not. If type variables are introduced, the resulting function type will of course be polymorphic. 
}

Processing a function signature has the following effect:

A new scope, $s_{sig}$, is introduced. The scope $s_{sig}$ is nested in the compile-time scope of the enclosing module definition, $s_m$, yielding a scope $s \triangleq s_m \leftarrow s_{sig}$. The scope $s$ is known as {\em the compile-time scope of the function signature}.
The current compile-time scope is set to $s$, and the types of the formal parameters and the return type are checked in accordance with the rules of section \ref{typeExpressions}. Then the current compile-time scope is set back to $s_m$.

{\em 
The function signature scope is intended to contain bindings for any type variables [\ref{typeVariables}] that are introduced in the parameter list.
}

It is a compile-time error if $p_i = p_j, i \ne j$.

The function declaration \FUNC{}  $F\LPAREN{}p_1\COLON T_1\COMMA{} \ldots\COMMA{} p_n\COLON T_n\RPAREN{}$  \BIND{} $e$ is equivalent to \FUNC{} $F\LPAREN{}p_1\COLON T_1\COMMA{} \ldots\COMMA{} p_n\COLON T_n\RPAREN{}\COLON T_e$  \BIND{} $e$ where $T_e$ is the type of $e$ in the function's compile-time scope.

Let $f \triangleq$ \FUNC{} $F\LPAREN{}p_1\COLON T_1\COMMA{} \ldots\COMMA{} p_n\COLON T_n\RPAREN{}\COLON T_r$  \BIND{} $e$.

Processing of $f$  has the following effect:

A binding of $F$ to $f$ is added to the compile-time scope of the enclosing program with the type schema [\ref{typeGeneralization}] $generalize(T_1, \ldots, T_n \to T_r)$ [\ref{functionTypes}].

{\em
Generalization produces a type schema (aka polymorphic type) for the function, that will be instantiated separately at every call, allowing the function to be used polymorphically. 
}

 Then the function signature is processed. Let $s_0$ be the compile-time scope of the function signature.
A new scope $s$ is created, and is known as the {\em immediate scope of} $f$. The scope $s_0 \leftarrow s$ is known as {\em the compile-time scope of $f$}.

{\em Thus, $s$ is nested in the function signature's scope, which is nested in the enclosing module definition scope.}

The variables $p_i$ are added to $s$, with types $T_i, i \in 1..n$ respectively.

Let $T_e$ be the type of $e$ in $s$. 
It is a compile-time error if  $T_e$ is not a subtype [\ref{subtyping}] of $T_r$.  It is a compile-time error if the compile-time scope of the enclosing program contains another declaration named $F$.



\section{Expressions}
\label{expressions}

Expressions evaluate values. Values are computed relative to a runtime scope. When we say that $e$ evaluates to $v$, we mean it evaluates to $v$ in the current runtime scope. 

Every expression in a legal ShapeRank program has a type [\ref{types}] that is determined statically, at compile-time. If no type can be determined for an expression, the expression and its enclosing program are illegal and a compile-time error must result. The process of determining the type of an expression is known as type inference [\ref{typeInference}]. Type inference  is usually dependent on the compile-time scope in which it occurs. When we say that an expression $e$ has type $T$, we mean that $e$ has type $T$ in the current compile-time scope.

\subsection{Identifier Expressions}
\label{identifierExpressions}

An {\em identifier expression} consists of a single identifier.

\IdentifierExpression{}

Let $i \triangleq ID$.
Evaluation of $i$ proceeds as follows:


Let $s$ be the the current runtime scope. Then $ID$ iusd looked up in $s$. $ID$ must be either a variable or a function.
\begin{itemize}
\item If $ID$ is bound to a variable $b$, then if no value is associated with $b$ then the definition of $b$ is executed. The value $v$ of $ID$ is then looked up in $s$. The value of $i$ is $v$.

{\em In the case where no value is associated with the variable, it is necessarily defined via  a \LET{} binding. The above reflects the lazy evaluation of \LET{}.}

\item If $ID$ is bound to a function $f$, then value of $i$ is $f$. 
\end{itemize}

The type of $i$ is the type associated with $ID$ in the enclosing compile-time scope.

It is a compile-time error if $ID$ is bound to a type. 


\subsection{Parenthesized Expressions}
\label{parenthesizedExpressions}

{\bf ParenthesizedExpression} $\rightarrow$ \LPAREN{} Expression \RPAREN{} $|$ \LPAREN{} Expression TypeSigSuffix \RPAREN{}


The expression  $\LPAREN{}e \RPAREN{}$ is equivalent to the expression $\LPAREN{}e \COLON{} T \RPAREN{}$ where $T$ is the type of $e$.

Let $p \triangleq \LPAREN{}e \COLON{} T \RPAREN{}$.

Evaluation of $p$ proceeds as follows:

The expression $e$ is evaluated to $v$. The value of $p$ is $v$.

The type of $p$ is $T$.

\subsection{Calls}
\label{calls}

A {\em call} invokes a function [\ref{functions}]. To understand the semantics of calls, we need the auxiliary concepts of frames, cells and replication.


\subsubsection{Frames and Cells}
\label{framesAndCells}

Hyperstreams can be divided into frames and cells. A {\em frame} is a hyperstream whose elements are also hyperstreams, called {\em cells}.

{\em As an example, the matrix 

2 3 4

5 6 7

 can be viewed as a pair of two 3-vectors:
[[2 3 4] [5 6 7]]

In that case, the frame is a 2-vector and the cells are 3-vectors.  Alternately, we can view it as a matrix, in which case the frame is the entire hyperstream, and the cells are scalars. A third way is to view the hyperstream as a frame of rank 0, which consists of a single cell of rank 2. In general, a hyperstream of rank $n$ can be decomposed into frames and cells in $n+1$ ways: a rank $n$ hyperstream with rank 0 elements, a rank $n-1$ hyperstream with vector elements, â€¦, a rank 1 vector with rank $n-1$ cells, or a rank 0 frame with a single rank $n$ cell.
}

A hyperstream $h$, of shape $[d_1, \ldots, d_n]$ may be divided into a frame, $f_h$ of shape $[d_1, \ldots, d_k]$ and cells of shape $[d_{k+1}, , \ldots, d_n]$, for any $0 > k > n$.
The cells are the elements of the $h[1] \ldots [k]$ are known as the cells of of $f_h$.

\subsubsection{Replication}
\label{replication}

A frame $f_0$ of shape $[d_1, \ldots, d_k]$ may be replicated into a larger frame, $f_r$ of shape of shape $d_1, \ldots, d_n$ for any $n$ where $n \ge k$. Each cell of $f_r$ is equal to $f_0$.




\subsubsection{Call Evaluation}
\label{callEvaluation}

Let $c \triangleq F\LPAREN{}a_1\COMMA{} \ldots\COMMA{} a_k\RPAREN$. Evaluation of $c$ proceeds as follows. 

Let $ar_i$ be the rank of $a_i$ and let $pr_i$ be the rank of $p_i, i \in 1.. k$. Then  $a_i$ is divided into a frame $f_i$, of rank $ar_i - pr_i$ with cells of rank $p_i$. Let $max\_frame \in \{i \in 1..k | f_i\}$ be a frame such that $rank(max\_frame) \ge rank(f_i), i \in 1 ..k$. Next, $f_i$ is replicated into a frame $af_i$, of shape $shape(max\_frame), i \in 1..k$. 
If $F$ is reactive[\ref{reactivityAndSynchronicity}], let $zip = zip_{react_k}$, otherwise let $zip = zip_{sync_k}$.

{\em Still need to define map and zip functions precisely.}

Then, let $r$ be the value of $map(zip(af_1, \ldots, af_k), F)$. $c$ evaluates to $r$.

{\em
Every formal parameter has an expected rank. However, arguments may be of higher rank. An argument of rank $n$ may be passed where a parameter of rank $k$ is expected, provided $n \ge k$. The argument is viewed as a frame of rank $n-k$ with cells of rank $k$. 
}

It is a compile-time error if $ar_i < pr_i, i \in 1..k$. It is a compile-time error if $shape(f_i)$ is not a prefix of $shape(max\_frame), i \in 1..k$. 


\subsection{Boolean Literals}
\label{booleanLiterals}

The identifiers \TRUE{} and \FALSE{} are predefined,  denoting the booleans true and false respectively, and have type \BOOL{} [\ref{bool}].

{\bf BoolLiteral} $\rightarrow$ \TRUE{} $|$ \FALSE{}

\subsection{Number Literals}
\label{numberLiterals}

Number literals are either integers literals or floating-point literals.

\NumberLiteral{}

\subsubsection{Integer Literals}
\label{integerLiterals}

An {\em integer literal} represents an integer.  Integer literals have type \INT{}.
Integer literals can be expressed in decimal and hexadecimal systems. The prefix `0x` or `0X` indicates a hexadecimal number literal. 

\subsubsection{Floating Point Literals}
\label{floatingPointLiterals}

A {\em floating-point literal} represents a floating point number conforming to the IEEE floating point standard. Floating-point literals have type \FLOAT{}.

Floating-point decimals may also be expressed in scientific notation using `E` or `e`.

The predefined identifier {\tt system::nan}  denotes an IEEE floating point NaN value and has type \FLOAT{} 
[\ref{number}].
The predefined identifier {\tt system::infinity} denotes IEEE floating point positive infinity and has type \FLOAT{}.

{\em
ShapeRank does not distinguish among NaN values.
}


\subsection{String Literals}
\label{stringLiterals}

A {\em string literal} can be written in one of the following forms:

\StringLiteral{}

\begin{itemize}
\item
Single-line string literals are enclosed in double quotes (\textsf{"}), for example \textsf{"}A single line string\textsf{"}. A backslash ($\backslash$) character is used for conventional character escaping.
\item Multi-line string literals are enclosed in triple double quotes.  {\em No escapes may be used.}
\item Verbatim string literals are enclosed in back-ticks (`). Only back-tick characters must be escaped using another back-tick character.
\end{itemize}

The type of a string literal is \STRING.

\subsection{Hyperstream Literals}
\label{hyperstreamLiterals}

\HyperstreamLiteral

Hyperstream literals denote hyperstreams of known size. 


\subsection{Struct Literals}
\label{structLiterals}

A {\em struct literal} defines a record of named fields.

\StructLiteral{}
\Property{}

Let $s \triangleq \LCURLY{}p_1\COLON{} e_1\COMMA{} \ldots \COMMA{} p_n\COLON{} e_n\RCURLY$.


\subsection{Dot Expressions}
\label{dotExpressions}

A {\em dot expression} provides a way to access a member of a struct [\ref{structTypes}] or builtin type.

\DotExpression{}

Let $m \triangleq e\DOT{}p$.

Evaluation of $m$ proceeds as follows:

The expression $e$ is evaluated to $v$. The value of $m$ is the value $v_p$ of the field $p$ of $v$.

Let $T$ be the type of $e$. If $T = \LCURLY{}p_1\COLON{} T_1\COMMA{} \ldots\COMMA{} p_n\COLON{} T_n\RCURLY$ where $p_k = p$, then the type of $m$ is $T_k$. 

It is a compile-time error if $T$ does not have a member named $p$. 

\subsection{Member Expressions}
\label{memberExpression}

A {\em member expression} is either an identifier expression [\ref{identifierExpressions}], a parenthesized expression [\ref{parenthesizedExpressions}], a function call [\ref{calls}], a literal ([\ref{booleanLiterals}, \ref{numberLiterals}, \ref{characterLiterals}, \ref{stringLiterals}, \ref{structTypesLiterals}], \ref{hyperstreamLiterals}), or a dot expression [\ref{dotExpressions}]]. It serves exclusively as a syntactic grouping.


\subsection{Unary Expressions}
\label{unaryExpressions}

A {\em unary expression} is either a member expression [\ref{memberExpression}] or the application of a unary operator to two unary expressions.
A {\em unary operator} is one of the operators \MINUS{} or  \NOT{}. The \MINUS{} operator implements IEEE floating point negation, with type $T \LT: \NUMBER{} \to T$. The \NOT{} operator implements boolean negation with type $\BOOL{} \to \BOOL$.

\UnaryExpression{}

Let $u \triangleq \theta{} e$.

The expression $\theta e$ where $\theta$ is a unary operator, is equivalent to $\theta\LPAREN{}e\RPAREN{}$.

\subsection{Multiplicative Expressions}
\label{multiplicativeExpressions}

A {\em multiplicative expression} is is either a unary expression or the application of a multiplicative operator to two multiplicative expressions.
A {\em multiplicative operator} is one of the operators \TIMES{}, \DIV{}, \MOD{}. The \TIMES{}, \DIV{}, and \MOD{ operators implement IEEE double multiplication, division and remainder, respectively. 

\MultiplicativeExpression{}
\MultiplicativeOp{}

The expression $e_1 \theta e_2$ where $\theta\LPAREN{}p_1\COLON{} T \LT: \NUMBER\COMMA{} p_2\COLON{} T\RPAREN\COLON{}T$ is a multiplicative operator, is equivalent to $\theta\LPAREN{}e_1\COMMA{} e_2\RPAREN$.

\subsection{Additive Expressions}
\label{additiveExpressions}

An {\em additive expression} is either a multiplicative expression [\ref{multiplicativeExpressions}] or the application of an additive operator to two additive expressions.
An {\em additive operator} is one of the operators \PLUS{}, \MINUS{} and \CONCAT{}. The \PLUS{} and \MINUS{} operators implement IEEE double addition and subtraction, respectively. The \CONCAT{} operator implements list concatenation.

\AdditiveExpression{}
\AdditiveOp{}


The expression $e_1 \theta e_2$ where $\theta$ is an additive operator, is equivalent to $\theta\LPAREN{}e_1\COMMA{} e_2\RPAREN$, where the signature of $\theta$ is $\theta\LPAREN{}T \LT: \NUMBER\COMMA{}T\RPAREN\COLON{} T$ if  $\theta = \PLUS{}$ or  $\theta = \MINUS{}$, or  $\theta\LPAREN{}\LBRACK\DOLLAR{}T\RBRACK\COMMA{}\LBRACK\DOLLAR{}T\RBRACK\RPAREN\COLON\LBRACK\DOLLAR{}T\RBRACK$ otherwise.

\subsection{Relational Expressions}
\label{relationalExpressions}

A {\em relational expression} is either an additive expression [\ref{additiveExpressions}] or the application of a relational operator to two relational expressions.
A {\em relational operator} is one of the operators \EQ{}, \NEQ{}, \LT{}, \GT{}, \LTE{}, \GTE{}.

The operators \EQ{}, \NEQ{}, \LT{}, \GT{}, \LTE{}, \GTE{} implement the equal, not equal,  less than, greater than,  less than or equal, greater or equal operators respectively. The \EQ{} and \LT{} operators are defined by equality and the linear orderings among values of types as given in sections \ref{bool}, \ref{char}, \ref{number}, \ref{list}, \ref{map}, \ref{structTypes}.

Let $v_1 \ne {\tt system::nan}, v_2 \ne {\tt system::nan}$ be values. 

$v_1 \NEQ{} v2$ iff it is not the case that $v_1 = v_2$.

$v_1 \LT{} v_2$ iff $v_1 < v_2$.

$v_1 \LTE{} v_2$ iff either $v_1 = v_2$ or $v_1 < v_2$.

$v_1 \GT{} v_2$ iff $v_1 > v_2$.

$v_1 \GTE{} v_2$ iff either $v_1 = v_2$ or $v_1 > v_2$.

In any other case (i.e, if one or both of $v_1, v2$ are {\tt system::nan}) then all the relational operators return false, per the rules of IEEE floating point.

\RelExpression{}
\RelOp{}

The expression $e_1 \theta e_2$ where $\theta$ is a relational operator, is equivalent to $\theta\LPAREN{}e_1\COMMA{} e_2\RPAREN$. For $\theta{} \in \EQ{}, \NEQ{}, \LT{}, \GT{}, \LTE{}, \GTE{}$ the signature of $\theta$ is $\theta\LPAREN{}p_1\COLON{} \DOLLAR{}T\COMMA{} p_2\COLON{} \DOLLAR{}T\RPAREN\COLON{}\BOOL$.


\subsection{Logical And}
\label{logicalAnd}

A {\em logical and expression} is either a relational expression [\ref{relationalExpressions}] or the application of the logical and operator, \AND{}, to two logical and expressions.

\AndExpression{}

The expression $e_1$ \AND{} $e_2$ is equivalent to the conditional expression [\ref{conditional}] 

\IF{} $e_1$ \THEN{} $e_2$ \ELSE{} \FALSE{}.

{\em While the semantic equivalence must be respected, it is advisable to provide specialized error messages when the types of $e_1$ and $e_2$ disagree,  as the expectation here is that $e_2$ is of type \BOOL{}, rather than that \FALSE{} is not of the same type as $e_2$.
}

{\em
Note that logical and is not commutative.
}

\subsection{Logical Or}
\label{logicalOr}

A {\em logical or expression} is either a logical and expression [\ref{logicalAnd}] or the application of the logical or operator, \AND{}, to two logical or expressions.

\OrExpression{}

The expression $e_1$ \OR{} $e_2$ is equivalent to the conditional expression [\ref{conditional}] 

\IF{} $e_1$ \THEN{} \TRUE{} \ELSE{} $e_2$.

{\em
Note that logical or is not commutative.
}


Evaluation of $s$ proceeds as follows:

The expressions $e_i$ are evaluated, respectively, to $v_i, i \in 1..n$. 

The value of $s$ is a record with fields $p_i$ with values of $v_i, i \in 1..n$. 

The type of $s$ is $\LCURLY{}p_1\COLON{} T_1\COMMA{} \ldots\COMMA{} p_n\COLON{} T_n\RCURLY\BANG$ [\ref{structTypes}], where $T_i$ is the type of $e_i, i \in 1..n$.

\subsection{Conditional}
\label{conditional}

A {\em conditional expression} allows for control flow based on the evaluation of a predicate.

\ConditionalExpression{}

Let $c \triangleq $ \IF{} $b$ \THEN{} $t$ \ELSE{} $e$.

Evaluation of $c$ proceeds as follows:

The expression $b$ is evaluated. 
If $b$ evaluates to \TRUE{}, $t$ is evaluated to a value $v_t$. The value of $c$ is $v_t$. Otherwise, $e$ is evaluated to a value $v_e$. The value of $c$ is $v_e$.

Let $B$ be the type of $b$, let $T$ is the type of $t$, let $E$ be the type of $e$, and let $C$ be the least common supertype of $T$ and $E$. The type of $c$ is $C$. 

It is a compile-time error if $B$ is not a subtype of \BOOL{}. It is a compile-time error if $T$ is not a subtype of $E$ or vice versa. 


\section{Types}
\label{types}

ShapeRank is a statically typed language. Types describe the values that are used in the program. Every expression in a valid ShapeRank program must have a fixed type that can be determined at compile-time.

{\em 
ShapeRank has a structural type system. Compatibility and equivalence of types is determined by the type's actual structure or definition, and not by  its name.
}

 \subsection{Type Inference}
  \label{typeInference}
  
 ShapeRank does not always require that the types of entities be explicitly declared.  In many cases, the type can be determined by a process of {\em type inference}. The actual rules of type inference for each construct are given in the section describing that construct. However, these rules depend on a common set of concepts, defined in this section.
 
  
  \subsubsection{Type Substitution}
  \label{typeSubstitution}
  
  A {\em type substitution} is a mapping of type, shape and dimension variables [\ref{typeVariables}] to types, shapes and dimensions respectively. We write $[\DOLLAR{}X_1 \to T_1, \ldots\, \DOLLAR{}X_n \to T_n]$ to denote the substitution that maps $\DOLLAR{}X_i$ to $T_i, i \in 1..n$. A substitution $[\DOLLAR{}X_1 \to T_1, \ldots, \DOLLAR{}X_n \to T_n]$ may be {\em applied} to a type (respectively, shape or dimension) $T$, producing a new type (respectively, shape or dimension) where each occurrence of $\DOLLAR{}X_i$ in $T$ is replaced by $T_i ,\in 1..n$.
  
  {\em 
  In our setting, only type schemas bind type , shape and dimension variables, and we only perform substitution on types, shapes and dimensions, so capture is not an issue.
  }
  
If $\theta$ is a substitution, we write $\theta T$ to denote the application of $\theta$ to $T$.

\subsubsection{bool}
\label{bool}

The predefined type \BOOL{} contains the values true and false.  A boolean value is equal only to itself. The value true is greater than false. The type \BOOL{} is equal only to itself.

\subsubsection{number}
\label{number}

 The predefined type \NUMBER{} consists of the set of IEEE double precision floating point values.
 
 Equality and ordering are defined by the IEEE floating point standard. The type \NUMBER{} is equal only to itself.
 
\subsubsection{string}
\label{string}

The predefined type \STRING{} consists of the set of all lists [\ref{list}] whose elements are Unicode code points. Equality and ordering of code points are defined by the Unicode standard. 

\subsubsection{Tensor Types}
\label{tensorTypes}

Tensor types describe hyperstreams. A tensor type is composed of a shape and an element type. The shape is either a list of dimensions, a shape variable, or a shape append. The shape may be omitted, in which case it defaults to $[]$, the empty shape. The tensor type $S$ $T$ denotes the set of hyperstreams of shape $S$ with elements of type $T$.


\subsubsection{Struct Types}
\label{structTypes}

A value of a struct type is composed of named values, known as {\em fields}. The type of a struct value is determined by the names and the types of the fields that it contains.

\StructType{}

\PropertySig{}

The type \LCURLY{}$f_1 \COLON{} T_1$\COMMA{} \ldots\COMMA{}  $f_k \COLON{} T_k$\RCURLY{} $, (f_i \ne f_j$ for $i \ne j)$ is equal to another type $X$ iff  $X \triangleq $ \LCURLY{}$f_1 \COLON{} S_1$\COMMA{} \ldots\COMMA{}  $f_k \COLON{} S_k$\RCURLY{} and $T_i = S_i, i \in 1..k$.


{\em
Structs are lexicographically ordered if we view structs as maps from field names to field values. 
}

\subsubsection{Type Identifiers}
\label{typeIdentifiers}

A {\em type identifier} denotes a named type available in the current compile-time scope.

Let $i \triangleq T$. If $t$ is the type bound to $T$ in the current compile-time scope, $i$ denotes $t$. 

It is a compile-time error if $T$ does not denote a type in the current compile-time scope.

\subsubsection{Dependent Type Variables}
\label{typeVariables}

A {\em dependent type variable} is either a {\em type variable}, a {\em shape variable} or a {\em dimension variable}. Dependent type variables may abstract over types, shapes and dimensions in the context of a type or function [\ref{functions}] declaration. Type variables abstract over types. Shape variables abstract over the shapes of types. Dimension variables are used both to abstract over the dimensions in a shape, and over integer values, which are typically used as dimensions.

Type, shape and dimension variables may be referred to as type, shape or dimension parameters respectively.

 A declaration can be {\em parameterized} with one or more dependent type variables. A parameterized declaration can be invoked (or instantiated) with different type arguments, allowing a single parameterized declaration to describe a family of (unparameterized) declarations. 
 
 \TYPEPARAM{}
 \SHAPEPARAM{}
 \DIMPARAM{}
 
 Let $p \triangleq \DOLLAR{}T$.
 
 Let $t$ be the type variable bound to $\DOLLAR{}T$ in the current compile-time scope. If $\DOLLAR{}T$ is not bound in the current compile-time scope, then, if $p$ occurs within  the parameter list of a function signature [\ref{functionSignatures}],  a binding of $\DOLLAR{}T$ to a fresh type variable $t$ is added to the current compile-time scope. In either case, $p$ denotes  $t$. 
 
 {\em 
No explicit declaration of a type variable is needed. They are declared by their first use, provided the use occurs in a function signature. This restriction reduces the attendant risk of inadvertently introduced parameters; furthermore, since
 actual type arguments are inferred, such inconsistencies are likely to be caught due to a mismatch between actuals and formals.
 } 
 
 It is a compile-time error if $p$ is neither available in the enclosing compile-time scope, nor enclosed in the parameter list of a function signature.
 
 Let $p \triangleq \DOLLAR{}d$.
 
 Let $t$ be the dimension variable bound to $\DOLLAR{}d$ in the current compile-time scope. If $\DOLLAR{}d$ is not bound in the current compile-time scope, then, if $p$ occurs within the parameter list of a function signature [\ref{functionSignatures}],  a binding of $\DOLLAR{}d$ to a fresh dimension variable $t$ is added to the current compile-time scope. In either case, $p$ denotes  $t$. 

 
 It is a compile-time error if $p$ is neither available in the enclosing compile-time scope, nor enclosed in the parameter list of a function signature.
 
 Let $p \triangleq @{}S$.
 
 Let $t$ be the shape variable bound to  $@{}S$ in the current compile-time scope. If $@{}S$ is not bound in the current compile-time scope, then, if $p$ occurs within the parameter list of a function signature [\ref{functionSignatures}],  a binding of  $@{}S$ to a fresh shape variable $t$ is added to the current compile-time scope. In either case, $p$ denotes  $t$. 
 
 It is a compile-time error if $p$ is neither available in the enclosing compile-time scope, nor enclosed in the parameter list of a function signature.
 
 A type variable $t$ is said to {\em free} in some expression, type expression, type schema, signature or scope $x$ if $t$ is not declared in $x$.  More precisely, we define the {\em free type variables} of $x$ as follows:
 
 $free(ID) = \phi$.
 
 $free(\DOLLAR{}ID) = \{\DOLLAR{}ID\}$ 
 
 $free([T]) = free(T)$.
 
 $free([K \COLON{} V]) = free(K) \cup free(V)$.
 
 $free(\{f_1\COLON{} T_1, \ldots, f_n\COLON{} T_n\}) =  free(T_1) \cup \ldots \cup free(T_n)$.
 
 $free(T_1, \ldots, T_n \to T_r) = (free(T_1) \cup \ldots free(T_n)) \cup free(T_r)$. 
 
 $free(F\LPAREN{} T_1\COMMA{} \ldots\COMMA{} T_n\RPAREN\COLON{}T_r) = free(\forall S_1, \ldots, S_k. T_1, \ldots, T_n \to T_r$ where $S_i \in 1..k$ are the type variables implicitly introduced in by $T_1, \ldots, T_n$.
 
 $free(\forall T_1, \ldots, T_n.T) = free(T) - \{T_1, \ldots, T_n\}$.
 
 
 We say a type variable $\DOLLAR{}X$ is free in a scope $S$, if there exists an identifier $ID$ with type $T$ defined in $S$, and $\DOLLAR{}X$ is free in $T$. The free type variables of $S$ are the set of all type variables that are free in $S$.
 
\subsection{Function Types}
\label{functionTypes}

A {\em function type} describes the type of a function [\ref{functions}].

A function type consists of a domain and a range. A {\em domain} is a list of types, composed from the types of the formal parameters of a function, in the order they appear in the function declaration. A {\em range} is a result type of a function. 
We write a  function type as $T_1, \ldots, T_n \to T_r$, where $T_1, \ldots, T_n$ is the domain and $T_r$ is the range.

Function types are used internally in this specification, but have no direct syntactic representation.

{\em 
Naturally, as ShapeRank does not support user-defined higher order functions.

Function types  are derived from function signatures [\ref{functionSignatures}].
}



\section{Lexical Rules}
\label{lexicalRules}
\printlexitable

\section{Grammar}
\label{grammar}
\printgrammartable



\end{document}