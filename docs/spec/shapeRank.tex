\documentclass{article}
\usepackage{epsfig}
\usepackage{hyperref}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{textcomp}

\input{shapeRank.sty}
\begin{document}
\title{ShapeRank Language Specification\\
{\large Version 0.2}
}
\maketitle

\tableofcontents

\section{Introduction}

ShapeRank is a referentially transparent, decidable, rank-polymorphic statically shape-safe language. It is designed for data analysis, reactive programming and machine learning. 

All values in ShapeRank are hyperstreams [\ref{concepts}]. A {\em hyperstream} is either scalar [\ref{hyperstreams}] or a sequence [\ref{streams}] of hyperstreams. Hyperstreams may be of a pre-determined size, or they may be unbounded. 

ShapeRank does not support user-defined higher order functions. However, a number of useful higher-order functions are built into the language [\ref{higherOrderFunctions}]. User defined functions [\ref{functions}] may be used as arguments to these.

The language does not permit recursion and has no explicit looping constructs. These are not needed, since all iteration is implicit, dictated by the shape of the data. As a result, a program written in ShapeRank can never diverge or crash. 

ShapeRank has no constructs to create recursive data structures, and so any data a program creates is acyclic. Hence, reference counting is a sufficient strategy for fully automatic memory reclamation.



\subsection{Conventions}
\label{conventions}

In this specification, normative text appears in roman font. Defined concepts are given in {\em italic font}. Non-normative commentary is given in {\em italic font}.

{\em Commentary is useful for adding explanations, motivations, context etc.}

{\em 
The specification does not detail syntax errors. Syntactically erroneous situations are implicitly defined by the syntax productions herein.
}

Constructs that are syntactically valid but are illegal for other reasons result in compile-time errors. The circumstances leading to such compile-time errors are described on an individual basis in this specification.

{\em
Examples include expressions that do not have a valid type or references to undeclared or multiply declared entities.
}

\subsubsection{Presentation of Syntax}

Syntax productions are given in a form of EBNF. The name of a production is given in {\bf bold}.  All non-terminals are enclosed in angle brackets. The symbol $\rightarrow$ is used to separate a production's left and right sides. Alternatives are separated by the $|$ symbol. Parentheses are used for grouping. The postfix $*$ denotes zero or more repetitions, and postfix $+$ denotes one or more repetitions. Optional items are postfixed by $?$. 

{\em
Of course one should never confuse syntax with meta-syntax. In particular,we will call out one possible confusion due to the unusual use of \QUESTIONMARK{} in the Shape Rank syntax. The use of $?$ as a meta-syntactic symbol  is distinct from the use of \QUESTIONMARK{} in ShapeRank itself, where it denotes unknown shapes [\ref{functions}] and unbounded dimensions in type
signatures, and the unbounded dimension value [\ref{concepts}] in expressions.
}

To distinguish terminals from EBNF notation, terminals appear in {\color{blue} blue}.

{\em Examples:}
\begin{itemize}
\item \BuiltinType
\item  \HyperstreamLiteral
\end{itemize}


Lexical rules are similar, but the names of lexical productions are always given in uppercase, and the left and right hand sides are separated by ::=.

\subsection{Scopes}
\label{scopes}

A {\em scope} is a mapping from names to entities such as variables [\ref{letBindings}, \ref{whereExpressions}], and function declarations [\ref{functions}]. 
Declarations affect scopes by adding elements to them. 
Modules [\ref{modules}], ShapeRank functions and where expressions [\ref{whereExpressions}] introduce scopes. 

Let $s_1, s_2$ be scopes.  We write $s_1 \leftarrow s_2$, pronounced $s_1$ overridden by $s_2$, to denote the scope  which maps all names defined in $s_2$ to their values in $s_2$ and any other name to its mapping in $s_1$, if any. We write $\{id_1 \mapsto v_1, \ldots, id_n \mapsto v_n\}$ to denote a scope that defines $id_i$ and binds it to $v_i$,  $\{id_1 \mapsto v_1: T_1, \ldots, id_n \mapsto  v_n: T_n\}$ to denote a scope that defines $id_i$ and binds it to $v_i$ with type $T_i$, and $\{id_1 \rightsquigarrow  T_1, \ldots, id_n \rightsquigarrow T_n\}$ to denote a scope that associates $id_i$ with a type $T_i $ without regard to value, $i \in 1..n$.

Scopes may nest. Nested scopes override their immediately enclosing scope: if a scope $s_{inner}$ is nested in a scope $s_{outer}$, then the effective scope is $s_{outer} \leftarrow s_{inner}$, and so all elements of $s_{outer}$ are {\em available in} $s_{inner}$ unless an element with the same name is added to $s_{inner}$.
The scope of a function is always nested in the scope of its enclosing module. 

{\em
In short, we have lexical scoping.
}

The technical use of the term {\em scope} should not be confused with its informal use in phrases such as {\em beyond the scope of this specification.}



\section{Concepts}
\label{concepts}

\subsection{Streams}
\label{streams}

A {\em stream} is a sequence of {\em elements}.  A stream may be {\em bounded} or {\em unbounded}. The {\em length} of a stream $s$  is 
\begin{itemize}
\item A fixed integer {\em length}, determined when $s$ is created, if $s$ is bounded.
\item \QUESTIONMARK{}, if $s$ is unbounded.
\end{itemize}

At any point in time, an unbounded stream has some number $n \ge 0$ of {\em available elements}. The number of available elements of a stream increases monotonically over time. Every stream also has a {\em dynamic size}, distinct from its statically declared length. The dynamic size is the maximum number of available elements during program execution.

{\em One may think of the length of an unbounded stream as potentially infinite. In practice, no stream is infinite, as we do not anticipate ShapeRank programs surviving the death of the universe.
}

\subsection{Hyperstreams}
\label{hyperstreams}

A {\em hyperstream} consists of either a scalar or a stream [\ref{streams}], whose elements are hyperstreams, along with 
 its  {\em shape}. 

The most elementary hyperstreams are {\em scalar hyperstreams}. These include  booleans [\ref{bool}], numbers [\ref{number}], strings [\ref{string}] and  structs [\ref{structTypes}]. A scalar hyperstream consists of a single scalar value.  We will often refer to scalar hyperstreams simply as scalars.
%  functions are scalar hyperstreams too, but their  use is restricted.

A non-scalar hyperstream consists of a stream, $s$, of hyperstreams. All elements of $s$ must have a common type.
We refer to $s$ as the {\em primary axis} of the hyperstream.

The {\em axes} of a hyperstream, if any, are its primary axis, followed by the axes of its elements. 

The {\em shape} of a hyperstream $h$ is:
\begin{itemize}
\item  The empty sequence, $[]$, if  $h$ is a scalar. 
\item A vector whose first element is the length of the primary axis of $h$ and whose remainder is given by the shape of the elements of $h$. 
\end{itemize}

{\em The above implies all elements of $h$ have the same rank and common element type, and each of their dimensions is either the same or \QUESTIONMARK}.
 
The elements of the shape are know as  the {\em dimensions} of the hyperstream.
 The {\em rank} of a hyperstream is the length of its shape.

{\em
The rank  gives the number of axes in the hyperstream. The rank of a scalar hyperstream is therefore $0$.
}

Informally, the term dimension may be used to denote an axis or its length. We may also use the terms size and length interchangeably.


\subsection{Reactivity and Synchronicity}
\label{reactivityAndSynchronicity}

A program or function [\ref{functions}] is {\em reactive} if it may fire whenever the number of available elements [\ref{streams}] of any of its inputs increases. Otherwise it is {\em synchronous}.
% define fire, or replace with run or execute

\subsection{Access Control}
\label{accessControl}

A {\em declaration} is either a let binding [\ref{letBindings}] or a function [\ref{functions}]. Declarations are defined inside modules [\ref{modules}]. Declarations may optionally be declared as \PUBLIC{}, in which case they are part of the module produced by the enclosing module declaration and so can be accessed outside the module.


\section{Let Bindings}
\label{letBindings}

A {\em let binding} assigns a value to an identifier. 

\LetBinding{}

Let  $l \triangleq $ \LET{} $ID$ \BIND{} $e$

The {\em enclosing scope} of $l$ is the declaration scope [\ref{programsAndIO}] of the preceding declaration, or the initial declaration scope of the program if there is no preceding declaration.

Let $s$ be the enclosing scope, and let $T$ be the type of $e$ in $s$.
The type $T$ is associated with $ID$ in $s$.

It is a compile-time error if $e$ does not have a valid type in $s$.


\section{Functions}
\label{functions}

Functions may be defined by either:
\begin{itemize}
\item A ShapeRank function declaration [\ref{shapeRankFunctionDeclarations}].
\item An external function declaration [\ref{externalFunctionDeclarations}]. 
\end{itemize}

\subsection{ShapeRank Function Declarations}
\label{shapeRankFunctionDeclarations}

\FunctionDeclaration

A function declaration defines a transformation of one or more input streams into an output stream. A function declaration has a
{\em function signature} which specifies the name of the function, and the name and rank of each of its parameters.

If the keyword \SYNC precedes the keyword \FUNC, the function is synchronous [\ref{reactivityAndSynchronicity}], otherwise it is reactive.

\FunctionSignature{}

\ParameterList{}

\Parameter{}

\RankSigSuffix{}

\RankSig{}

A function signature has the form  $F\LPAREN{}p_1 R_1\COMMA{} \ldots\COMMA{} p_n R_n\RPAREN{}$ where $F$ is an identifier that specifies the name of the function, and $p_i  R_i,  i \in 1..n$ specify the function's parameters; each $p_i$ is an identifier that names the $i$th parameter, and the corresponding $R_i$ specifies the parameter's rank $r_i$.  

The specification $R_i$ of a parameter's rank has one of the following forms:
\begin{itemize}
\item A colon, followed by either of 
\begin{itemize}
\item One or more pairs of square brackets. The specified rank, $r_i$ is the number of such pairs.
\item \QUESTIONMARK{}.  The specified rank, $r_i$ is unknown.
\end{itemize}
\item An empty specification. The specified rank, $r_i$, is 0.
\end{itemize}

It is a compile-time error if $p_i = p_j, i \ne j$.

Let $f \triangleq$ \FUNC{} $F\LPAREN{}p_1 R_1\COMMA{} \ldots\COMMA{} p_n R_n\RPAREN{}$  \BIND{} $e$.

The {\em enclosing scope} of $f$ is the declaration scope [\ref{programsAndIO}] of the preceding declaration, or the initial declaration scope of the program if there is no preceding declaration.

Processing of $f$  has the following effect:

 Let $s_0$ be the enclosing scope of $f$. 
A new scope $s$ is created, and is known as the {\em immediate scope of} $f$. The scope $s_0 \leftarrow s$ is known as {\em the compile-time scope of $f$}.

{\em Thus, $s$ is nested in the enclosing scope.}

The variables $p_i$ are added to $s$, with ranks $r_i$, where $r_i$ is the rank specified by $R_i, i \in 1..n$.

It is a compile-time error if the enclosing scope of $f$ contains another declaration named $F$.

\subsection{External Function Declarations}
\label{externalFunctionDeclarations}

An {\em external function} is a function written in a programming language other than ShapeRank, that is used within a ShapeRank program [\ref{programsAndIO}].
An external function must, of necessity, be provided from outside the program. External functions are declared as parameters to the program.  A program parameter declares an external function if its declared type is an external function signature.  

\ExternalFunctionSignature{}
\ExternalFunctionParameterList
\ExternalFunctionParameter
\ExternalFunctionTypeSigSuffix
\TypeParameterList
\TypeParameter

An {\em external function signature} lists the names and types of each of the function's parameters in parentheses, followed by a colon followed by the function's return type, and defines a  function type [\ref{functionTypes}] whose domain is the cartesian product of the listed parameter types and whose range is the given return type.

{\em Each value parameter has a specification similar to that of a function parameter \ref{shapeRankFunctionDeclarations}. However, rather than specifying a rank for each parameter, a shape and base type are specified. The shape may be elided, in which case it is taken to be empty.
} 

If the function has type parameters, these are listed between parentheses prior to the value parameters.


\section{Built-in Functions}
\label{builtinFunctions}

This section describes those functions built-in to the ShapeRank language which cannot be implemented in ShapeRank itself. A ShapeRank implementation should provide additional functions via a standard prelude. The specification of such functions is beyond the scope of this document. 

{\em
Functions that are implemented as primitives but that can be implemented in
ShapeRank (e.g., contains()) are defined in the specification of the standard prelude. They can still be given a specification using ShapeRank code, augmented with prose
and/or signature information as necessary.
}

\subsection{Hyperstream Creation}
\label{streamCreation}

Because ShapeRank prohibits recursion, it is not possible to create unbounded hyperstreams from scratch. One must obtain an unbounded hyperstream from input or by calling a function.

{\em
If we include a primitive that produces an unbounded stream, for example a function {\em time()}, then additional
unbounded streams may be derived from it.
}

However, it is possible to define bounded hyperstreams.

{\em In other words, arrays.}

The function $makeTensor(dims: [], contents: [])$
will produce a hyperstream whose shape is given by a bounded hyperstream, $dims$ and whose contents are given by a hyperstream $contents$.

{\em
Should we call this makeStream()? Or just reshape()?
}

Specifically, we define

$makeTensor([d_1, \ldots, d_n], [c_1, \ldots, c_x]) = [e_1, \ldots e_{d_1}]$ where  
\newline 
$e_k  = makeTensor([d_2, \ldots, d_n], [c_{(k -1)\prod_{i=2}^{n} d_i}, \ldots, c_{k\prod_{i=2}^{n}d_i}])$

$makeTensor([d], [c_1, \ldots, c_{d_c}]) = [c_1, \ldots, c_d]$ if $d \le d_c$, and $[c_1, \ldots, c_{d_c}, c_1, \ldots, c_{d -d_c}]$ otherwise.

{\em 

In the common case where $d = d_c$ we have

$makeTensor([d], [c_1, \ldots, c_d]) = [c_1, \ldots, c_d]$

If $d < d_c$ we truncate {\em content} to length $d$.
If $d > d_c$, we wrap around, repeating elements of $contents$ as needed.
}

{\em In the APL programming language family, this is known as the ravel order.}

{\em
One might prefer that the situation where $d_1 \ne d_c$ be considered an error.  This is easily arranged by defining a wrapper function.
}

{\em
See section \ref{hyperstreamTypes} for the details of the type annotations used above.
}

\subsection{Indices}
\label{indices}

The $indices$ function returns an integer vector consisting of the indices of the first dimension of a hyperstream $s$. If $s$ is bounded, the result is $1 \RANGE{} length(s)$ [\ref{length}].  Otherwise, the result is a stream of integers in 1:1 correspondence with the elements of $s$, starting with 1, where each element is the natural number immediately succeeding its predecessor. The dynamic size [\ref{streams}] of $indices(s)$ is always equal to the dynamic size of $s$.

$indices(x: [])$

{\em
This allows us to compute things like the running average of a numeric stream $x$:

$\SYNC{}$  $\FUNC{}$ $avg(x:[]) = scan(+, 0, x)/scan(+, 0, indices(x))$
}

\subsection{Length}
\label{length}

The $length$ function returns the length [\ref{concepts}] of a hyperstream.

$length(s: \QUESTIONMARK{})$

If the hyperstream is unbounded, the value \QUESTIONMARK{} is returned.

\subsection{Rank}
\label{rank}

The $rank$ function returns the rank [\ref{concepts}] of a hyperstream.

$rank(s: \QUESTIONMARK{})$

\subsection{ShapeOf}
\label{shapeOf}

The $shapeOf$ function returns the shape [\ref{concepts}] of a hyperstream.

{\em 
It follows from the  definition of shape and length [\ref{length}] that
if any  dimension of the hyperstream is unbounded, the shape will contain the value \QUESTIONMARK{} at the corresponding  position.
}

$shapeOf(s: \QUESTIONMARK{})$

\subsection{Higher-Order Functions}
\label{higherOrderFunctions}

ShapeRank supports a number of higher-order functions. They treat their function-valued arguments as scalar streams [\ref{hyperstreams}]. 


\subsubsection{Fold}
\label{fold}


The $fold$ function takes a binary function $f$, an initial scalar value $acc$ and a bounded stream $x$ of rank $r \ge 1$ and length $d$. It then computes the rank-polymorphic call [\ref{calls}]
$f(f( \ldots f(acc, x_1), \ldots x_{d-1}), x_d)$, where $d$ is the dynamic size of $x$.

{\em It is worth emphasizing that the calls to f above are rank-polymorphic, and will therefore adapt to the dimensions of x. See the discussion of the signature of fold below.
}

{\em Note that fold only returns a result when $x$ is completed, which is why it is restricted to bounded streams.}

For documentation purposes, we use the signature notation used for external functions \ref{externalFunctionDeclarations}.

$fold(f: P$ $T \to{}Q$ $S \to{}P$ $T, acc: P$ $T, x:[d\BANG]::R::Q $ $S): R::P $ $T $

{\em
The signature above bears some explanation. The function $f$ expects its second argument to have shape $Q$, with rank: $rank(Q)$. The actual stream $x$ is not necessarily a stream of elements of shape $Q$ (such a stream would have rank $rank(Q) +1$); it may have rank $r \gt rank(Q) + 1$. We express this by defining the shape of $x$ to be $[d!]::R::Q$, which ensures that $r = 1 + rank(R) + rank(Q)$. Thus $R$ expresses an extra degree of 'padding'. The overall result shape is padded by $R$.

The dimension $d$ is suffixed by \BANG{}, indicating that we require a bounded dimension (see [\ref{hyperstreamTypeDescriptors}]). If $d$ were unbounded, $fold$ might diverge.

Note that the function $f$ does not require that both its parameters have the same element type; it requires the first parameter to agree with $f$s return type, since the result of $f$ is fed back  into $f$. The second parameter is taken from $x$, and so it has the same element type as $x$. 
}

\subsubsection{Inner Product}
\label{innerProduct}

The $innerProduct$ function takes binary functions $f$ and $g$ and hyperstreams $a$ and $b$, and calls [\ref{calls}] $reduce(f, g(s_a, s_b))$ [\ref{reduce}] for all slices $s_a$ along the last dimension of  $a$ and all slices  $s_b$ along the first dimension of $b$. The dynamic size  of $indices(s)$ is  always equal to the dynamic size of $s$.


{\em Define slices. Define reduce w/o explicit acc parameter.}

{\em Inner product can be seen as a generalization of matrix multiplication.  Given matrices $a: [m][n]$ and $b[n][p]$, their product is given by
 $innerProduct(a, b, *, +)$

}

$innerProduct(a: X:: [n]$ $T, b: [n]::Y$ $S,  f: R \to R \to Q, g: T \to S \to R): X::Y$ $Q$

\subsubsection{OuterProduct}
\label{outerProduct}

The $outerProduct$ function calls [\ref{calls}] a binary function $f$ on all applicable pairs of elements of two arguments $a$ and $b$ and aggregates the results.

{\em
The outerProduct function is similar to the concept of outer product in mathematics, but there are important differences. It explicitly abstracts over the 'product' operator, $f$, which need not be a mathematical product in any sense. And of course, it applies to hyperstreams rather than tensors.
}

$outerProduct(f: S_1 $ $T_1 \to{} S_2 $ $T_2 \to{} S_3 $ $T_3, a: [d_1]::S_4::S_1 $ $T_1, b: [d_2]::S_5::S_2 $ $T_2): [d_1]::S_4::[d_2]::S_5::S_3 $ $T_3$

{\em
The signature includes 'padding' much like that of fold above. Here, either the elements of $a$ or of $b$, or both, may have ranks that are strictly greater than what is required by $f$.
Hence, each has its own distinct padding shape ($S_4$ and $S_5$ respectively).
}


\subsubsection{Reduce}
\label{reduce}

The $reduce$ function takes a binary function $f$, an initial scalar value $acc$ and a bounded stream $x$ of rank $r \ge 1$. It then computes
$f(f( \ldots f(acc, x_1), \ldots x_{d-1}), x_d)$, where $d$ is the dynamic size of $x$.

$reduce(f: S $ $T \to{} S $ $T \to{} S $ $T, acc: S $ $T, x:[d\BANG]::R::S $ $T): R::S $ $T$

{\em
Reduce works just like fold, except that we insist that both of the arguments to $f$ must have the same type. This allows us to compute the
value in logarithmic time.

The name reduce is motivated by the fact that it reduces the rank of its input $x$ by 1. The reduce function is a basic building block of functional programming, but was introduced by APL many years before functional programming was invented.
}

\subsubsection{Scan}
\label{scan}

The $scan$ function operates like $fold$, except that it produces all of its interim results, in order, on its output stream. 

{\em 
Therefore, scan, unlike fold, is suitable for application to unbounded hyperstreams. Since scan is inherently sequential, there is no justification for a separate version analogous to reduce.
}

$scan(f: P $ $T \to{} Q $ $T \to{} P $ $T, acc: P $ $T, x:[]::R::Q $ $T):[d]::R::Q $ $T$

\section{Modularity}
\label{modularity}


{\em
Unimplemented and subject to change.
}


\subsection{Modules}
\label{modules}

A {\em module} is a record whose fields are ShapeRank declarations. A module is produced by invoking a module declaration [\ref{moduleDeclarations}].
Each field of a module is referred to as a {\em module member}.

\subsubsection{Module Member Access}
\label{moduleMemberAccess}

A public [\ref{accessControl}] member  $f$ of module $m$ may be accessed via a {\em qualified identifier} of the form $m \DOUBLECOLON{} f$.




\subsection{Module Declarations}
\label{moduleDeclarations}

A {\em module declaration} is a mathematical function between modules [\ref{modules}].  A module declaration has a name, a list of parameters and a body which is a series of function declarations or let bindings.  The parameters  of the module declaration are in scope within its body.

\subsubsection{Module Declaration Invocation}
\label{moduleDeclarationInvocation}

A module declaration may be invoked to produce a module. Syntactically, a {\em module invocation} has the form of a function call [\ref{calls}], except that all its arguments must denote modules.
A module invocation $m(a_1, \ldots, a_n)$ denotes a record whose fields are the public declarations of $m$.

{\em firm up. Substitution of arguments, key vs. value, define public access ...}

\section{Programs and I/O}
\label{programsAndIO}

A {\em program} consists of an optional  program signature, followed by an optional  series of declarations, and an expression.

\Program{}

A {\em program signature} specifies the name of the program as whole. In addition it specifies the program's parameters, if any.  These include {\em value parameters} and {\em type parameters}. 

\ProgramSignature{}

\ProgramParameterList{}

\ProgramParameter{}

\TypeSigSuffix{}

{\em What about type parameters? We don't yet allow them to be specified explicitly. Yet we do for external functions. TBD }

The program's value parameters are all listed between parentheses.  Each value parameter has a specification consisting of its name, followed by a colon followed by either a type expression [\ref{typeExpressions}] or an external function signature [\ref{externalFunctionDeclarations}].

{\em This is similar to the specification of external function parameters. However, unlike external function parameters, program parameters may be given a function type [\ref{functionTypes}].
} 


{\em
We require type signatures for program parameters because program arguments (unlike function arguments) are unavailable at compile time and so we cannot
infer the types of the parameters.
}

Unlike a function, a program is not invoked by a function call [\ref{calls}]. Instead, it is invoked from the surrounding computing environment in an implementation specific manner.  The invocation binds the type parameters \ref{typeVariables} and value parameters of the program. 

{\em
How an implementation supplies type parameters is beyond the scope of this specification. Typically it will require them to be given explicitly by the user.
It may be possible, in some environments, to infer some or all of the type variables.
}

The value parameters declared in the program signature are bound to external data sources. These sources are the program's sole source of input. The program's result is the value of its expression, and this is its sole external output. 

{\em 
Thus, ShapeRank has no constructs for I/O in the traditional sense.
}

If the keyword \SYNC precedes the keyword \PROGRAM, the program is synchronous [\ref{reactivityAndSynchronicity}], otherwise it is reactive.

Let $p$ be a program with declarations $decl_1, \ldots, decl_n$ and expression $e_p$. Each declaration, $decl_k, k \in 1..n$, is either a function $v_k$ named $id_k$, or a let binding that binds identifier $id_k$ to a value $v_k$.
Let $preludeScope$ be a scope that binds the name of every built-in function [\ref{builtinFunctions}] $f$'s  to $f$, and let $s_{args}$ be the scope $[p_i = a_i]$  where $p_i$ are the parameters of program $p$, and $a_i$ the corresponding arguments. The {\em initial declaration scope} of $p$ is $s_0 = preludeScope \leftarrow s_{args}$.
The declaration scope, $s_k$ of declaration $decl_k$ is defined to be $s_{k-1}  \leftarrow [id_k = v_k],  k \in 1..n$.

The {\em program scope} is $s_n$.  
We say $p$ is well typed iff $e_p$ has valid type in the program scope.

{\em
The scope rules preclude recursion, since a function can only invoke functions defined earlier in the program, or in the standard prelude.
}

{\em 

The above implies a program is typechecked once for every set of  arguments, but this is not true.  A program needs to be checked once for every type of its arguments. 

We need to flesh out these details, both for regular args and external functions.

}

\section{Expressions}
\label{expressions}

Expressions evaluate to values. Values are computed relative to a runtime scope. When we say that $e$ evaluates to $v$, we mean it evaluates to $v$ in the current runtime scope.

\Expression{} 

Every expression in a ShapeRank program is typechecked at compile-time. If no type [\ref{types}] can be determined for an expression, the expression and its enclosing program are illegal and a compile-time error must result. The process of determining the type of an expression is known as type inference [\ref{typeInference}]. 

 When we say that an expression $e$ has type $T$, we mean that $e$ has type $T$ in the current compile-time scope.

{\em We now typecheck against actual arguments so it isn't really compile-time scope.}

\subsection{Identifier Expressions}
\label{identifierExpressions}

An {\em identifier expression} consists of a single identifier.

\IdentifierExpression{}

Let $i \triangleq ID$.
Evaluation of $i$ proceeds as follows:


Let $s$ be the the current runtime scope. Then $ID$ is looked up in $s$. $ID$ must be either a variable or a function.
\begin{itemize}
\item If $ID$ is bound to a variable $b$, then if no value is associated with $b$ then the definition of $b$ is executed. The value $v$ of $ID$ is then looked up in $s$. The value of $i$ is $v$.

{\em In the case where no value is associated with the variable, it is necessarily defined via  a \LET{} binding. The above reflects the lazy evaluation of \LET{}.}

\item If $ID$ is bound to a function $f$, then value of $i$ is $f$. 
\end{itemize}

The type of $i$ is the type associated with $ID$ in the enclosing compile-time scope. {\em fix}.

It is a compile-time error if $ID$ is bound to a type. 


\subsection{Parenthesized Expressions}
\label{parenthesizedExpressions}

\ParenthesizedExpression{}

Let $p \triangleq \LPAREN{}e \RPAREN{}$.

Evaluation of $p$ proceeds as follows:

The expression $e$ is evaluated to $v$. The value of $p$ is $v$.

The type of $p$ in scope $S$ is the type of $e$ in scope $S$.

\subsection{Calls}
\label{calls}

A {\em call} invokes a function [\ref{functions}]. To understand the semantics of calls, we need the auxiliary concepts of frames, cells and replication.


\subsubsection{Frames and Cells}
\label{framesAndCells}

Hyperstreams can be divided into frames and cells. A {\em frame} is a hyperstream whose elements are also hyperstreams, called {\em cells}.

{\em As an example, the matrix 

2 3 4

5 6 7

 can be viewed as a pair of two 3-vectors:
[[2 3 4] [5 6 7]]

In that case, the frame is a 2-vector and the cells are 3-vectors.  Alternately, we can view it as a matrix, in which case the frame is the entire hyperstream, and the cells are scalars. A third way is to view the hyperstream as a frame of rank 0, which consists of a single cell of rank 2. In general, a hyperstream of rank $n$ can be decomposed into frames and cells in $n+1$ ways: a rank $n$ hyperstream with rank 0 elements, a rank $n-1$ hyperstream with vector elements, …, a rank 1 vector with rank $n-1$ cells, or a rank 0 frame with a single rank $n$ cell.
}

A hyperstream $h$, of shape $[d_1, \ldots, d_n]$ may be divided into a frame, $f_h$ of shape $[d_1, \ldots, d_k]$ and cells of shape $[d_{k+1}, , \ldots, d_n]$, for any $0 \le k \le n$.
The elements of the $h[1] \ldots [k]$ are known as the cells of of $f_h$.

A function $g(a_1, \ldots, a_k)$ may be {\em mapped} on to a frame $f_h$, written $map(g, f_h)$, producing a new frame, $f_m$ of the same shape as $f_h$ such that for each cell $c_h$ of $f_h$, $f_m$ has a corresponding cell $c_m = g(c_{h_1}, \ldots, c_{h_k})$.

\subsubsection{Zipping}
\label{zipping}

Given hyperstreams $h_i$, each with dynamic size $s_i$ and $n_i^t$  available elements at an arbitrary time $t$, $ i \in 1..k, k > 0$, the function $zip_{sync_k}$ produces a hyperstream 
 \newline
 $h_{sync} \triangleq (h_{1_1}, \ldots, h_{k_1}), \ldots, (h_{1_n}, \ldots, h_{k_n})$ 
 \newline
 where $n = min(s_i), i \in 1..k$.
 The number of available elements of $h_{sync}$ at any time $t$ is no more than $min(n_i^t), i \in 1..k$

{\em
Note that the $h_i$ may include both bounded and unbounded streams. If any of the $h_i$ are bounded, then the result of $zip_{sync_k}$ is bounded, and it's length is that of the shortest of the $h_i$. If all  the $h_i$ are unbounded, then $zip_{sync_k}$ is unbounded, with a dynamic size that is the smallest of the dynamic sizes of the $h_i$.

Of necessity, the number of available elements of $h_{sync}$ at any time $t$ is no more than the minimum among the $n_i^t$.

An important property of $zip_{sync_k}$ is that it synchronizes its inputs.
}

The function $zip_{react_k}$  produces a hyperstream $h_{react}$, whose first element is $(h_{1_1}, \ldots, h_{k_1})$. When the number of available elements of any of $h_i$ increases, an element $(h_{1_{n_1}}, \ldots, h_{k_{n_k}})$ may be appended to $h_{react}$. The precise decision of when to add new elements to $h_{react}$ is up to the
implementation, which should make a best-effort to add elements promptly.

{\em
The value of $h_{react}$ is non-deterministic. The first value is produced when all of the $h_i$ have an available value, just as with $h_{sync}$. From that point on, however,
new values may be added whenever any one of the $h_i$ has a new available value. No guarantees are made as to whether such a value will be added and when. It is quite possible that some of the $h_i$ will have a new available value, while others do not. In such cases, for any $h_i$ that doesn't have a new value,  the last available value is reused.
It is also possible that multiple new values may have become available on any or all of the $h_i$, in which case some values will be skipped.

The implementation of $zip_{react_k}$ is a best-effort, subject to complex engineering trade-offs, much like garbage-collection.

In an extreme case, $zip_{react_k}$ might produce a single value, but this would be an unacceptably poor implementation. Alternatively, $zip_{react_k}$ could behave just like 
$zip_{sync_k}$, and this too would be unacceptable.
}

\subsubsection{Replication}
\label{replication}

A frame $f_0$ of shape $[d_1, \ldots, d_k]$ may be replicated into a larger frame, $f_r$ of shape $[d_1, \ldots, d_n]$ for any $n$ where $n \ge k$. 




\subsubsection{Call Evaluation}
\label{callEvaluation}

Let $c_e \triangleq F[t_1, \ldots, t_m]\LPAREN{}a_1\COMMA{} \ldots\COMMA{} a_k\RPAREN$. Evaluation of $c_e$ proceeds as follows. 

The value of $c_e$ is the value of $F\LPAREN{}a_1\COMMA{} \ldots\COMMA{} a_k\RPAREN$.

It is a compile-time error if $F$ is not an external function [\ref{externalFunctionDeclarations}].
It is a compile-time error if $F$ does not declare $m$ type parameters. 
It is a compile-time error if the $i$th type parameter of $F$ is a shape variable, and $t_i$ is not a shape.
It is a compile-time error if the $i$th type parameter of $F$ is a dimensions variable, and $t_i$ is not a dimension.
It is a compile-time error if the $i$th type parameter of $F$ is a scalar type variable, and $t_i$ is not a scalar type.


Let $c \triangleq F\LPAREN{}a_1\COMMA{} \ldots\COMMA{} a_k\RPAREN$. Evaluation of $c$ proceeds as follows. 

Let $ar_i$ be the rank of $a_i$ and let $pr_i$ be the rank of $p_i, i \in 1.. k$. Then  $a_i$ is divided into a frame $f_i$, of rank $ar_i - pr_i$ with cells of rank $pr_i$. 

{\em
Every formal parameter has an expected rank. However, arguments may be of higher rank. An argument of rank $n$ may be passed where a parameter of rank $k$ is expected, provided $n \ge k$. The argument is viewed as a frame of rank $n-k$ with cells of rank $k$. 

The cells of an argument's frame are of the rank expected by the corresponding formal. If the argument is of higher rank than expected, framing breaks into cells that are suitable 
arguments.

The callee, $F$, will be invoked with arguments of the rank it expects; however, if any of its arguments are of higher rank than expected, it will be invoked multiple times.
The results of these invocations will be assembled into a result stream. 

It is easiest to understand the process by considering a function of one argument, such as the logical negation function, $not()$. Given a call such as

$not([true, false])$

we see that the rank of the argument is 1, but the function expects a scalar argument, i.e, an argument of rank 0. We therefore produce a frame of rank $1 - 0 = 1$, with two cells of rank $0$.  We can now invoke $not()$ on each of the two cells, and produce a result by assembling the scalar results into a result vector, $[false, true]$.

If all functions were unary, the argument framing rules given so far would suffice. However, the situation is more complex given multiple arguments.
To deal with these, we need the notion of {\em common frame} for all the arguments as described below.
}

Let $common\_frame$ be a frame such that:
\begin{itemize}
\item  $rank(common\_frame) = max(rank(f_i)), i \in 1 ..k$. 
\item  If $shape(f_i)_j = \QUESTIONMARK{}$ then $shape(common\_frame)_j = \QUESTIONMARK{}$ otherwise $shape(common\_frame)_j =  shape(f_i)_j,i \in 1 ..k, j \in 1..rank(f_i)$.
\end{itemize}

{\em
As noted above, framing arguments allows us to apply functions to arguments whose rank is higher than expected by the function. In the presence of multiple arguments,
we may find that each argument may be framed differently. To make the call, we must determine a common frame for all the arguments. The function $F$ will be 
invoked once per cell of the common frame.  

To understand the definition above, let us first consider bounded hyperstreams - those whose dimensions are known (aka, arrays).
In that case, no dimension is equal to \QUESTIONMARK{}. Rather, the $i$th dimension of the common frame is the same as that of the $i$th dimension of any of the argument frames (if they have such a dimension).  This implies that all the argument frames must agree on their $i$th dimension (if they do not, we have an error as specified below).
In other words, the shape of each argument frame is a prefix of the shape of the common frame. This is known as the prefix rule in array programming languages such as J,  where it was introduced as a clean generalization of the original rules of APL.

We adjust this rule to account for the generalization from arrays to streams, 
stating that, if any of the arguments frames has \QUESTIONMARK{} as its $i$th dimension, we use \QUESTIONMARK{} as the $i$th dimension of the common frame.
}

Next, $f_i$ is replicated [\ref{replication}] into a frame $af_i$, of shape $shape(common\_frame), i \in 1..k$. 

{\em
Since we invoke $F$ once per cell of the common frame, we have to replicate cells of frames that have less cells.
As a simple example, consider

$[1, 2, 3] + 2$

We expect to call $+$ once for each element of $[1, 2, 3]$, i.e., $1+2$, $2+2$, $3+2$. In other words, the argument $2$ is {\em replicated} to match the shape of the first argument, as if we wrote $[1, 2, 3] + [2, 2, 2]$.

A lower level, more mechanistic  description is this:

The two arguments of $+$ are framed differently. The first is a 3-vector (rank 1) and its frame is also of rank 1 with the same shape, $[3]$, and cells $1, 2$ and $3$.
The second argument is  scalar,  and its frame has rank 0 and shape $[]$, and a single cell containing $2$. The common frame is of rank 1, of shape $[3]$. The first argument frame is already of the requisite shape. The second frame however is not, and so it is replicated into a frame of shape $[3]$, with three cells: $2, 2$ and $2$.

At this point, all argument frames have the same shape, and therefore the same number of cells (modulo streaming) as the common frame. We can therefore invoke $F$ once per cell of the common frame;  for each call, we need to select corresponding cells from each argument frame. The precise mechanism we use to do that is given below. 
}

If $F$ is reactive[\ref{reactivityAndSynchronicity}], let $zip = zip_{react_k}$, otherwise let $zip = zip_{sync_k}$.

{\em
The use of zip serves to combine multiple arguments into one.  
Each cell of the zipped frame consists of an argument vector, whose elements are arguments of the rank expected by $F$.
We will then invoke $F$ on each cell of the zipped frame.

An alternative formulation might use a $map_k$ function instead.
However, using zip gives us a convenient place to manage reactivity.
It is the use of the different zip functions that determine when a reactive function will fire. 
}

Let $r$ be the value of $map(F, zip(af_1, \ldots, af_k))$. $c$ evaluates to $r$.

It is a compile-time error if $ar_i < pr_i, i \in 1..k$. It is a compile-time error if the $i$th dimension of  $common\_frame$ is not required to be  \QUESTIONMARK{}, and the $i$th dimensions of two argument frames differ. 

{\em In such a situation, the specification of $common\_frame$ would be ambiguous. Consequently, no consistent replication of the arguments is possible.}

If $F$ is a ShapeRank function declaration [\ref{shapeRankFunctionDeclarations}] then
let $S$ be a scope, let $R$ be the type of the body of $F$ in scope $S <- [p_i = a_i], i = 1..k$. The the type of $c$ in scope $S$ is
$shape(common\_frame), shape(R) baseType(R)$.

% define baseType, scope override etc. Is shape(max_frame well defined now?

If $F$ is an external function declaration then let let $R_e$ be the return type declared in the signature of $F$,  let $V_i$ be the type variables declared in the signature of $F$, let 
$T_e = [t_i/V_i]R_e, 1 \le i \le k$, let $s_e$ be the shape of $T_e$, and let $t_e$ be the base type of $T_e$.
The type of $c$ is
$shape(common\_frame), s_e t_e)$.

{\em 

Still missing checking of incoming parameter types.

Only an external function may have type parameters, and these must be passed to it explicitly. They are then substituted [\ref{typeSubstitution}] into the function's declared return type.

The motivation for these rules is as follows:

Calls to ShapeRank functions have their type inferred based on their bodies and their actual parameters. The types of external function calls  cannot be inferred in this way,
since the ShapeRank implementation has no access to, or understanding of, the internals of an external function. Instead, the type of the call is based on the function signature. 
If the signature involves type variables, their bindings must be known.  To avoid the difficulties of type inference, we require that any type variables be passed explicitly.

External functions are relatively few, and infrequently polymorphic; hence the burden of passing type arguments is not too onerous. Future versions of ShapeRank may 
further ameliorate this burden, since  in most cases, inference is tractable.
}


\subsection{Boolean Literals}
\label{booleanLiterals}

The identifiers \TRUE{} and \FALSE{} are predefined,  denoting the boolean scalars true and false respectively, and have type $[]\BOOL{}$ in any scope $S$. [\ref{bool}].

{\bf BoolLiteral} $\rightarrow$ \TRUE{} $|$ \FALSE{}

\subsection{Number Literals}
\label{numberLiterals}

Number literals are either integers literals or floating-point literals.

\NumberLiteral{}

\subsubsection{Integer Literals}
\label{integerLiterals}

An {\em integer literal} represents an integer scalar.  An integer literal with value $n$ has type $[]n{}$ in any scope $S$.

Integer literals can be expressed in decimal and hexadecimal systems. The prefix `0x` or `0X` indicates a hexadecimal number literal. 

\subsubsection{Floating Point Literals}
\label{floatingPointLiterals}

A {\em floating-point literal} represents a floating point number scalar conforming to the IEEE floating point standard. Floating-point literals have type $[]\FLOAT{}$ in any scope $S$.

Floating-point decimals may also be expressed in scientific notation using `E` or `e`.

The predefined identifier {\tt system::nan}  denotes an IEEE floating point NaN value and has type $[]\FLOAT{}$ in any scope $S$. 
[\ref{number}].
The predefined identifier {\tt system::infinity} denotes IEEE floating point positive infinity and has type $[]\FLOAT{}$ in any scope $S$.

{\em
ShapeRank does not distinguish among NaN values.
}


\subsection{String Literals}
\label{stringLiterals}

A {\em string literal} denotes a string valued scalar, and can be written in one of the following forms:

\StringLiteral{}

\begin{itemize}
\item
Single-line string literals are enclosed in double quotes (\textsf{"}), for example \textsf{"}A single line string\textsf{"}. A backslash ($\backslash$) character is used for conventional character escaping.
\item Multi-line string literals are enclosed in triple double quotes.  {\em No escapes may be used.}
\item Verbatim string literals are enclosed in back-ticks (`). Only back-tick characters must be escaped using another back-tick character.
\end{itemize}

A string literal has type $[]\STRING$ in any scope $S$.

\subsection{Hyperstream Literals}
\label{hyperstreamLiterals}

\HyperstreamLiteral

Hyperstream literals denote hyperstreams [\ref{concepts}] of fixed length. 

{\em Note that one cannot specify an empty hyperstream literal. An empty hyperstream may be created as a result of some computation. However, we may change the rules
to allow empty hyperstream literals.}

Let $hs = [e_1, \ldots, e_n]$  be a hyperstream literal. 

The type of $hs$ in scope $S$  is $[n] shape(t_1)gcs(t_i)$ where $t_i$ is the type of $e_i$ in $S, i = 1..n$.

It is a compile time error if $shape(t_i) \ne shape(t_j)$ for any $i, j \in 1..n$.

{\em Define gcs. Also, $shape(t_1)$ is probably wrong, as dimensions may merge into \QUESTIONMARK. Decide on consistent notation for shape concatenation.}


\subsection{Struct Literals}
\label{structLiterals}

A {\em struct literal} defines a record scalar with named fields.

\StructLiteral{}
\Property{}

Let $s \triangleq \LCURLY{}p_1\COLON{} e_1\COMMA{} \ldots \COMMA{} p_n\COLON{} e_n\RCURLY$.

The type of $s$ in scope $S$ is $[]\LCURLY{}p_1\COLON{} t_1\COMMA{} \ldots \COMMA{} p_n\COLON{} t_n\RCURLY$, where $t_i$ is the type of $e_i$ in scope $S, i = 1..n$.


\subsection{Dot Expressions}
\label{dotExpressions}

A {\em dot expression} provides a way to access a member of a struct [\ref{structTypes}] or builtin type.

\DotExpression{}

Let $m \triangleq e\DOT{}p$.

Evaluation of $m$ proceeds as follows:

The value of $m$ is $v$ if the value of $e$ is a record scalar with a field $p$ with value $v$; otherwise it is the value of the call expression [\ref{calls}] $dot_T(e)$, where $dot_T$ is defined as if by the function declaration  [\ref{functions}] $\FUNC{}$ $dot_T(x) = x.p$.


The type of $m$ in scope $S$
 is $T$ if the type of $e$ in $S$ is a scalar struct type [\ref{structTypes}] with a field $p$ with type $T$; otherwise it is the type of the call expression [\ref{calls}] $dot_T(e)$ in $S$, where $dot_T$ is defined as above.

Let $T_e$ be the type of $e$ in scope $S$.  It is a compile-time error if the base type of $T_e$ is not a struct type with a member named $p$. 

\subsection{Member Expressions}
\label{memberExpression}

A {\em member expression} is either an identifier expression [\ref{identifierExpressions}], a parenthesized expression [\ref{parenthesizedExpressions}], a function call [\ref{calls}], a literal ([\ref{booleanLiterals}, \ref{numberLiterals}, \ref{stringLiterals}, \ref{structLiterals}], \ref{hyperstreamLiterals}), or a dot expression [\ref{dotExpressions}]]. It serves exclusively as a syntactic grouping.


\subsection{Unary Expressions}
\label{unaryExpressions}

A {\em unary expression} is either a member expression [\ref{memberExpression}] or the application of a unary operator to two unary expressions.
A {\em unary operator} is one of the operators \MINUS{} or  \NOT{}. 

The \MINUS{} operator implements IEEE floating point negation. Its result type is the type of its argument. It is a compile-time error if the argument to \MINUS{} is not of numeric type. 

The \NOT{} operator implements boolean negation It maps boolean arguments to boolean results. It is a compile-time error if the argument to \NOT{} is not of type \BOOL.

\UnaryExpression{}

Let $u \triangleq \theta{} e$.

The expression $\theta e$ where $\theta$ is a unary operator, is equivalent to $\theta\LPAREN{}e\RPAREN{}$.

\subsection{Multiplicative Expressions}
\label{multiplicativeExpressions}

A {\em multiplicative expression} is is either a unary expression or the application of a multiplicative operator to two multiplicative expressions.
A {\em multiplicative operator} is one of the operators \TIMES{}, \DIV{}, \MOD{}. The \TIMES{}, \DIV{}, and \MOD{ operators implement IEEE double multiplication, division and remainder, respectively. 

\MultiplicativeExpression{}
\MultiplicativeOp{}

The expression $e_1 \theta e_2$ where $\theta\LPAREN{}p_1\COLON{} T \LT: \NUM\COMMA{} p_2\COLON{} T\RPAREN\COLON{}T$ is a multiplicative operator, is equivalent to $\theta\LPAREN{}e_1\COMMA{} e_2\RPAREN$.

\subsection{Additive Expressions}
\label{additiveExpressions}

An {\em additive expression} is either a multiplicative expression [\ref{multiplicativeExpressions}] or the application of an additive operator to two additive expressions.
An {\em additive operator} is one of the operators \RANGE{}, \PLUS{}  and \MINUS{}.  The \RANGE{} operator produces a bounded stream, $s$, of length $stop - start + 1$, where $start$ is the  first argument to \RANGE{} and  $stop$ is its second argument. The  first  element of $s$ is $start$ and each succeeding element is the natural number succeeding its predecessor. The \PLUS{} and \MINUS{} operators implement IEEE double addition and subtraction, respectively.

\AdditiveExpression{}
\AdditiveOp{}


The expression $e_1 \theta e_2$ where $\theta$ is an additive operator, is equivalent to $\theta\LPAREN{}e_1\COMMA{} e_2\RPAREN$. Its result type is the least common supertype of $e_1$ and $e_2$. It is a compile-time error if either $e_1$ or $e_2$ is not of numeric type.

\subsection{Relational Expressions}
\label{relationalExpressions}

A {\em relational expression} is either an additive expression [\ref{additiveExpressions}] or the application of a relational operator to two relational expressions.
A {\em relational operator} is one of the operators \EQ{}, \NEQ{}, \LT{}, \GT{}, \LTE{}, \GTE{}.

The operators \EQ{}, \NEQ{}, \LT{}, \GT{}, \LTE{}, \GTE{} implement the equal, not equal,  less than, greater than,  less than or equal, greater or equal operators respectively. The \EQ{} and \LT{} operators are defined by equality and the linear orderings among values of types as given in sections \ref{bool}, \ref{number}, \ref{structTypes}.

Let $v_1 \ne {\tt system::nan}, v_2 \ne {\tt system::nan}$ be scalar values. 

$v_1 \NEQ{} v2$ iff it is not the case that $v_1 = v_2$.

$v_1 \LT{} v_2$ iff $v_1 < v_2$.

$v_1 \LTE{} v_2$ iff either $v_1 = v_2$ or $v_1 < v_2$.

$v_1 \GT{} v_2$ iff $v_1 > v_2$.

$v_1 \GTE{} v_2$ iff either $v_1 = v_2$ or $v_1 > v_2$.

In any other case (i.e, if one or both of $v_1, v2$ are {\tt system::nan}) then all the relational operators return false, per the rules of IEEE floating point.

\RelExpression{}
\RelOp{}

The expression $e_1 \theta e_2$ where $\theta$ is a relational operator, is equivalent to $\theta\LPAREN{}e_1\COMMA{} e_2\RPAREN$. The type of a relational expression is  \BOOL{} in any scope $S$.


\subsection{Logical And}
\label{logicalAnd}

A {\em logical and expression} is either a relational expression [\ref{relationalExpressions}] or the application of the logical and operator, \AND{}, to two logical and expressions.

\AndExpression{}

The expression $e_1$ \AND{} $e_2$ is equivalent to the conditional expression [\ref{conditional}] 

\IF{} $e_1$ \THEN{} $e_2$ \ELSE{} \FALSE{}.

{\em While the semantic equivalence must be respected, it is advisable to provide specialized error messages when the types of $e_1$ and $e_2$ disagree,  as the expectation here is that $e_2$ is of type \BOOL{}, rather than that \FALSE{} is not of the same type as $e_2$.
}

{\em
Note that logical and is not commutative.
}

\subsection{Logical Or}
\label{logicalOr}

A {\em logical or expression} is either a logical and expression [\ref{logicalAnd}] or the application of the logical or operator, \AND{}, to two logical or expressions.

\OrExpression{}

The expression $e_1$ \OR{} $e_2$ is equivalent to the conditional expression [\ref{conditional}] 

\IF{} $e_1$ \THEN{} \TRUE{} \ELSE{} $e_2$.

{\em
Note that logical or is not commutative.
}


\subsection{Conditional}
\label{conditional}

A {\em conditional expression} allows for control flow based on the evaluation of a predicate.

\ConditionalExpression{}

Let $c \triangleq $ \IF{} $b$ \THEN{} $t$ \ELSE{} $e$.

Evaluation of $c$ proceeds as follows:

The expression $b$ is evaluated. 
If $b$ evaluates to \TRUE{}, $t$ is evaluated to a value $v_t$. The value of $c$ is $v_t$. Otherwise, $e$ is evaluated to a value $v_e$. The value of $c$ is $v_e$.

Let $B$ be the type of $b$ in scope $S$, let $T$ is the type of $t$ in scope $S$, let $E$ be the type of $e$ in scope $S$, and let $C$ be the least common supertype of $T$ and $E$. The type of $c$  in scope $S$ is $C$. 

It is a compile-time error if $B$ is not a subtype of \BOOL{}. It is a compile-time error if $T$ is not a subtype of $E$ or vice versa. 

\subsection{Reranking}
\label{reranking}

A {\em rerank expression} takes an existing function and produces a new one, whose parameters differ in rank but is otherwise the same.

{\em
Rerank is not a proper declaration, because it does not introduce a name. 
}

\RerankExpression

Let $r \triangleq  \RERANK{}$ $f$  $\TO{}$ $r_1, \ldots, r_n$.

where $f$ is a function with signature $f(p_1 R_1, \ldots, p_n R_n)$. Then

Then $r$ evaluates to a function with body $f(a_1, \ldots, a_n)$ and signature 
$x(a_1: []_1\ldots []_{r_1}), \ldots, a_n: []_1\ldots []_{r_n})$, where $x$ is name unique in the program.

It is a compile-time error if a rerank expression is used anywhere except the following:
\begin{itemize}
\item As the target of a call.
\item  As an argument to a higher-order function, where the base type of the corresponding parameter is a function.
\item As the value of a let binding, or 
\item Immediately following the keyword \RERANK{} in another rerank expression. 
\end{itemize}

\subsection{Casts}
\label{casts}

A {\em shape cast expression} can be used to dynamically test whether the shape of an expression matches a specified shape.

\ShapeCastExpression

Let $sc \triangleq \SHAPECAST{}$ $e$ $\TO{}$ $s$.
Let $s_e T_e$ be the type of $e$ in scope $S$, and let $v$ be the value of $e$.
Then, if the shape of $v$ is compatible with $s$, the value of $sc$ is $v$, otherwise a runtime error occurs. The type of $sc$ in scope $S$ is $s T_e$. 

It is a compile-time error if the $s_e$ is not compatible $s$.

Two shapes $s_1 = [d_{11} \ldots d_{1r}], s_1 = [d_{21} \ldots d_{2r}]$ of the same rank $r$ are {\em compatible} if either $d_{1i} = d_{2i}$, or $d_{1i} = \QUESTIONMARK{}$ or  $d_{2i} = \QUESTIONMARK{}, i \in 1..r$

\subsection{Where Expressions}
\label{whereExpressions}

A {\em where expression} allows an identifier to be bound in the context of a larger expression. A where expression is either a logical or expression \ref{logicalOr}, or a where expression followed by the keyword \WHERE{} , followed by a variable binding. A variable binding is identifier followed by an equal sign followed by an expression.

\WhereBindingExpression{}

\VALIDENT{}


Let $we \triangleq e_1$ \WHERE{} $id = e_2$.

Let $s$ be the current scope, and $v_2$ be the value of $e_2$. The value of $we$ is the value of $e_1$ in the scope $s \leftarrow [id = v_2]$.

Let $T$ be the type of $e_2$ ins scope $S$. The type of $we$ in scope $S$ is the type of $e_1$ in the scope $S \leftarrow [id = T]$.


\section{Types}
\label{types}

ShapeRank's type system guarantees that a ShapeRank program will not cause a type error (including shape errors) at runtime. 
Typing is determined with respect to a scope (or context) that varies per call site. 

{\it
This arrangement is unusual. It means that an expression is typechecked with respect to the types of the actual arguments of the surrounding function rather  than any
formal types. This approach is possible because ShapeRank is not Turing complete and so we can perform type checking via an abstract interpretation that expands calls without risk of
divergence. The abstract interpretation is independent of the size of the program inputs.

The approach has significant advantages and disadvantages, but we feel the advantages greatly outweigh the disadvantages.

First, programmers need not specify base types, return types,  dimensions or type variables of any kind in function signatures. Second, typing is actually more accurate.
The resulting language is easier to learn, use and implement.
} 


%The built in type system does not guarantee that a function is shape safe for all possible

%ShapeRank is a statically typed language. Types describe the values that are used in the program. Every expression in a valid ShapeRank program must have a fixed type that can be determined at compile-time.

{\em 
%ShapeRank has a structural type system. Compatibility and equivalence of types is determined by the type's actual structure or definition, and not by  its name.
}

 \subsection{Type Inference}
  \label{typeInference}

We require type declarations for program parameters, including external functions.
For ShapeRank functions, only the ranks of formal parameters must be declared. All other type information is inferred.

Programs specify a type signature that specifies the rank and base type for each parameter. Programs also accept external functions as arguments.
For parameters representing external functions, the base type is  a function type with each parameter type, and the return type, all have a complete type signature including rank, dimensions and base type.

The actual rules of type inference for each construct are given in the section describing that construct. However, these rules depend on a common set of concepts, defined in this section.
 
  
  \subsubsection{Type Substitution}
  \label{typeSubstitution}
  
  A {\em type substitution} is a mapping of type, shape and dimension variables [\ref{typeVariables}] to types, shapes and dimensions respectively. We write $[X_1 \to T_1, \ldots\, X_n \to T_n]$ to denote the substitution that maps $X_i$ to $T_i, i \in 1..n$. A substitution $[X_1 \to T_1, \ldots, X_n \to T_n]$ may be {\em applied} to a type (respectively, shape or dimension) $T$, producing a new type (respectively, shape or dimension) where each free occurrence of $X_i$ in $T$ is replaced by $T_i ,i \in 1..n$.
  
If any of the free type variables of $T_i$ is bound in the surrounding scope, it is renamed to avoid capture.

{\em Define renaming.}

% Reference definition of "free". 
  
If $\theta$ is a substitution, we write $\theta T$ to denote the application of $\theta$ to $T$.


\subsection{Scalar Types}
\label{scalarTypes}

\subsubsection{Bool}
\label{bool}

The predefined type \BOOL{} contains the values true and false.  A boolean value is equal only to itself. The value true is greater than false. The type \BOOL{} is equal only to itself.

\subsubsection{Num}
\label{number}

 The predefined type \NUM{} consists of the types \INT{} and \FLOAT. The type \NUM{} is equal only to itself. 
 
\subsubsection{Int}
\label{int}

The predefined type \INT} consists of the integers. Equality and ordering are as defined for the integers in mathematics. The type \INT{} is equal only to itself.


\subsubsection{Float}
\label{float}

The predefined type \FLOAT{} consists of the set of IEEE double precision floating point values.  Equality and ordering are defined by the IEEE floating point standard.  The type \FLOAT{} is equal only to itself.
 
\subsubsection{Integer Singleton Types}
\label{integerSingletonTypes}

For each integer $n$, there exists a corresponding type consisting the singleton set of values $\{n\}$. 


\subsubsection{String}
\label{string}

The predefined type \STRING{} is a sequence of zero or more Unicode code points. Equality and ordering of code points are defined by the Unicode standard. 
The strings, $a = a_1, \ldots, a_n$ and $b = b_1, \ldots, b_n$ are equal iff $a_i = b_i, i \in 1..n$. Strings are ordered lexicographically., i.e., $a_1, \ldots, a_n < b_1, \ldots, b_m$ iff  either $a_1 < b_1$ or $a_1 = b1$ and $a_2, \ldots, a_n < b_2, \ldots, b_m$.

The type \STRING{} is equal only to itself. 

\subsubsection{Struct Types}
\label{structTypes}

A value of a struct type is composed of named values, known as {\em fields}. The type of a struct value is determined by the names and the types of the fields that it contains.

\StructType{}

\PropertySig{}

The type \LCURLY{}$f_1 \COLON{} T_1$\COMMA{} \ldots\COMMA{}  $f_k \COLON{} T_k$\RCURLY{} $, (f_i \ne f_j$ for $i \ne j)$ is equal to another type $X$ iff  $X \triangleq $ \LCURLY{}$f_1 \COLON{} S_1$\COMMA{} \ldots\COMMA{}  $f_k \COLON{} S_k$\RCURLY{} and $T_i = S_i, i \in 1..k$.


{\em
Structs are lexicographically ordered if we view structs as maps from field names to field values. 
}

\subsubsection{Function Types}
\label{functionTypes}

A {\em function type} describes the type of a function [\ref{functions}].

A function type consists of a domain and a range. A {\em domain} is a list of types, composed from the types of the formal parameters of a function, in the order they appear in the function declaration. A {\em range} is a result type of a function. 
We write a  function type as $T_1, \ldots, T_n \to T_r$, where $T_1, \ldots, T_n$ is the domain and $T_r$ is the range.

Function types are used internally in this specification, and can be indicated syntactically by external function signatures [\ref{externalFunctionDeclarations}]. These can only occur in program parameters [\ref{programsAndIO}].

{\em 
There are two reasons for this.  The base types of ShapeRank variables, other than program parameters, are always inferred. Furthermore, ShapeRank does not support user-defined higher order functions, and so users have no need to declare function signatures as types of parameters,
with the exception of external functions declared as program parameters.
}


\subsection{Hyperstream Types}
\label{hyperstreamTypes} 

A {\em hyperstream type} is a pair of a shape \ref{concepts} and a scalar type \ref{scalarTypes}. The scalar type component of a hyperstream type is known as its {\em base type}. The hyperstream type $(S,  T)$ denotes the set of hyperstreams of shape $S$ with elements of scalar type $T$. We often write $S$ $T$ to denote $(S,  T)$.


\subsection{Type Expressions}
\label{typeExpressions}

A {\em type expression} denotes a type. Type expressions are used whenever a type must be specified.


\subsubsection{Type Identifiers}
\label{typeIdentifiers}

A {\em type identifier} denotes a named type available in the current compile-time scope.

Let $i \triangleq T$. If $t$ is the type bound to $T$ in the current compile-time scope, $i$ denotes $t$. 

It is a compile-time error if $T$ does not denote a type in the current compile-time scope.

\subsubsection{Type Variables}
\label{typeVariables}

A {\em type variable} is either a {\em scalar type variable}, a {\em shape variable} or a {\em dimension variable}. Type variables may abstract over types, shapes and dimensions in the context of the declaration of a program declaration [\ref{programsAndIO}] or external function [\ref{functions}]. Scalar type variables abstract over  scalar types. Shape variables abstract over shapes. Dimension variables are used both to abstract over the dimensions in a shape, and over integer values, which are typically used as dimensions.

Scalar type, shape and dimension variables may be referred to as type, shape or dimension parameters respectively.

 The declaration of a program [\ref{programsAndIO}] or of an external function [\ref{externalFunctionDeclarations}] can be {\em parameterized} with one or more type variables. A parameterized declaration can be invoked (or instantiated) with different type arguments, allowing a single parameterized declaration to describe a family of (unparameterized) declarations. 
 
 A type variable $t$ is said to {\em free} in some expression, type expression, signature or scope $x$ if $t$ is not declared in $x$.  More precisely, we define the {\em free type variables} of $x$ as follows:
 
 
 $free(ID) = \{ID\}$ if $ID$ is a type variable or $\phi$ otherwise.
 
 $free([T]) = free(T)$.
 
 $free([K \COLON{} V]) = free(K) \cup free(V)$.
 
 $free(\{f_1\COLON{} T_1, \ldots, f_n\COLON{} T_n\}) =  free(T_1) \cup \ldots \cup free(T_n)$.
 
 $free(T_1, \ldots, T_n \to T_r) = (free(T_1) \cup \ldots free(T_n)) \cup free(T_r)$. 
 
 $free(F\LPAREN{} T_1\COMMA{} \ldots\COMMA{} T_n\RPAREN\COLON{}T_r) = free(\forall S_1, \ldots, S_k. T_1, \ldots, T_n \to T_r$ where $S_i \in 1..k$ are the type variables implicitly introduced in by $T_1, \ldots, T_n$.
 
 $free(\forall T_1, \ldots, T_n.T) = free(T) - \{T_1, \ldots, T_n\}$.
 
 
 We say a type variable $X$ is free in a scope $S$, if there exists an identifier $ID$ with type $T$ defined in $S$, and $X$ is free in $T$. The free type variables of $S$ are the set of all type variables that are free in $S$.

\paragraph{Scalar Type Variables.}
 
 Let $p \triangleq T$.
 
 Let $t$ be the type variable bound to $T$ in the current compile-time scope. If $T$ is not bound in the current compile-time scope, then, if $p$ occurs within  the parameter list of an external function signature,  a binding of $T$ to a fresh type variable $t$ is added to the current compile-time scope. In either case, $p$ denotes  $t$. 
 
 {\em 
No explicit declaration of a type variable is needed. They are declared by their first use, provided the use occurs in an external function signature. This restriction reduces the attendant risk of inadvertently introduced parameters; furthermore, since
 actual type arguments are inferred, such inconsistencies are likely to be caught due to a mismatch between actuals and formals.
 } 
 
 % what about program signatures?
 
 It is a compile-time error if $p$ is neither available in the enclosing compile-time scope, nor enclosed in the parameter list of an external function signature.
 
 \paragraph{Dimension Variables.}
 
 Let $p \triangleq d$.
 
 Let $t$ be the dimension variable bound to $d$ in the current compile-time scope. If $d$ is not bound in the current compile-time scope, then, if $p$ occurs within the parameter list of an external function signature,  a binding of $d$ to a fresh dimension variable $t$ is added to the current compile-time scope. In either case, $p$ denotes  $t$. 

 
 It is a compile-time error if $p$ is neither available in the enclosing compile-time scope, nor enclosed in the parameter list of an external function signature.
 
 \paragraph{Shape Variables.}


 Let $p \triangleq S$.
 
 Let $t$ be the shape variable bound to  $S$ in the current compile-time scope. If $S$ is not bound in the current compile-time scope, then, if $p$ occurs within the parameter list of an external function signature,  a binding of  $S$ to a fresh shape variable $t$ is added to the current compile-time scope. In either case, $p$ denotes  $t$. 
 
 It is a compile-time error if $p$ is neither available in the enclosing compile-time scope, nor enclosed in the parameter list of an external function signature.
 
\subsubsection{Hyperstream Type Descriptors}
\label{hyperstreamTypeDescriptors}

A {\em hyperstream type descriptor} is composed of a shape descriptor and a scalar type type descriptor. The shape descriptor may be omitted, in which case it defaults to the empty shape. 

\TypeSig{}
\HyperstreamType

\paragraph{Dimension Descriptors.}
A {\em dimension descriptor} has the form $[d]$ where $d$ is a dimension. 

\Dimension

A {\em dimension} is one of
\begin{itemize}
\item An integer literal $n$ [\ref{integerLiterals}]. This indicates the size of the described dimension is the value of $n$.
\item An optional dimension variable [\ref{typeVariables}] $v$, possibly followed by \BANG. This indicates the size of the described dimension is the value of $v$.
The use of the \BANG{} suffix indicates the the described  dimension must be of fixed size. 
{\em ergo, it must be an array, not a stream.}
If $v$ is omitted, it defaults to \QUESTIONMARK{}. 
\item The sum of two dimensions, $d_1 + d_2$
\item  \QUESTIONMARK. This indicates the described dimension's size is unbounded.
 \end{itemize}
 
\paragraph{Shape Descriptors.}
 A {\em shape descriptor} denotes a shape vector. 
 
 \Shape
 
A shape descriptor takes one of the following forms:
 \begin{itemize}
 \item A shape variable [\ref{typeVariables}], possibly followed by \BANG. The use of the \BANG{} suffix indicates the the shape's  dimensions must all be of fixed size. 
 \item A shape append, of the form $s_1 :: s_2$, where $s_1, s_2$ are shape descriptors, denoting the concatenation of the shape vectors denoted by $s1$ and $s_2$. 
  \item  A list $[d_1] \ldots [d_n]$, denoting the shape vector $[d_1, \ldots, d_n]$ where $[d_i], i \in 1..n$ are dimension descriptors.
 \end{itemize}
 
\paragraph{Scalar Type Descriptors.}
 A {\em scalar type descriptor} is either a type variable [\ref{typeVariables}] or one of \BOOL [\ref{bool}],  \NUM,[\ref{number}] \INT, \FLOAT, \STRING [\ref{string}], an integer literal [\ref{integerSingletonTypes}], or a struct type [\ref{structTypes}].
 
 \ElementType


\section{Lexical Rules}
\label{lexicalRules}
\printlexitable

\section{Grammar}
\label{grammar}
\printgrammartable



\end{document}
