Newspeak3
'Root'
class BuildSystem usingPlatform: p parser: parsing <ShapeRankParser> streams: hs <HyperStream class> ffi: swf <ShapeWebFFI> 
(* :exemplar: [
	|
	namespace
	embedder
	ide
	parsers
	grammar
	parsing
	Evaluator
    utils
    hyperstreams
	Scopes
    InterimTypechecker
	Typechecker
	interpreter
	hopscotchPlatform
	|
	
    utils:: CollectionUtils usingPlatform: platform.
    hyperstreams:: HyperStreams usingPlatform: platform.
	Scopes::
	  (ShapeRankScopes usingPlatform: platform asts: ShapeRankASTs tensorflow: Tensorflow nodeAPI: NodeAPI) Scopes.
    InterimTypechecker::
	  (ShapeRankTypechecker  usingPlatform: platform asts: Scopes collectionUtils: utils)
	     Typechecker.     
    Typechecker::
	  (ShapeRankConcreteTypechecker  usingPlatform: platform asts: InterimTypechecker collectionUtils: utils streams: hyperstreams)
	     TypeInterpreter.
    interpreter:: ShapeRankStreamInterpreter usingPlatform: platform
	                                    asts: Typechecker
                                        collectionUtils: utils
                                        streams: hyperstreams.
    Evaluator:: interpreter Evaluator.
    parsers:: CombinatorialParsing usingPlatform: platform.
    grammar:: ShapeRankGrammar usingPlatform: platform parsers: parsers.
    parsing:: ShapeRankParser usingPlatform: platform grammar: grammar asts: Evaluator collectionUtils: utils.

    BuildSystem usingPlatform: platform parser: parsing streams:  hyperstreams HyperStream ffi: (ShapeRankWebFFI usingPlatform: platform api: NodeAPI)] value *) = (
  |
  private JSArray = p js global at: 'Array'.
  private Parser = parsing Parser.
  private HyperStream <HyperStream class> = hs.
  parser = Parser new.
  api <NodeAPI> = swf api.
  ffi <ShapeRankWebFFI FFI> = swf FFI parser: parser.
  watcher <Alien> =  ffi api require: 'build_demo_lib'.  
  |
) (
public run2 = (
  | shapeRankProgram = parser program parseString: shapeRankSource2. |
  ^shapeRankProgram evaluateWithArguments: {
      HyperStream fromScalar:
       (ffi newspeakFunction: #getFile: ofObject: self signature: '(filePath: String): [?] String')
    }.
)
shapeRankSource2  ^ <String> = (
  ^'
  program build(getFile: (filePath: String): [?] String)
  getFile("Users/gbracha/shapeRank/f5/shapeRank/examples/a.c")
 '
)
public getFile: path  <String> ^ <HyperStream> = (
  | stream <HyperStream> = HyperStream extensible. |
  stream iterator add: path.
 watcher getFiles: path do: [:filepath <String> | 
     stream iterator add: path.
     nil
     ].
  ^stream
)
shapeRankSource ^ <String> = (
  ^'
  program build(getFile: (filePath: String): [?] String, clang: (target: String, deps: [?]String, flags: String): String, basicLink: (target: String, deps: [?]String, flags: String): String)
  func cc(target: String, deps: []String, flags: String) = 
  clang(getFile(target), zip(getFile(deps)), flags)

  func link(target: String, deps: [][]String, flags: String) =   basicLink(target, zip(deps), flags);
  
  link("myApp", [
   cc("Users/gbracha/shapeRank/f5/shapeRank/examples/a.c", ["Users/gbracha/shapeRank/f5/shapeRank/examples/b.h"], "-c"),
   cc(‘Users/gbracha/shapeRank/f5/shapeRank/examples/b.c’, ["Users/gbracha/shapeRank/f5/shapeRank/examples/b.h", "Users/gbracha/shapeRank/f5/shapeRank/examples/c.h"], "-c"),
   cc("Users/gbracha/shapeRank/f5/shapeRank/examples/c.c", ["Users/gbracha/shapeRank/f5/shapeRank/examples/c.h"], "-c"),
   cc("d.c", [], "-c"),                                     
], "") 
  '
)
public cc: path <String> dependencies: ds  <HyperStream[String]> flags: s <String>  ^ <HyperStream> = (
  | prefix <String>  deps = JSArray new: ds size. |
  (* ds should be bounded hyperstream; we need to create an array of its elements and pass that down to JS.  Because of the problem with expat arrays, it needs to be a JS array. *)
  1 to: ds size do: [:i | deps at: i put: ds iterator next].
  watcher clang: path dependencies: deps flags: s.
  ^HyperStream fromScalar: prefix, '.o'
)
public link: path <String> dependencies: ds  <HyperStream[String]> flags: s <String>  ^ <HyperStream> = (
| deps = JSArray new: ds size. |
  (* ds should be a hyperstream of shape [k] for some finite k; we need to create a k-array of its elements and pass that down to JS.  Because of the problem with expat arrays, it needs to be a JS array. *)
  watcher basicLink: path dependencies: deps flags: s.
  ^HyperStream fromScalar: path
)
public run = (
  | shapeRankProgram = parser program parseString: shapeRankSource. |
  shapeRankProgram evaluateWithArguments: {
    ffi newspeakFunction: #getFile: ofObject: self signature: '(filePath: String): [?] String'.
    ffi newspeakFunction: #cc:dependencies:flags: ofObject: self signature: '(target: String, deps: [?]String, flags: String): String'.   
    ffi newspeakFunction: #link:dependencies:flags: ofObject: self signature: '(target: String, deps: [?]String, flags: String): String'.    
    }.
)
) : (
)
