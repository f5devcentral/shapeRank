Newspeak3
'Root'
class ShapeRankStreamInterpreter usingPlatform:
platform asts: asts collectionUtils: utils streams: hs = ( (*
Interpreter for ShapeRank with stream support.  *)
  | private ASTClass <ShapeRankAST class> = asts.
    private HyperStream <HyperStream class> = hs HyperStream.
    private Iterator = hs Iterator.
    private Map = platform collections Map.
    private List = platform collections List.
    private Utils = utils.
    | ) (
public class Evaluator usingPlatform: p
<Platform> collectionUtils: c = ASTClass usingPlatform: p
collectionUtils: c ( (* As indicated elsewhere, this class leverages
class hierarchy inheritance, extending the AST with interpretation
machinery without compromising modularity.

Runtime values are represented by class Tensor.  These are produced by evaluation, performed by the #eval
methods of various AST nodes.   Interpretation uses a call stack, which consists of individual activations. Class 
Activation implements this, providing the runtime scope by mapping parameter names to tensors.
*)
  | 
  callStack <List[Activation]> = List new. 
  emptyFrame = Tensor dimensions: {} contents: {}.
  specialEvaluators <Map[Symbol, [List[ExprAST] | List[Tensor]]]> = computeSpecialEvaluators.
  |
) (
class Activation of: f <FunctionAST> from: argVector <List[Stream]> = (
|
  function <FunctionAST> = f.
  public arguments <List[Stream]> = argVector.
|
) (
public at: k <Symbol> ^ <Stream> = (
  ^at: k ifAbsent: [Error signal: 'Undefined variable ', k]. (* should never happen in a typechecked prgram *)
)
public at: k <Symbol> ifAbsent: blk <[Stream]> ^ <Stream> = (
  1 to: function parameters size do: [:i <Integer> |
  (function parameters at: i) id = k ifTrue: [ | arg |
    arg:: arguments at: i.
    arg isKindOfAbstractStream ifFalse: [arg:: scalar: arg].
    ^arg
    ]
  ].
^blk value 
)
) : (
)
public class BlockAST body: e <ExprAST> position: p <{Integer. Integer}> = super BlockAST body: e position: p (
  | private body = e. |
) (
public eval ^ <Tensor> = (
  | homeContext = callStack isEmpty ifTrue: [emptyFrame] ifFalse: [currentActivation]. |
  ^Tensor dimensions: {} contents: {
    Block body: body context: homeContext
  }
)
) : (
public body: e <ExprAST> ^ <Instance> = (
(* sigh, we should find a solution for class method inheritance *)
  ^body: e position: e position
)
)
public class WhereAST expr1: e1 <ExprAST> ident: id <Symbol> expr2: e2 <ExprAST> position: p <{Integer. Integer}> = super WhereAST expr1: e1 ident: id expr2: e2 position: p (
) (
public eval ^ <Tensor> = (
  (* e1 already has ident -> e2 in its scope *)
  ^expr1 eval
)
) : (
)
public class BoolAST value: v <Boolean> position: p <{Integer. Integer}> = super BoolAST value: v position: p (
) (
public eval  ^ <Tensor> = (
  ^ Tensor dimensions: {} contents: {val}
)
) : (
)
public class StringAST value: v <String> position: p <{Integer. Integer}> = super StringAST value: v position: p (
) (
public eval ^<Tensor> = (
  ^Tensor dimensions: {} contents: {val}
)
) : (
)
public class StructLiteralAST data: data <Map[Symbol, ExprAST]> position: p <{Integer. Integer}> = super StructLiteralAST data: data position: p (
) (
public eval ^<Tensor> = (
  ^Tensor dimensions: {} contents: { Record contents: (contents collect: [:v | v eval]) }
)
) : (
)
public class StructDotAST expr: expr <ExprAST> label: label <Symbol> position: p <{Integer. Integer}> = super StructDotAST expr: expr label: label position: p (
) (
public eval ^<Tensor> = (
  ^evalOn: (expr eval)
)
public evalOn: t <HyperStream | Record | ParameterAST> ^<HyperStream> = (
  t isKindOfParameterAST ifTrue: [^evalOn: (currentActivation at: t id)].
  t isKindOfRecord ifTrue: [^t data at: label ifAbsent: [ assert: false. nil]]. (* is this right? *)
  t isKindOfHyperStream ifTrue: [
    | ret = t map: [:v | evalOn: v]. |
    t isScalar ifTrue: [^ret contents at: 1] ifFalse: [^ret]
  ].
  Error signal: 'Could not index non-struct object'.
)
) : (
)
public class CallAST function: f <Symbol> arguments: as <List[ExprAST]> position: p <{Integer. Integer}> =  super CallAST function: f  arguments: as  position: p  (
) (
public eval ^ <Tensor> = (
  ^computeFunction: callee arguments: evaluateArguments
)
evaluateArgument: arg <ExprAST> for: param <ParameterAST> ^ <Tensor | AST> = (
  ^(param isHOF and: [arg isKindOfBlockAST not]) ifTrue: [
        | ast ::= (scope lookup: arg id ifAbsent:
                     [^(currentActivation at: arg id)]) at: #ast. |
        ast isKindOfParameterAST ifTrue: [^(currentActivation at: ast id)].
        Tensor dimensions: {} contents: {ast}
     ] ifFalse: [arg eval]
)
evaluateArguments = (
   | result = List new: arguments size. |
   1 to: arguments size do: [:i <Integer> | result add: (evaluateArgument: (arguments at: i) for: (callee parameters at: i))].
   ^result
)
) : (
)
class Frame dimensions: ds <List[Integer]> cells: cs <HyperStream[Cell[T def]]> = (
(* A Frame is a hyperstream of cells. The shape of the hyperstream is given by #dimensions.
The cells themselves are provided as a hyperstream.
*)
|
  public dimensions  <List[Integer | UnboundedDimension]> = ds.
  public cells <HyperStream[Cell[T]]> = cs.
|
) (
public hasRank ^ <Boolean> = (
   ^true
)
public max: t <Frame> ^ <Frame> = (
 (* should check that either my shape is a prefix of t's or vice versa *)
  dimensions size > t dimensions size ifTrue: [^self].
  ^t
)
public printString = (
  ^'Frame of rank: ', rank printString
)
public rank ^ <Integer> = (
  ^dimensions size
)
public size = (
  ^dimensions reduce: [:d1 <Integer> :d2 <Integer> | d1 * d2] ifEmpty: [1]
)
public replicateToMatch: dims <List[Integer | UnboundedDimension]> ^ <Frame[T]> = (
(* Create a frame of shape dims, that replicates the contents of this frame as needed; 
    We assume dims are the dimensions of a frame that is a suffix of this frame. *)
  |  cdims <List[Integer]> = dims copyFrom: dimensions size + 1 to: dims size. |
  cdims isEmpty ifTrue: [^self].
  ^Frame dimensions: dims cells: (HyperStream replicate: cells dimensions: cdims)
)
public map: f <[T | X def]> ^ <Frame[X]> = (
  ^Frame 
        dimensions: dimensions 
        cells: (cells map: [:c <Cell[T]> | Cell for: (f value: c contents)])
)
public asStream ^ <HyperStream[T]> = (
  ^cells map: [:c <Cell[T]> | c contents ]
)
public prefixOf: f <Frame> ^ <Boolean> = (
  (* Answer whether my shape is a prefix of f's or vice versa *)
    dimensions size >= f dimensions size ifTrue: [^f isPrefixOf: self].
   ^isPrefixOf: f
)
inPrefixRelationWith: f <Frame> ^ <Boolean> = (
  (* Answer whether my shape is a prefix of f's or vice versa *)
    dimensions size >= f dimensions size ifTrue: [^f isPrefixOf: self].
   ^isPrefixOf: f
)
public isPrefixOf: f <Frame> ^ <Boolean> = (
  (* Answer whether my shape is a prefix of f's. Must only be called if length(shape(f))  >= length(shape(self)) *)
   dimensions with: (f dimensions copyFrom: 1 to: dimensions size) do: [:d <Integer | UnboundedDimension> :fd <Integer | UnboundedDimension> |
      d = fd ifFalse: [^false]
   ].
   ^true
)
public synchronouslyFuse: f <Frame[S def]> ^ <Frame[{T. S}]> = (
  | maxdims <List[Integer | UnboundedDimension]> = dimensions size > f dimensions size ifTrue: [dimensions] ifFalse: [f dimensions]. |
    (*  Check that f's shape is a prefix of my shape or vice versa *)
     (inPrefixRelationWith: f) ifFalse: [Error signal: 'Frame ', f printString, ' is not a prefix of ', printString, ' nor vice versa'].
     (* fuse *)
     ^Frame: maxdims cells: (synchronouslyFuse: cells with: f cells) 
)
public reactivelyFuse: f <Frame[S def]> ^ <Frame[{T.S}]> = (
  | maxdims <List[Integer | UnboundedDimension]> = dimensions size > f dimensions size ifTrue: [dimensions] ifFalse: [f dimensions]. |
    (*  Check that f's shape is a prefix of my shape or vice versa *)
     (inPrefixRelationWith: f) ifFalse: [Error signal: 'Frame ', f printString, ' is not a prefix of ', printString, ' nor vice versa'].
     (* fuse *)
     ^Frame: maxdims cells: (reactivelyFuse: cells with: fcells)
)
) : (
)
public class IdentifierAST named: n <String> position: p <{Integer. Integer}> = super IdentifierAST named: n  position: p  (
) (
computeBinding  ^ <Tensor> = (
   callStack isEmpty ifFalse: [^currentActivation at: id ifAbsent: [evalFromScope: id]].
  ^evalFromScope: id.
)
public eval  ^ <Tensor> = (
   callStack isEmpty ifFalse: [^currentActivation at: id ifAbsent: [evalFromScope: id]].
  ^evalFromScope: id.
)
evalFromScope:  n <Symbol> ^ <ExprAST> = (
  | decl = (scope lookup: id) at: #ast. |
  decl isKindOfLetAST ifTrue: [^decl expression eval].
  decl isKindOfExprAST ifTrue: [^decl eval].
  decl isKindOfFunctionAST ifTrue: [Error signal: 'Higher order functions not supported'].
 ^decl
)
) : (
)
public class NumAST value: n <Integer> position: p <{Integer. Integer}> = super NumAST value: n position: p () (
public eval  ^ <Tensor> = (
  ^ Tensor dimensions: {} contents: {val}
)
) : (
)
class PrimitiveBodyAST block: blk <Block> = super PrimitiveBodyAST block: blk (
) (
public eval ^ <Tensor> = (
  ^block valueWithArguments: currentActivation arguments asArray
)
) : (
)
public class ProgramAST declarations: ds <List[FunctionAST]> expression: e <ExprAST> position: p <{Integer. Integer}> = 
  super ProgramAST declarations: ds expression: e position: p (
) (
public eval ^ <Tensor> = (
  ^expression eval.
)
) : (
)
public class RerankAST  reranking: fn <String> to: rs <List[Integer]> position: p <{Integer. Integer}>  = 
  super RerankAST reranking: fn to: rs  position: p (
) (
public eval  ^ <Tensor> = (
  ^etaExpansion
)
) : (
)
public class ShapeCastAST expression: e <ExprAST> to: s <ShapeAST> position: p <{Integer. Integer}> = 
  super ShapeCastAST expression: e to: s position: p (
) (
ensure: t <Tensor>  conformsTo: s <ShapeAST> ^ <Boolean> = (
  ^t shape = shape
)
public eval  ^ <Tensor> = (
  | result <Tensor> = expression eval. |
  (ensure: result conformsTo: shape) ifFalse: [Error signal: 'Runtime type error: cast failed'].
  ^result
)
) : (
)
class Record contents: data <Map[Symbol, Tensor]> = (
  | public data <Map[Symbol, Tensor]> = data. |
) (
public isKindOfRecord = (
  ^true
)
public = other <Object> ^<Boolean> = (
  other isKindOfRecord ifFalse: [^false].
  ^(Utils maps: data eq: other data)
)
public hash ^<Integer> = (
  ^(Utils valueMapHashOf: data)
)
public printString ^<String> = (
  | ret ::= '{ '.
    first ::= true. |
  data keysAndValuesDo: [:k :v |
    first ifTrue: [first:: false] ifFalse: [ret:: ret, ', '].
    ret:: ret, ' ', k, ': ', v printString.
  ].
  ret:: ret, ' }'.
  ^ret
)
) : (
)
public class Block body: e <ExprAST> context: c <Activation> = (
  | public body = e.
    private ctx = c. |
) (
public hasRank ^ <Boolean> = (
   ^true
)
public rank ^ <Integer> = (
  ^0
)
public evalBody ^<Tensor> = (
  | result <Tensor> |
  pushActivation: ctx.
  result:: body eval.
  popActivation.
  ^result
)
public isKindOfBlock = (
  ^true
)
) : (
)
class Tensor dimensions: ds <List[Integer]> contents: cs <List[Object]> = (
(*
A Tensor is either scalar or not. It is scalar iff it is of rank 0.
A non-scalar Tensor contains a list of subtensors stored in its #contents. A scalar Tensor
has an empty #dimensions list, and contains a single non-Tensor in #contents.
*)
|
  public dimensions <List[Integer]> = ds.
  public contents <List[Object]> = cs.
|
) (
public = other <Object> ^ <Boolean> = (
  (isScalar & other isScalar) ifTrue: [^asScalar = other asScalar].
  other isKindOfTensor ifFalse: [^false].
  other dimensions  with:  dimensions do: [:od :d | od = d ifFalse: [^false]].
  other contents with: contents do: [:oe :e | oe = e ifFalse: [^false]].
  ^true.
)
public asScalar ^ <Object> = (
  | c |
  isScalar ifFalse: [Error signal: printString, ' is not a scalar'].
  c:: contents at: 1.
  c isKindOfTensor ifTrue: [^c asScalar].
  ^c
)
public contains: element = (
   isScalar ifTrue: [^self = element].
   contents do: [:subtensor <Tensor> | (subtensor contains: element) ifTrue: [^true]].
   ^false
)
public hasRank ^ <Boolean> = (
   ^true
)
public isKindOfTensor ^ <Boolean> = (
  ^true
)
public isScalar ^ <Boolean> = (
| c |
  ^rank = 0 and: [
  contents size = 1 and: [
    c:: contents at: 1. 
    c isKindOfTensor not or: [c isScalar]
    ]
  ]
)
public map: f <[Object | T def]> ^ <Tensor[T]> = (
  | newContents = contents collect: f.
    newDimensions = (newContents size > 0 and: [newContents first isKindOfTensor])
                    ifTrue: [
                      | myDim = dimensions size > 0
                                  ifTrue: [{dimensions first}]
                                  ifFalse: [dimensions]. |
                        myDim, newContents first dimensions]
                    ifFalse: dimensions. |
  ^Tensor dimensions: newDimensions contents: newContents
)
public max: t <Tensor> ^ <Tensor> = (
 (* should check that either my shape is a prefix of t's or vice versa *)
  dimensions size > t dimensions size ifTrue: [^self].
  ^t
)
public printOn: stream <CharOutputStream> = (
      rank > 0 ifTrue: [
     stream nextPutAll: '['.
         contents do: [:e | e printOn: stream] separatedBy: [ stream nextPutAll: ', ']. 
         stream nextPutAll: ']'.
      ]
      ifFalse: [(contents at: 1) printOn: stream]
)
public printString ^ <String> = (
  | contentString <String> |
      contentString:: ''.
      ^rank > 0 ifTrue: [
     contents do: [:e | contentString:: contentString, e printString] 
          separatedBy: [contentString:: contentString, ', '].
     '[', contentString, ']'.
      ]
      ifFalse: [(contents at: 1) printString]
)
public rank ^ <Integer> = (
  ^dimensions size
)
public shape ^ <ShapeAST> = (
  | dims <List[DimensionNumber]> = dimensions collect: [:d <Integer> | DimensionNumberAST number: d position: {0. 0} ]. |
  ^ShapeVectorAST dimensions: dims position: {0. 0}
)
public hash ^ <Integer> = (
  dimensions hash bitXor: [contents hash].
)
public cellsOfShape: cds <List[Integer]> ^ <HyperStream> = (
  assert: [rank >= cds size] message: 'Cells larger than Stream!'.
  rank = cds size ifTrue: [^{self}].
  ^(contents collect: [:e <Tensor> | e cellsOfShape: cds]) flatten
)
public asStream ^ <HyperStream> = (
  | subtensors <List[HyperStream]>  |
  isScalar ifTrue: [^HyperStream fromScalar: self asScalar].
  subtensors:: contents collect: [:subtensor <Tensor> | subtensor asStream].
  ^HyperStream fromList: subtensors dimensions: dimensions
)
) : (
)
public class TensorAST expressions: es <List[ExprAST]> position: p <{Integer. Integer}> = super TensorAST expressions: es  position: p (
) (
appendDimensionsOf: e <ExprAST> to: ds <List[Integer]> ^  <List[Integer]> = (
  e isKindOfTensorAST ifTrue: [
  ds add: e expressions size.
  appendDimensionsOf: e expressions first to: ds
  ].
   ^ds
)
public dimensions = (
  ^appendDimensionsOf: self to: List new
)
public eval  ^ <Tensor> = (
  ^ Tensor dimensions: dimensions contents: (expressions flatMap: [:e <ExprAST> | e eval])
)
public hasRank ^ <Boolean> = (
   ^true
)
public rank ^ <Integer> = (
  ^dimensions size
)
) : (
)
class Cell for: s <HyperStream[T def]> = (
  |
  public contents <HyperStream[T]> = s.
  |
) (
) : (
)
class SynchronouslyFusedIterator fusing: i1<Iterator[HyperStream[T def]]> and: i2  <Iterator[HyperStream[S def]]> = Iterator (
(*
Synchronous fusion of two iterators.
*)
  |
  iterator1 <Iterator[HyperStream[T]]> = i1.
  iterator2 <Iterator[HyperStream[S]]> = i2.
  |
) (
public rank ^ <Integer> = (
  ^iterator1 rank max: iterator2 rank
)
public clone = (
  ^class fusing: iterator1 clone and: iterator2 clone
)
public hasNext ^ <Boolean> = (
(* A synchronously fused iterator's hasNext if both iterator's hasNext is true. *)
  ^iterator1 hasNext and: [iterator2 hasNext]
)
public next ^ <HyperStream[{T. S}]> = (
(* A synchronously fused iterator's next is the synchronous fusion of the next elements of each iterator. *)
  ^synchronouslyFuse: iterator1 next with: iterator2 next
)
) : (
)
class ReactivelyFusedIterator fusing: i1<Iterator[HyperStream[T def]]> and: i2  <Iterator[HyperStream[S def]]> = Iterator (
  |
  iterator1 <Iterator[HyperStream[T]]> = i1.
  iterator2 <Iterator[HyperStream[S]]> = i2.
  |
) (
public clone = (
  ^class fusing: iterator1 clone and: iterator2 clone
)
public rank ^ <Integer> = (
  ^iterator1 rank max: iterator2 rank
)
public hasNext ^ <Boolean> = (
  ^iterator1 hasNext or: [iterator2 hasNext]
)
public next ^ <HyperStream[{T. S}]> = (
  ^reactivelyFuse: iterator1 next with: iterator2 next
)
) : (
)
public DimensionNumberAST ^ <DimensionNumberAST class> = (
  ^super DimensionNumberAST
)
public ShapeVectorAST ^ <ShapeVectorAST class> = (
  ^super ShapeVectorAST
)
computeSpecialEvaluators ^ <Map[Symbol, [List[ExprAST] | List[Tensor]]]> = (
  | ses <Map[Symbol, [List[ExprAST] | List[Tensor]]]> = Map new. scanReduceBlock <[List[ExprAST] | List[Tensor]]>  |
  scanReduceBlock:: [:args <List[ExprAST]> | 
  List new 
    add: (Tensor dimensions: {} contents: {(programScope lookup: (args at: 1) id) at: #ast}); 
    add: (args at: 2) eval; 
    add: (args at: 3) eval;
    yourself
  ].
  ses 
  at: #fold put: scanReduceBlock; 
  at: #innerProduct put: innerProductBlock; 
  at: #outerProduct put: scanReduceBlock; 
  at: #reduce put: scanReduceBlock; 
  at: #scan put: scanReduceBlock.
  ^ses
)
currentActivation ^ <Activation> = (
   ^callStack last
)
currentProgram ^ <ProgramAST> = (
  ^super currentProgram
)
innerProductBlock = (
  ^[:args <List[ExprAST]> | 
  List new 
    add: (args at: 1) eval; 
    add: (args at: 2) eval; 
    add: (Tensor dimensions: {} contents: {(programScope lookup: (args at: 3) id) at: #ast}); 
    add: (Tensor dimensions: {} contents: {(programScope lookup: (args at: 4) id) at: #ast}); 
    yourself
  ].
)
popActivation = (
  callStack removeLast.
)
programScope ^ <Scope> = (
  ^super programScope
)
pushActivation: a <Activation> = (
  callStack add: a
)
scalar: o <Object> ^ <Stream> = (
  ^HyperStream fromScalar: o
)
frameArgument: arg <HyperStream[T def]> forParameter: p <ParameterAST> ^ <Frame[T]> = (
  (* unranked parameter: use entire argument as sole cell *)
  p hasRank ifFalse: [
  ^Frame dimensions: {} cells: (HyperStream fromList: {arg} dimensions: {1}).
  ].
  arg rank >= p rank ifTrue: [ 
  | fdims <List[Integer | UnboundedDimension]> = arg dimensions copyFrom: 1 to: arg rank - p rank. |
    ^Frame dimensions: fdims cells: (cellsFor: fdims from: arg).
  ].
   ^Error signal: 'Rank of actual argument ' , arg printString, '(', arg rank printString, ') is less than rank of formal parameter ', p id, ' (', p rank printString, ')'.
)
cellsFor: fdims <List[Integer | UnboundedDimension]> from: arg <HyperStream[T def]>  ^ <HyperStream[Cell[T]]> = (
    (* base case: empty frame with single cell *)
    fdims isEmpty ifTrue: [^HyperStream fromScalar: (Cell for: arg)].
    (* recursively traverse first dimension of the argument, computing cells for each element *)
    ^arg asStream collect: [:e  <HyperStream[T]>  |  cellsFor: (fdims copyFrom: 2 to: fdims size) from: e]
)
frameArguments: args <List[HyperStream]> of: callee <FunctionAST> ^ <List[Frame]> = (
  | argFrames <List[Frame]> = List new: args size. |
  args with: callee parameters do: [:a <HyperStream> :p <ParameterAST> |
  argFrames add: (frameArgument: a forParameter: p)
  ].
  ^argFrames
)
computeFunction: callee <FunctionAST> arguments: args <List[HyperStream]> ^  <HyperStream> = (
  | 
  argFrames <List[Frame]> = frameArguments: args of: callee. (* frame *)
  maxFrame <Frame>
  replicatedFrames <List[Frame]>
  zippedFrame <Frame>
  resultFrame <Frame>
  |
(* replicate *)
  maxFrame:: argFrames reduce: [:f1 <Frame> :f2 <Frame> |
  f1 max: f2
  ] ifEmpty: [emptyFrame].
  replicatedFrames:: argFrames collect: [:f <Frame> | f replicateToMatch: maxFrame dimensions].
(* zip *)
  zippedFrame:: zipFrames: replicatedFrames. 
(* map *)
  resultFrame:: zippedFrame map: [:argVector <List[HyperStream]> | 
   | result  <HyperStream> | 
   pushActivation:  (Activation of: callee from: argVector).
   result:: callee body eval.
   popActivation.
   result.
  ].
  ^resultFrame asStream.  
)
zipFrames: l <List[Frame]> ^ <Frame[List]> = (
  | 
  (* All the incoming frames have the same shape, so we pick the first; if the list is empty, dims is empty too *)
  dims = l isEmpty ifFalse: [l first dimensions] ifTrue: [{}].
  (* Extract the frame's contents, and zip them *)
  zipped <HyperStream[List]> = HyperStream zipReactive: (l collect: [:f <Frame> | f cells contents]). 
  (* Convert the zipped contents into cells *)
  zippedCells <HyperStream[Cell[List]]> = cellsFor: dims from: zipped.
  |
  ^Frame dimensions: dims cells: zippedCells.
)
fuseBounded: b <BoundedHyperStream[Cell[U def]]> withScalar: s <ScalarHyperStream[Cell[S def]]> ^ <BoundedHyperStream[Cell[{U. S}]]> = (
(*
To fuse a bounded stream, b, and a scalar one, s, (either synchronously or reactively, makes no difference), we create a new bounded hyperstream whose window consists of the pointwise fusion of b's elements with s.
*)
 | fusedSubstreams <List[HyperStream[Cell[{U. S}]]]> =  List new: b size. |
 1 to: b size do: [:i <Integer> |
    | be <HyperStream[Cell[U]]> = b iterator next.  | 
       fusedSubstreams add: (be fuse: s)
     ]. 
  ^HyperStream fromList: fusedSubstreams
)
fuseScalar: s1 <ScalarHyperStream[Cell[S1 def]]> withScalar: s2 <ScalarHyperStream[Cell[S2 def]]> ^ <ScalarHyperStream[Cell[List]]> = (
(*
The fusion of two ScalarHyperStreams, s1 and s2, is a scalar hyperstream over a Cell of a flattened pair of the contents of the cells of s1 and s2.
*)
| flatPair <List> |
  ^HyperStream fromScalar: (Cell for: flatPair)
)
fuseUnbounded: u <UnboundedHyperStream[U def]> withScalar: s <ScalarHyperStream[S def]> ^ <UnboundedHyperStream[{U. S}]> = (
(*
To fuse an unbounded stream, u,  and a scalar one, s, (either synchronously or reactively, makes no difference), we create a new unbounded hyperstream whose iterator hasNext if u iterator hasNext, and whose next is the fusion of the u next and s.
*)
  | fusedIterator <Iterator> |
  ^HyperStream iteratingOver: fusedIterator
)
synchronouslyFuse: cells with: fcells <HyperStream[Cell[S def]]> ^ <Hyperstream[Cell[{T. S}]]> = ( 
(* ordering is still an issue *)
     cells isKindOfScalarHyperStream ifTrue: [
        fcells isKindOfScalarHyperStream ifTrue: [^fuseScalar: cells withScalar: fcells].
        fcells isKindOfUnboundedHyperStream 
           ifTrue: [^fuseUnbounded: fcells withScalar: cells].
        ^fuseBounded: fcells withScalar: cells
     ] ifFalse: [
          cells isKindOfUnboundedHyperStream ifTrue: [
                  fcells isKindOfScalarHyperStream ifTrue: [^fuseUnbounded: cells withScalar: fcells].
                  ^synchronouslyFuseUnbounded: cells with: fcells
          ].
          fcells isKindOfScalarHyperStream ifTrue: [^fuseBounded: cells withScalar: fcells].
          ^synchronouslyFuseBounded: cells with: fcells  
          ]
)
synchronouslyFuseBounded: u <BoundedHyperStream[Cell[U def]]> with: v <BoundedHyperStream[Cell[V def]]> ^ <BoundedHyperStream[Cell[{U. V}]]> = (
(*
To synchronously fuse two bounded hyperstreams, create a new bounded hyperstream, whose window consists of the pointwise synchronous fusion of the constituent hyperstreams of their windows (whose sizes necessarily agree).
*)
 | fusedSubstreams <List[HyperStream[Cell[{U. V}]]]> =  List new: u size. |
 1 to: u size do: [:i <Integer> |
    | ue <HyperStream[Cell[U]]> = u iterator next. ve <HyperStream[Cell[V]]> = v iterator next. | 
       fusedSubstreams add: (synchronouslyFuse: ue with: ve)
     ]. 
  ^HyperStream fromList: fusedSubstreams
)
synchronouslyFuseUnbounded: u <UnboundedHyperStream[Cell[U def]]> with: v <UnboundedHyperStream[Cell[V def]]> ^ <UnboundedHyperStream[Cell[{U. V}]]> = (
(*
To synchronously fuse two unbounded hyperstreams, we create a new unbounded hyperstream, whose iterator is the synchronous fusion of their iterators.
*)
  ^HyperStream iteratingOver: (SynchronouslyFusedIterator fusing: u iterator and: v iterator)
)
reactivelyFuseUnbounded: u <UnboundedHyperStream[U def]> with: v <UnboundedHyperStream[V def]> ^ <UnboundedHyperStream[{U. V}]> = (
(*
To reactively fuse two unbounded hyperstreams, we create a new unbounded hyperstream, whose iterator is the reactive fusion of their iterators.
*)
  ^HyperStream iteratingOver: (ReactivelyFusedIterator fusing: u iterator and: v iterator)
)
reactivelyFuseBounded: u <BoundedHyperStream[Cell[U def]]> with: v <BoundedHyperStream[Cell[V def]]> ^ <BoundedHyperStream[Cell[{U. V}]]> = (
(*
To synchronously fuse two bounded hyperstreams, create a new bounded hyperstream, whose window consists of the pointwise reactive fusion of the constituent hyperstreams of their windows (whose sizes necessarily agree).
*)
 | fusedSubstreams <List[HyperStream[Cell[{U. V}]]]> =  List new: u size. |
 1 to: u size do: [:i <Integer> |
    | ue <HyperStream[Cell[U]]> = u iterator next. ve <HyperStream[Cell[V]]> = v iterator next. | 
       fusedSubstreams add: (ue reactivelyFuse: ue with: ve)
     ]. 
  ^HyperStream fromList: fusedSubstreams
)
reactivelyFuse: cells with: fcells <HyperStream[Cell[S def]]> ^ <Hyperstream[Cell[{T.S}]]> = ( 
     cells isKindOfScalarHyperStream ifTrue: [
        fcells isKindOfScalarHyperStream ifTrue: [^fuseScalar: cells withScalar: fcells].
        fcells isKindOfUnboundedHyperStream 
           ifTrue: [^fuseUnbounded: fcells withScalar: cells].
        ^fuseBounded: fcells withScalar: cells
     ] ifFalse: [
          cells isKindOfUnboundedHyperStream ifTrue: [
                  fcells isKindOfScalarHyperStream ifTrue: [^fuseUnbounded: cells withScalar: fcells].
                  ^reactivelyFuseUnbounded: cells with: fcells
          ].
          fcells isKindOfScalarHyperStream ifTrue: [^fuseBounded: cells withScalar: fcells].
          ^reactivelyFuseBounded: cells with: fcells  
          ]
)
) : (
)
) : (
)
