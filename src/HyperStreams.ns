Newspeak3
'Root'
class HyperStreams usingPlatform: p <Platform> = (
(*
A module for implementing hyperstreams. The implementation is kept as simple (naive) as possible.

A hyperstream is  either a scalar, or a stream whose elements are hyperstreams. A hyperstream has zero or more dimensions. The number of dimensions of a hyperstream is known as its rank. All elements of a hyperstream must have the same rank. Hyperstreams are represented by subclasses of AbstractHyperStream.

A scalar is itself a hyperstream,  known as a scalar hyperstream, which is represented by class ScalarHyperStream.  A scalar hyperstream has zero dimensions, and therefore has rank 0; otherwise, a hyperstream has 1 + k dimensions, where k is the rank of of its elements. Each dimension has a size, which may be known or unknown. If the size is unknown, it indicated by ?, which is represented by an instance of class UnboundedDimension; otherwise the size is a positive integer.

*)
  |
    (* imports *)
    private List = p collections List.
    
    (* export *)
    
    public HyperStream = HyperStreamFactory new.
  |
) (
class AbstractHyperStream rank: r <Integer> = (
  |
    output <OutputPort>
    window <List[HyperStream]>
    public rank <Integer> = r.
    public dimensions <List[Integer | UnboundedDimension]>
  |
) (
class Iterator = outer HyperStreams Iterator (
  |
  index <Integer> ::= 0.
  |
) (
public next ^ <T> = (
  hasNext ifTrue: [
    index:: index + 1.
    ^at: index
    ].
  Error signal: 'Attempt to access unavailable stream element' 
)
public hasNext ^ <Boolean> = (
  ^(index = window size) not.
)
public rank ^ <Integer> = (
  ^outer AbstractHyperStream rank
)
) : (
)
public addAll: es <List[T]> = (
  es do: [:e <T> | add: e]
)
public iterator ^ <Iterator[T]> = (
  ^Iterator new
)
public  asStream ^ <HyperStream> = (
  ^self
)
public add: e <T> = (
  window add: e
)
public isKindOfAbstractHyperStream ^ <Boolean> = (
  ^true
)
public select: f <[:T | Boolean]> ^ <Stream[T]> = (
  ^filter: f
)
public collect: f <[:T | R]>  ^ <Stream[R]> = (
  ^map: f
)
public isComplete: b <Boolean> = (
  subclassResponsibility
)
public take: n <Integer> ^ <Stream[T]> = (
  subclassResponsibility
)
public isBounded ^ <Boolean> = (
  subclassResponsibility
)
public map: f <[:T | R]>  ^ <Stream[R]> = (
  subclassResponsibility
)
public isComplete  ^ <Boolean> = (
  subclassResponsibility
)
public filter: f <[:T | Boolean]> ^ <Stream[T]> = (
  subclassResponsibility
)
) : (
fromArray: a <Array[T]> ^ <Instance> = (
  ^self new addAll: a; isComplete: true; yourself
)
)
class ConstantStream on: k  = AbstractHyperStream rank: 0 (
  |
  constant = k.
  |
) (
class Iterator = (
) (
public hasNext ^ <Boolean> = (
  ^true
)
public next ^ <T> = (
  ^constant
)
public rank ^ <Integer> = (
  ^0
)
) : (
)
public isComplete  ^ <Boolean> = (
  ^false (* Is this the right answer?*)
)
public add: e <T> = (
  Error signal: 'Attempt to add to a constant stream'
)
public map: f <[:T | R]>  ^ <Stream[R]> = (
  ^class on: (f value: constant)
)
public filter: f <[:T | Boolean]> ^ <Stream[T]> = (
  (f value: constant) ifTrue: [^self] ifFalse: [^EmptyStream].
)
public isComplete: b  <Boolean> = (
   (* Do nothing? *)
)
public take: n <Integer> ^ <Stream[T]> = (
  | l <List> = List new: n. |
  1 to: n do: [:i <Integer> | l add: constant].
  ^BoundedStream fromList: l dimensions: {}
)
) : (
)
public class BoundedHyperStream fromList: l <List[Stream[T]]> dimensions: ds <List[Integer | UnboundedDimension]> = AbstractHyperStream rank: ds size (
(* A hyperstream whose first dimension is a known integer.  The rank of a bounded hyperstream is always at least 1 - rank 0 cases are represented by ScalarHyperStream.
Hence, the window and dimensions are never empty, and the window elements elements are always hyperstreams, bottoming out as scalar hyperstreams.
*)
  window: l.
    dimensions: ds.
) (
public isBounded ^ <Boolean> = (
  ^true
)
public isKindOfBoundedHyperStream ^ <Boolean> = (
  ^true
)
public isComplete  ^ <Boolean> = (
  ^true
)
public at: i <Integer> ^ <T> = (
(* What if i is out of bounds? *)
  ^window at: i
)
public isComplete: b <Boolean> = (
  (*  do nothing, but check that no one tries to tell me I'm not complete *)
  assert: [b] message: 'Attempt to assert bunded stream is incomplete!'
)
public filter: f <[:T | Boolean]> ^ <Stream[T]> = (
  | dtail = dimensions copy from: 2 to: dimensions size. |
  ^class fromList: (window select: [:e <Stream[T]> | e filter: f]) dimensions: {UnboundedDimension new}, dtail 
)
public map: f <[:T | R]>  ^ <Stream[R]> = (
  ^class fromList: (window collect:  [:e <Stream[T]> | e map: f]) dimensions: dimensions
)
public take: n <Integer> ^ <Stream[T]> = (
  (* Need to protect against taking more than the window size *)
  assert: [n <= window size] message: 'Attempt to access a bounded stream past its end'.
  ^class fromList: (window copyFrom: 1 to: n) dimensions: dimensions
)
) : (
)
public class UnboundedHyperStream iteratingOver: i <Iterator> = AbstractHyperStream rank: i rank (
  |
  source <Iterator> = i.
    public isComplete ::= false.
  |
) (
public map: f <[:T | R]>  ^ <Stream[R]> = (
  ^class iteratingOver: (iterator map: f)
)
public take: n <Integer> ^ <Stream[T]> = (
  ^class iteratingOver: (iterator take: n)
)
public isKindOfUnboundedHyperStream ^ <Boolean> = (
  ^true
)
public filter: f <[:T | Boolean]> ^ <Stream[T]> = (
  ^class iteratingOver: (iterator filter: f)
)
public isBounded ^ <Boolean> = (
  ^false
)
) : (
)
public class HyperStreamFactory = (
) (
public  iteratingOver: i <Iterator>  ^ <UnboundedHyperStream> = (
   ^UnboundedHyperStream iteratingOver: i
)
public zipSynchronous: streams <List[Stream]> ^ <Stream> = (
  ^iteratingOver: (SynchronousZipIterator iterators: (streams collect: [:s | s iterator]))
)
public replicate: s <S> ^ <Stream[S]> = (
   s isScalar ifTrue: [^ConstantStream on: s].
   ^iteratingOver: s iterator
)
public zipReactive: streams <List[Stream]> ^ <Stream> = (
  ^iteratingOver: (ReactiveZipIterator zipping: (streams collect: [:s | s iterator]))
)
public fromList: l <List[T]> dimensions: ds <List[Integer | UnboundedDimension]> ^ <BoundedHyperSteam> = (
  ^BoundedHyperStream fromList: l dimensions: dimensions
)
repeat: s  dimension: d = (
   d isKindOfInteger ifTrue: [ 
     (* Bounded case *)
     | l = List new: d. | (* Replicate s d times *)
     1 to: d do: [:i | l add: (HyperStream iteratingOver: s iterator)].
     ^fromList: l dimensions: {}, s dimensions.
   ].
   (* Unbounded case *)
   ^iteratingOver: (ReplicatingIterator replicating: s by: d iterator)
)
public replicate: s  <Stream> dimensions: dims <List[Integer | UnboundedDimension]> ^ <HyperStream> = (
   (* Base case; we've stripped away all the dimensions, and just produce a copy of s *)
   dims isEmpty ifTrue: [^replicate: s].
   (* Recursively replicate for the tail of the dimesniosn, and replicate the result by the first dimension *)
   ^repeat: (replicate: s dimensions: (dims copyFrom: 2 to: dims size)) dimension: dims first
)
public fromScalar: o <Object> ^ <ConstantStream> = (
  ^ScalarHyperStream scalarValue: o
)
public empty ^ <HyperStream> = ( 
  ^EmptyHyperStream new
)
) : (
)
class MappedIterator mapping: f <[:T | R]> on: i <Iterator> =  DerivedIterator fromIterator: i (
  |
  function <[:T | R]> = f.
  |
) (
public next ^ <R> = (
  ^function value: iterator next
)
) : (
)
class DerivedIterator fromIterator: i <Iterator> =  Iterator (
  |
  iterator <Iterator>
  |
) (
public hasNext ^ <Boolean> = (
  ^iterator hasNext
)
public rank ^ <Integer> = (
  ^iterator rank
)
) : (
)
class Iterator = (
) (
public hasNext ^ <Boolean> = (
  ^subclassResponsibility
)
public next ^ <T> = (
  ^subclassResponsibility
)
public map: f = (
  ^MappedIterator mapping: f on: self
)
public filter: f <[:T | Boolean]>  = (
  ^FilteredIterator filtering: f on: self
)
public rank ^ <Integer> = (
  ^subclassResponsibility
)
) : (
)
class FilteredIterator mapping: f <[:T | Boolean]> on: i <Iterator> =  DerivedIterator fromIterator: i (
  |
  function <[:T | Boolean]> = f.
    peek <T | Nil>
  |
) (
lookahead = (
  | nextItem <T | Nil> nextIsValid <Boolean>  |
  [iterator hasNext ifTrue: [nextIsValid:: (function value: (nextItem: iterator next))] ifFalse: [true]] whileFalse: [].
  ^nextIsValid ifTrue: [nextItem] ifFalse: [nil].
)
public hasNext ^ <boolean>  = (
   (* We're working on a stream, so even if we had nothing before, we might have something now. *)
   ^peek isNil not or: [peek:: lookahead. peek isNil not]
)
public next ^ <T> = (
(* Iffy. Only works if we assume somone has called hasNext just before calling next. 
   We should probably call hasNext here.  
*)
 | result = peek. |
 peek isNil ifTrue: [Error signal].
 peek:: lookahead.
  ^result
)
) : (
)
class ReactiveZipIterator zipping: iters <List[Iterator[T]]> = Iterator (
  |
  iterators <List[Iterator]> = iters.
  |
) (
public hasNext ^ <Boolean> = (
  ^iterators anySatisfy: [:iter <Iterator[T]> | iter hasNext].
)
public next ^ <List[T]> = (
  | result <List[T]> = List new: iterators size. |
  iterators do: [:iter <iterator[T]> |
     result add: (iter hasNext 
       ifTrue: [iter next]
       (* Not quite. First time? also last not defined yet *)
       ifFalse: [iter last]
    )
  ].
  ^result
)
public rank ^ <Integer> = (
  ^iterators first rank
)
) : (
)
class SynchronousZipIterator zipping: iters <List[Iterator]> = Iterator (
  |
  iterators <List[Iterator]> = iters.
  |
) (
public hasNext ^ <Boolean> = (
  ^iterators allSatisfy: [:iter <Iterator[T]> | iter hasNext].
)
public next ^ <List[T]> = (
  ^iterators collect: [:iter <Iterator[T]> | iter next ]
)
public rank ^ <Integer> = (
  ^iterators first rank
)
) : (
)
class ReplicatingIterator replicating: v by: i = DerivedIterator fromIterator: i (
  |
  replicated = v.
  |
) (
public rank ^ <Integer> = (
  ^iterator rank + 1
)
public next = (
  iterator next.
  v isKindOfAbstractHyperStream ifTrue: [^v iterator].
  ^v
)
) : (
)
public class UnboundedDimension = (
  (* The magic object representing an unbounded dimension of a hyperstream *)
) (
public = other ^ <Boolean> = (
  ^other isKindOfUnboundedDimension
)
public hash ^ <Integer> = (
  ^class hash
)
public isKindOfUnboundedDimension ^ <Boolean> = (
  ^true
)
) : (
)
class ScalarHyperStream scalarValue: s =  AbstractHyperStream rank: 0 (
  |
  constant = s.
  |
    window:: List new withAll: {s}.
    dimensions:: List new.
) (
public add: e <T> = (
  Error signal: 'Cannot add elements to a scalar stream'
)
public map: f <[:T | R]>  ^ <ScalarHyperStream[R]> = (
  ^class scalarValue: (f value: constant)
)
public take: n <Integer> ^ <Stream[T]> = (
  assert: [n < 2] message: 'Attempt to access more than one leement of a scalr stream'.
  ^self
)
public filter: f <[:T | Boolean]> ^ <Stream[T]> = (
  ^(f value: constant) ifTrue: [self] ifFalse: [HyperStream empty]
)
public isBounded ^ <Boolean> = (
  ^true
)
public isComplete ^ <Boolean> = (
  ^true
)
public isComplete: b <Boolean> = (
  (*  do nothing, but check that no one tries to tell me I'm not complete *)
  assert: [b] message: 'Attempt to assert bunded stream is incomplete!'
)
public isKindOfScalarHyperStream ^ <Boolean> = (
  ^true
)
public isScalar ^ <Boolean> = (
  ^true
)
) : (
)
class EmptyHyperStream = AbstractHyperStream rank: 0(

) (
public isBounded ^ <Boolean> = (
  ^true
)
public isComplete ^ <Boolean> = (
  ^true
)
public isComplete: b <Boolean> = (
  (*  do nothing, but check that no one tries to tell me I'm not complete *)
  assert: [b] message: 'Attempt to assert bunded stream is incomplete!'
)
public isKindOfEmptyHyperStream ^ <Boolean> = (
  ^true
)
) : (
)
) : (
)
