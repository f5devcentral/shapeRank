Newspeak3
'Root'
class HyperStreams usingPlatform: p <Platform> = (
(*
A module for implementing hyperstreams. The implementation is kept as simple (naive) as possible.

A hyperstream is  either a scalar, or a stream whose elements are hyperstreams. A hyperstream has zero or more dimensions. The number of dimensions of a hyperstream is known as its rank. All elements of a hyperstream must have the same rank. Hyperstreams are represented by subclasses of HyperStream.

A scalar is itself a hyperstream,  known as a scalar hyperstream, which is represented by class ScalarHyperStream.  A scalar hyperstream has zero dimensions, and therefore has rank 0; otherwise, a hyperstream has 1 + k dimensions, where k is the rank of of its elements. Each dimension has a size, which may be known or unknown. If the size is unknown, it indicated by ?, which is represented by an instance of class UnboundedDimension; otherwise the size is a positive integer.

*)
  |
    (* imports *)
    private List = p collections List.    
  |
) (
public class HyperStream rank: r <Integer> = (
(* The abstract class at the root of the hyperstream hierarchy.  A hyperstream contains elements of some type T. *)
  |
    output <OutputPort>
    window <List[HyperStream[T]]>
    public rank <Integer> = r.
    public dimensions <List[Integer | UnboundedDimension]>
  |
) (
class Iterator = outer HyperStreams Iterator (
  |
  index <Integer> ::= 0.
  |
) (
public next ^ <T> = (
  hasNext ifTrue: [
    index:: index + 1.
    ^at: index
    ].
  Error signal: 'Attempt to access unavailable stream element' 
)
public hasNext ^ <Boolean> = (
  ^(index = window size) not.
)
public rank ^ <Integer> = (
  ^outer HyperStream rank
)
) : (
)
public iterator ^ <Iterator[T]> = (
  ^Iterator new
)
public isKindOfHyperStream ^ <Boolean> = (
  ^true
)
public isComplete: b <Boolean> = (
  subclassResponsibility
)
public isBounded ^ <Boolean> = (
  subclassResponsibility
)
public isComplete  ^ <Boolean> = (
  subclassResponsibility
)
public clone = (
  subclassResponsibility
)
public  asStream ^ <HyperStream[T]> = (
  ^self
)
public map: f <[:T | R]>  ^ <HyperStream[R]> = (
  subclassResponsibility
)
public filter: f <[:T | Boolean]> ^ <HyperStream[T]> = (
  subclassResponsibility
)
public take: n <Integer> ^ <HyperStream[T]> = (
  subclassResponsibility
)
) : (
public  iteratingOver: i <Iterator>  ^ <UnboundedHyperStream> = (
   ^UnboundedHyperStream iteratingOver: i
)
public zipReactive: streams <List[HyperStream]> ^ <HyperStream[List]> = (
  ^iteratingOver: (ReactiveZipIterator zipping: (streams collect: [:s <HyperStream> | s iterator]))
)
public replicate: s <HyperStream[S def]> ^ <HyperStream[S]> = (
   s isScalar ifTrue: [^ScalarHyperStream on: s contents].
   ^iteratingOver: s iterator (* oops, some iterators are stateful, need to clone *)
)
public replicate: s  <HyperStream[T def]> dimensions: dims <List[Integer | UnboundedDimension]> ^ <HyperStream[T]> = (
   (* Base case; we've stripped away all the dimensions, and just produce a copy of s *)
   dims isEmpty ifTrue: [^replicate: s].
   (* Recursively replicate for the tail of the dimensions, and replicate the result by the first dimension *)
   ^repeat: (replicate: s dimensions: (dims copyFrom: 2 to: dims size)) dimension: dims first
)
public fromList: l <List[HyperStream[T def]]> dimensions: ds <List[Integer | UnboundedDimension]> ^ <BoundedHyperSteam[T]> = (
  ^BoundedHyperStream fromList: l dimensions: dimensions
)
public zipSynchronous: streams <List[HyperStream]> ^ <HyperStream[List]> = (
  ^iteratingOver: (SynchronousZipIterator iterators: (streams collect: [:s <HyperStream> | s iterator]))
)
repeat: s  <HyperStream[T def]> dimension: d <Integer | UnboundedDimension> ^ <HyperStream[T]> = (
   d isKindOfInteger ifTrue: [ 
     (* Bounded case *)
     | l <List[HyperStream[T]]> = List new: d. | (* Replicate s d times *)
     1 to: d do: [:i <Integer> | l add: (HyperStream iteratingOver: s iterator)]. (* what if substrems are bounded? *)
     ^fromList: l dimensions: {}, s dimensions.
   ].
   (* Unbounded case *)
   ^iteratingOver: (ReplicatingIterator replicating: s by: d iterator) (* d has an iterator? *)
)
public fromScalar: o <T def> ^ <ScalarHyperStream[T]> = (
  ^ScalarHyperStream scalarValue: o
)
public empty ^ <EmptyHyperStream> = ( 
  ^EmptyHyperStream new
)
)
class ConstantStream on: k  dimension: ds <List[Integer | UnboundedDimension]> = HyperStream rank: ds size (
(* A hyperstream , all of whose elements are equal to some constant  *)
  |
  constant = k.
  |
  dimensions:: ds.
) (
class Iterator = (
) (
public hasNext ^ <Boolean> = (
  ^true
)
public next ^ <T> = (
  ^constant
)
public rank ^ <Integer> = (
  ^0
)
) : (
)
public isComplete  ^ <Boolean> = (
  ^false (* Is this the right answer?*)
)
public add: e <T> = (
  Error signal: 'Attempt to add to a constant stream'
)
public filter: f <[:T | Boolean]> ^ <Stream[T]> = (
  (f value: constant) ifTrue: [^self] ifFalse: [^EmptyStream].
)
public isComplete: b  <Boolean> = (
   (* Do nothing? *)
)
public take: n <Integer> ^ <Stream[T]> = (
  | l <List> = List new: n. |
  1 to: n do: [:i <Integer> | l add: constant].
  ^BoundedStream fromList: l dimensions: {}
)
public clone = (
)
public map: f <[:T | R]>  ^ <Stream[R]> = (
  ^class on: (f value: constant)
)
) : (
)
public class BoundedHyperStream fromList: l <List[HyperStream[T]]> dimensions: ds <List[Integer | UnboundedDimension]> = HyperStream rank: ds size (
(* A hyperstream whose first dimension is a known integer.  The rank of a bounded hyperstream is always at least 1; rank 0 cases are represented by ScalarHyperStream.
Hence, the window and dimensions are never empty, and the window elements elements are always hyperstreams, bottoming out as scalar hyperstreams.
*)
  window: l.
  dimensions: ds.
) (
public isBounded ^ <Boolean> = (
  ^true
)
public isKindOfBoundedHyperStream ^ <Boolean> = (
  ^true
)
public isComplete  ^ <Boolean> = (
  ^true
)
public at: i <Integer> ^ <T> = (
(* What if i is out of bounds? *)
  ^window at: i
)
public isComplete: b <Boolean> = (
  (*  do nothing, but check that no one tries to tell me I'm not complete *)
  assert: [b] message: 'Attempt to assert bunded stream is incomplete!'
)
public take: n <Integer> ^ <Stream[T]> = (
  (* Need to protect against taking more than the window size *)
  assert: [n <= window size] message: 'Attempt to access a bounded stream past its end'.
  ^class fromList: (window copyFrom: 1 to: n) dimensions: dimensions
)
public map: f <[:T | R]>  ^ <HyperStream[R]> = (
  ^class fromList: (window collect:  [:e <HyperStream[T]> | e map: f]) dimensions: dimensions
)
public filter: f <[:T | Boolean]> ^ <BoundedHyperStream[T]> = (
  | dtail = dimensions copy from: 2 to: dimensions size. |
  ^class fromList: (window select: [:e <HyperStream[T]> | e filter: f]) dimensions: {UnboundedDimension new}, dtail 
)
public clone  = (
  ^class fromList: window dimensions: dimensions
)
) : (
)
public class UnboundedHyperStream iteratingOver: i <Iterator> = HyperStream rank: i rank (
  |
  source <Iterator> = i.
  public isComplete ::= false.
  |
) (
public isKindOfUnboundedHyperStream ^ <Boolean> = (
  ^true
)
public isBounded ^ <Boolean> = (
  ^false
)
public map: f <[:T | R]>  ^ <HyperStream[R]> = (
  ^class iteratingOver: (iterator map:  [:e <HyperStream[T]> | e map: f]) dimensions: dimensions 
)
public filter: f <[:T | Boolean]> ^ <BoundedHyperStream[T]> = (
  ^class iteratingOver: (iterator map: [:e <HyperStream[T]> | e filter: f]) dimensions: dimensions 
)
public take: n <Integer> ^ <HyperStream[T]> = (
  ^class iteratingOver: (iterator take: n)
)
public clone = (
  ^class iteratingOver: source clone
)
) : (
)
class MappedIterator mapping: f <[:T | R]> on: i <Iterator> =  DerivedIterator fromIterator: i (
  |
  function <[:T | R]> = f.
  |
) (
public next ^ <R> = (
  ^function value: iterator next
)
public clone = (
  ^class mapping: function on: iterator clone
)
) : (
)
class DerivedIterator fromIterator: i <Iterator> =  Iterator (
  |
  iterator <Iterator>
  |
) (
public hasNext ^ <Boolean> = (
  ^iterator hasNext
)
public rank ^ <Integer> = (
  ^iterator rank
)
) : (
)
class Iterator = (
) (
public hasNext ^ <Boolean> = (
  ^subclassResponsibility
)
public next ^ <T> = (
  ^subclassResponsibility
)
public map: f = (
  ^MappedIterator mapping: f on: self
)
public filter: f <[:T | Boolean]>  = (
  ^FilteredIterator filtering: f on: self
)
public rank ^ <Integer> = (
  ^subclassResponsibility
)
public clone = (
  self subclassResponsibility
)
) : (
)
class FilteredIterator mapping: f <[:T | Boolean]> on: i <Iterator> =  DerivedIterator fromIterator: i (
  |
  function <[:T | Boolean]> = f.
  peek <T | Nil>
  |
) (
lookahead = (
  | nextItem <T | Nil> nextIsValid <Boolean>  |
  [iterator hasNext ifTrue: [nextIsValid:: (function value: (nextItem: iterator next))] ifFalse: [true]] whileFalse: [].
  ^nextIsValid ifTrue: [nextItem] ifFalse: [nil].
)
public hasNext ^ <boolean>  = (
   (* We're working on a stream, so even if we had nothing before, we might have something now. *)
   ^peek isNil not or: [peek:: lookahead. peek isNil not]
)
public next ^ <T> = (
(* Iffy. Only works if we assume someone has called hasNext just before calling next. 
   We should probably call hasNext here.  
*)
 | result = peek. |
 peek isNil ifTrue: [Error signal].
 peek:: lookahead.
  ^result
)
public clone = (
  ^class mapping: function on: iterator clone
)
) : (
)
class ReactiveZipIterator zipping: iters <List[Iterator]> = Iterator (
(*
Iterator for reactive function calls. Takes a list of iterators on the arguments, and produces an iterator for their zipped values. If any argument has a vaue ready, produce a list of zipped values. Iterators that do not have a next value re-use their previous values, which are kept in the lastValues slot. Of course, this can't work the first time  the iterator is called, since there are no "previous values".  This is a special case, tracked by the firstTime slot.
*)
  |
  iterators <List[Iterator]> = iters.
  firstTime <Boolean> ::= true.
  lastValues <List> = List new: iterators size.
  |
) (
public rank ^ <Integer> = (
  ^iterators first rank
)
first ^ <List> = (
(* Produce  the first value of the iterator.  This is a special case, as noted in the class comment.*)
  iterators do: [:iter <Iterator> |
     (* initially populate lastValues *)  
     lastValues add: (iter hasNext 
       ifTrue: [iter next]
       (* We require that hasNext was call before calling this method, which will ensure that all iter hasNext is true for all iterators. Hence, if it is not the case, we have an error.*)
       ifFalse: [Error signal: 'Called iterator next without verifying if hasNext is true']
    )
  ].
  (* Ok, we are past the first time now *)
  firstTime:: false.
  (* Our results are in lastValues, but we do not want to expose that, so we copy *)
  ^lastValues copyFrom: 1 to: iterators size
)
public hasNext ^ <Boolean> = (
  (* First call is a special case, per class comment. We need initial values for all iterators. *)
  firstTime ifTrue: [^iterators allSatisfy: [:iter <Iterator> | iter hasNext]].
  (* normal case - as long as any iterator has a new value, we are ok. *)
  ^iterators anySatisfy: [:iter <Iterator[T]> | iter hasNext].
)
public next ^ <List> = (
  | result <List> = List new: iterators size. |
  firstTime ifTrue: [^first].
  assert: [hasNext] message: 'Called iterator next without verifying if hasNext is true'.
  (* We require that hasNext was call before calling this method. If it is not the case, we have an error.*)  
  iterators with: lastValues do: [:iter <Iterator> :last <Object> |
     result add: (iter hasNext 
       ifTrue: [iter next]
       ifFalse: [last]
    )
  ].
  ^result
)
public clone = (
  ^class zipping: (iterators collect: [:i <iterator> | i clone])
)
) : (
)
class SynchronousZipIterator zipping: iters <List[Iterator]> = Iterator (
  |
  iterators <List[Iterator]> = iters.
  |
) (
public hasNext ^ <Boolean> = (
  ^iterators allSatisfy: [:iter <Iterator[T]> | iter hasNext].
)
public next ^ <List[T]> = (
  ^iterators collect: [:iter <Iterator[T]> | iter next ]
)
public rank ^ <Integer> = (
  ^iterators first rank
)
public clone = (
  ^class zipping: (iterators collect: [:i <iterator> | i clone])
)
) : (
)
class ReplicatingIterator replicating: s <HyperStream[T def]> by: i <Iterator> = DerivedIterator fromIterator: i (
(* Replicate stream s once per element of i *)
  |
  replicated <HyperStream[T]> = s.
  |
) (
public rank ^ <Integer> = (
  ^iterator rank + 1
)
public next ^ <HyperStream[T]> = (
  iterator next.
  ^replicated
)
public clone = (
  ^class replicating: replicated clone by: iterator clone
)
) : (
)
public class UnboundedDimension = (
  (* The magic object representing an unbounded dimension of a hyperstream *)
) (
public = other ^ <Boolean> = (
  ^other isKindOfUnboundedDimension
)
public hash ^ <Integer> = (
  ^class hash
)
public isKindOfUnboundedDimension ^ <Boolean> = (
  ^true
)
) : (
)
class ScalarHyperStream scalarValue: s =  HyperStream rank: 0 (
  |
  constant = s.
  |
    window:: List new withAll: {s}.
    dimensions:: List new.
) (
public add: e <T> = (
  Error signal: 'Cannot add elements to a scalar stream'
)
public filter: f <[:T | Boolean]> ^ <Stream[T]> = (
  ^(f value: constant) ifTrue: [self] ifFalse: [HyperStream empty]
)
public isBounded ^ <Boolean> = (
  ^true
)
public isComplete ^ <Boolean> = (
  ^true
)
public isComplete: b <Boolean> = (
  (*  do nothing, but check that no one tries to tell me I'm not complete *)
  assert: [b] message: 'Attempt to assert bunded stream is incomplete!'
)
public isKindOfScalarHyperStream ^ <Boolean> = (
  ^true
)
public isScalar ^ <Boolean> = (
  ^true
)
public take: n <Integer> ^ <Stream[T]> = (
  assert: [n < 2] message: 'Attempt to access more than one element of a scalr stream'.
  ^self
)
public clone = (
 ^class scalarValue: constant
)
public map: f <[:T | R]>  ^ <ScalarHyperStream[R]> = (
  ^class scalarValue: (f value: constant)
)
) : (
)
class EmptyHyperStream = HyperStream rank: 0(

) (
public isBounded ^ <Boolean> = (
  ^true
)
public isComplete ^ <Boolean> = (
  ^true
)
public isComplete: b <Boolean> = (
  (*  do nothing, but check that no one tries to tell me I'm not complete *)
  assert: [b] message: 'Attempt to assert bunded stream is incomplete!'
)
public isKindOfEmptyHyperStream ^ <Boolean> = (
  ^true
)
public add: e <T> = (
  Error signal: 'Cannot add elements to an empty stream'
)
public filter: f <[:T | Boolean]> ^ <Stream[T]> = (
)
public take: n <Integer> ^ <Stream[T]> = (
  assert: [n = 0] message: 'Attempt to element(s) of an empty stream'.
  ^self
)
public map: f <[:T | R]>  ^ <EmptyHyperStream[R]> = (
)
public clone = (
)
) : (
)
) : (
)
