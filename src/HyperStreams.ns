Newspeak3
'Root'
class HyperStreams usingPlatform: p <Platform> = (
(*
A module for implementing hyperstreams. The implementation is kept as simple (naive) as possible.

A hyperstream is  either a scalar, or a stream whose elements are hyperstreams. A hyperstream has zero or more dimensions. The number of dimensions of a hyperstream is known as its rank. All elements of a hyperstream must have the same rank. Hyperstreams are represented by subclasses of HyperStream.

A scalar is itself a hyperstream,  known as a scalar hyperstream, which is represented by class ScalarHyperStream.  A scalar hyperstream has zero dimensions, and therefore has rank 0; otherwise, a hyperstream has 1 + k dimensions, where k is the rank of of its elements. Each dimension has a size, which may be known or unknown. If the size is unknown, it indicated by ?, which is represented by an instance of class UnboundedDimension; otherwise the size is a positive integer.

*)
  |
    (* imports *)
    private List = p collections List.    
  |
) (
public class HyperStream rank: r <Integer> = (
(* The abstract class at the root of the hyperstream hierarchy.  A hyperstream contains elements of some type T. *)
  |
    output <OutputPort>
    window <List[HyperStream[T]]>
    public rank <Integer> = r.
    public dimensions <List[Integer | UnboundedDimension]>
  |
) (
public isKindOfHyperStream ^ <Boolean> = (
  ^true
)
public isComplete: b <Boolean> = (
  subclassResponsibility
)
public isBounded ^ <Boolean> = (
  subclassResponsibility
)
public isComplete  ^ <Boolean> = (
  subclassResponsibility
)
public clone = (
  subclassResponsibility
)
public  asStream ^ <HyperStream[T]> = (
  ^self
)
public map: f <[:T | R]>  ^ <HyperStream[R]> = (
  subclassResponsibility
)
public filter: f <[:T | Boolean]> ^ <HyperStream[T]> = (
  subclassResponsibility
)
public take: n <Integer> ^ <HyperStream[T]> = (
  subclassResponsibility
)
public iterator ^ <Iterator[T | HyperStream[T]]> = (
  suclassResponsibility
)
) : (
public  iteratingOver: i <Iterator>  ^ <UnboundedHyperStream> = (
   ^UnboundedHyperStream iteratingOver: i
)
public zipReactive: streams <List[HyperStream]> ^ <HyperStream[List]> = (
  ^iteratingOver: (ReactiveZipIterator zipping: (streams collect: [:s <HyperStream> | s iterator]))
)
public fromList: l <List[HyperStream[T def]]> dimensions: ds <List[Integer | UnboundedDimension]> ^ <BoundedHyperSteam[T]> = (
  ^BoundedHyperStream fromList: l dimensions: dimensions
)
public zipSynchronous: streams <List[HyperStream]> ^ <HyperStream[List]> = (
  ^iteratingOver: (SynchronousZipIterator iterators: (streams collect: [:s <HyperStream> | s iterator]))
)
public fromScalar: o <T def> ^ <ScalarHyperStream[T]> = (
  ^ScalarHyperStream scalarValue: o
)
public empty ^ <EmptyHyperStream> = ( 
  ^EmptyHyperStream new
)
repeat: s  <HyperStream[T def]> dimension: d <Integer | UnboundedDimension> ^ <HyperStream[T]> = (
   d isKindOfInteger ifTrue: [ 
     (* Bounded case *)
     | l <List[HyperStream[T]]> = List new: d. | (* Replicate s d times *)
     1 to: d do: [:i <Integer> | l add: s clone].
     ^fromList: l dimensions: {}, s dimensions.
   ].
   (* Unbounded case *)
   ^iteratingOver: (ReplicatingIterator replicating: s by: d iterator) (* d has an iterator? *)
)
public replicate: s  <HyperStream[T def]> dimensions: dims <List[Integer | UnboundedDimension]> ^ <HyperStream[T]> = (
   (* Base case; we've stripped away all the dimensions, and just produce a copy of s *)
   dims isEmpty ifTrue: [^s clone].
   (* Recursively replicate for the tail of the dimensions, and replicate the result by the first dimension *)
   ^repeat: (replicate: s dimensions: (dims copyFrom: 2 to: dims size)) dimension: dims first
)
)
class ConstantStream on: k <T def> dimension: ds <List[Integer | UnboundedDimension]> = HyperStream rank: ds size (
(* A hyperstream , all of whose elements are equal to some constant  *)
  |
  constant <T> = k.
  |
  dimensions:: ds.
) (
class Iterator = outer HyperStreams Iterator (
) (
public hasNext ^ <Boolean> = (
  ^true
)
public next ^ <T> = (
  ^constant
)
public rank ^ <Integer> = (
  ^0
)
) : (
)
public isComplete  ^ <Boolean> = (
  ^false (* Is this the right answer?*)
)
public isComplete: b  <Boolean> = (
   (* Do nothing? *)
)
public clone = (
)
public take: n <Integer> ^ <HyperStream[T]> = (
  | l <List> = List new: n. |
  1 to: n do: [:i <Integer> | l add: constant].
  ^BoundedStream fromList: l dimensions: {}
)
public filter: f <[:T | Boolean]> ^ <HyperStream[T]> = (
  (f value: constant) ifTrue: [^self] ifFalse: [^EmptyStream].
)
public map: f <[:T | R]>  ^ <HyperStream[R]> = (
  ^class on: (f value: constant)
)
public iterator ^ <Iterator[T | HyperStream[T]]> = (
  ^Iterator new
)
) : (
)
public class BoundedHyperStream fromList: l <List[HyperStream[T]]> dimensions: ds <List[Integer | UnboundedDimension]> = HyperStream rank: ds size (
(* A hyperstream whose first dimension is a known integer.  The rank of a bounded hyperstream is always at least 1; rank 0 cases are represented by ScalarHyperStream.
Hence, the window and dimensions are never empty, and the window elements elements are always hyperstreams, bottoming out as scalar hyperstreams.
*)
| public iterator <Iterator[HyperStream[T]]> = Iterator new. |
  window: l.
  dimensions: ds.
) (
class Iterator = outer HyperStreams Iterator (
  |
  index <Integer> ::= 0.
  |
) (
public hasNext ^ <Boolean> = (
  ^(index = window size) not.
)
public rank ^ <Integer> = (
  ^outer BoundedHyperStream rank
)
public clone = (
  ^class new
)
public next ^ <HyperStream[T]> = (
  hasNext ifTrue: [
    index:: index + 1.
    ^window at: index
    ].
  Error signal: 'Attempt to access unavailable stream element' 
)
) : (
)
public isBounded ^ <Boolean> = (
  ^true
)
public isKindOfBoundedHyperStream ^ <Boolean> = (
  ^true
)
public isComplete  ^ <Boolean> = (
  ^true
)
public isComplete: b <Boolean> = (
  (*  do nothing, but check that no one tries to tell me I'm not complete *)
  assert: [b] message: 'Attempt to assert bunded stream is incomplete!'
)
public take: n <Integer> ^ <Stream[T]> = (
  (* Need to protect against taking more than the window size *)
  assert: [n <= window size] message: 'Attempt to access a bounded stream past its end'.
  ^class fromList: (window copyFrom: 1 to: n) dimensions: dimensions
)
public map: f <[:T | R]>  ^ <HyperStream[R]> = (
  ^class fromList: (window collect:  [:e <HyperStream[T]> | e map: f]) dimensions: dimensions
)
public filter: f <[:T | Boolean]> ^ <BoundedHyperStream[T]> = (
  | dtail = dimensions copy from: 2 to: dimensions size. |
  ^class fromList: (window select: [:e <HyperStream[T]> | e filter: f]) dimensions: {UnboundedDimension new}, dtail 
)
public clone  = (
  ^class fromList: window dimensions: dimensions
)
) : (
)
public class UnboundedHyperStream iteratingOver: i <Iterator[HyperStream[T def]]> = HyperStream rank: i rank (
  |
  iterator <Iterator[HyperStream[T]]> = i.
  public isComplete <Boolean> ::= false.
  |
) (
public isKindOfUnboundedHyperStream ^ <Boolean> = (
  ^true
)
public isBounded ^ <Boolean> = (
  ^false
)
public map: f <[:T | R]>  ^ <HyperStream[R]> = (
  ^class iteratingOver: (iterator map:  [:e <HyperStream[T]> | e map: f]) dimensions: dimensions 
)
public filter: f <[:T | Boolean]> ^ <BoundedHyperStream[T]> = (
  ^class iteratingOver: (iterator map: [:e <HyperStream[T]> | e filter: f]) dimensions: dimensions 
)
public take: n <Integer> ^ <HyperStream[T]> = (
  ^class iteratingOver: (iterator take: n)
)
public clone = (
  ^class iteratingOver: iterator clone
)
) : (
)
class MappedIterator mapping: f <[:T | R]> on: i <Iterator> =  DerivedIterator fromIterator: i (
  |
  function <[:T | R]> = f.
  |
) (
public next ^ <R> = (
  ^function value: iterator next
)
public clone = (
  ^class mapping: function on: iterator clone
)
) : (
)
class DerivedIterator fromIterator: i <Iterator[T def]> =  Iterator (
  |
  iterator <Iterator[T]>
  |
) (
public hasNext ^ <Boolean> = (
  ^iterator hasNext
)
public rank ^ <Integer> = (
  ^iterator rank
)
) : (
)
class Iterator = (
  (* Abstract class at root of the iterator hierarchy for hyperstreams.  An iterator is a one dimensional sequence of elements of a type T.  In this module, they serve to represent a stream of hyperstreams that underlies a[n unbounded] hyperstream, and so T is usually HyperStream[S] for some S.*)
) (
public hasNext ^ <Boolean> = (
  ^subclassResponsibility
)
public next ^ <T> = (
  ^subclassResponsibility
)
public filter: f <[:T | Boolean]>  = (
  ^FilteredIterator filtering: f on: self
)
public rank ^ <Integer> = (
  ^subclassResponsibility
)
public clone = (
  self subclassResponsibility
)
public map: f <[:T | R]> = (
  ^MappedIterator mapping: f on: self
)
) : (
)
class FilteredIterator mapping: f <[:T | Boolean]> on: i <Iterator> =  DerivedIterator fromIterator: i (
  |
  function <[:T | Boolean]> = f.
  peek <T | Nil>
  |
) (
lookahead = (
  | nextItem <T | Nil> nextIsValid <Boolean>  |
  [iterator hasNext ifTrue: [nextIsValid:: (function value: (nextItem: iterator next))] ifFalse: [true]] whileFalse: [].
  ^nextIsValid ifTrue: [nextItem] ifFalse: [nil].
)
public hasNext ^ <boolean>  = (
   (* We're working on a stream, so even if we had nothing before, we might have something now. *)
   ^peek isNil not or: [peek:: lookahead. peek isNil not]
)
public next ^ <T> = (
(* Iffy. Only works if we assume someone has called hasNext just before calling next. 
   We should probably call hasNext here.  
*)
 | result = peek. |
 peek isNil ifTrue: [Error signal].
 peek:: lookahead.
  ^result
)
public clone = (
  ^class mapping: function on: iterator clone
)
) : (
)
class ReactiveZipIterator zipping: iters <List[Iterator]> = Iterator (
(*
Iterator for reactive function calls. Takes a list of iterators on the arguments, and produces an iterator for their zipped values. If any argument has a vaue ready, produce a list of zipped values. Iterators that do not have a next value re-use their previous values, which are kept in the lastValues slot. Of course, this can't work the first time  the iterator is called, since there are no "previous values".  This is a special case, tracked by the firstTime slot.
*)
  |
  iterators <List[Iterator]> = iters.
  firstTime <Boolean> ::= true.
  lastValues <List> = List new: iterators size.
  |
) (
public rank ^ <Integer> = (
  ^iterators first rank
)
first ^ <List> = (
(* Produce  the first value of the iterator.  This is a special case, as noted in the class comment.*)
  iterators do: [:iter <Iterator> |
     (* initially populate lastValues *)  
     lastValues add: (iter hasNext 
       ifTrue: [iter next]
       (* We require that hasNext was call before calling this method, which will ensure that all iter hasNext is true for all iterators. Hence, if it is not the case, we have an error.*)
       ifFalse: [Error signal: 'Called iterator next without verifying if hasNext is true']
    )
  ].
  (* Ok, we are past the first time now *)
  firstTime:: false.
  (* Our results are in lastValues, but we do not want to expose that, so we copy *)
  ^lastValues copyFrom: 1 to: iterators size
)
public hasNext ^ <Boolean> = (
  (* First call is a special case, per class comment. We need initial values for all iterators. *)
  firstTime ifTrue: [^iterators allSatisfy: [:iter <Iterator> | iter hasNext]].
  (* normal case - as long as any iterator has a new value, we are ok. *)
  ^iterators anySatisfy: [:iter <Iterator[T]> | iter hasNext].
)
public next ^ <List> = (
  | result <List> = List new: iterators size. |
  firstTime ifTrue: [^first].
  assert: [hasNext] message: 'Called iterator next without verifying if hasNext is true'.
  (* We require that hasNext was call before calling this method. If it is not the case, we have an error.*)  
  iterators with: lastValues do: [:iter <Iterator> :last <Object> |
     result add: (iter hasNext 
       ifTrue: [iter next]
       ifFalse: [last]
    )
  ].
  ^result
)
public clone = (
  ^class zipping: (iterators collect: [:i <iterator> | i clone])
)
) : (
)
class SynchronousZipIterator zipping: iters <List[Iterator]> = Iterator (
  |
  iterators <List[Iterator]> = iters.
  |
) (
public hasNext ^ <Boolean> = (
  ^iterators allSatisfy: [:iter <Iterator[T]> | iter hasNext].
)
public next ^ <List[T]> = (
  ^iterators collect: [:iter <Iterator[T]> | iter next ]
)
public rank ^ <Integer> = (
  ^iterators first rank
)
public clone = (
  ^class zipping: (iterators collect: [:i <iterator> | i clone])
)
) : (
)
class ReplicatingIterator replicating: s <HyperStream[T def]> by: i <Iterator> = DerivedIterator fromIterator: i (
(* Replicate stream s once per element of i *)
  |
  replicated <HyperStream[T]> = s.
  |
) (
public rank ^ <Integer> = (
  ^iterator rank + 1
)
public next ^ <HyperStream[T]> = (
  iterator next.
  ^replicated
)
public clone = (
  ^class replicating: replicated clone by: iterator clone
)
) : (
)
public class UnboundedDimension = (
  (* The magic object representing an unbounded dimension of a hyperstream *)
) (
public = other ^ <Boolean> = (
  ^other isKindOfUnboundedDimension
)
public hash ^ <Integer> = (
  ^class hash
)
public isKindOfUnboundedDimension ^ <Boolean> = (
  ^true
)
) : (
)
class ScalarHyperStream scalarValue: s =  HyperStream rank: 0 (
  |
  constant = s.
  iterator <Iterator[T]> = Iterator new.
  |
    window:: List new withAll: {s}.
    dimensions:: List new.
) (
class Iterator = outer HyperStreams Iterator (
  | accessed <Boolean> ::= false. |
) (
public hasNext ^ <Boolean> = (
  ^accessed
)
public next ^ <T> = (
  ^accessed ifFalse: [accessed:: true. constant] ifTrue: [Error signal: 'scalar iterator exhausted']
)
public clone = (
  ^class new
)
public rank ^ <Integer> = (
  ^0
)
) : (
)
public filter: f <[:T | Boolean]> ^ <Stream[T]> = (
  ^(f value: constant) ifTrue: [self] ifFalse: [HyperStream empty]
)
public isBounded ^ <Boolean> = (
  ^true
)
public isComplete ^ <Boolean> = (
  ^true
)
public isComplete: b <Boolean> = (
  (*  do nothing, but check that no one tries to tell me I'm not complete *)
  assert: [b] message: 'Attempt to assert bunded stream is incomplete!'
)
public isKindOfScalarHyperStream ^ <Boolean> = (
  ^true
)
public isScalar ^ <Boolean> = (
  ^true
)
public take: n <Integer> ^ <Stream[T]> = (
  assert: [n < 2] message: 'Attempt to access more than one element of a scalr stream'.
  ^self
)
public clone = (
 ^class scalarValue: constant
)
public map: f <[:T | R]>  ^ <ScalarHyperStream[R]> = (
  ^class scalarValue: (f value: constant)
)
) : (
)
class EmptyHyperStream = HyperStream rank: 0(

) (
public isBounded ^ <Boolean> = (
  ^true
)
public isComplete ^ <Boolean> = (
  ^true
)
public isComplete: b <Boolean> = (
  (*  do nothing, but check that no one tries to tell me I'm not complete *)
  assert: [b] message: 'Attempt to assert bunded stream is incomplete!'
)
public isKindOfEmptyHyperStream ^ <Boolean> = (
  ^true
)
public add: e <T> = (
  Error signal: 'Cannot add elements to an empty stream'
)
public filter: f <[:T | Boolean]> ^ <Stream[T]> = (
)
public take: n <Integer> ^ <Stream[T]> = (
  assert: [n = 0] message: 'Attempt to element(s) of an empty stream'.
  ^self
)
public map: f <[:T | R]>  ^ <EmptyHyperStream[R]> = (
)
public clone = (
)
public iterator ^ <Iterator[T | HyperStream[T]]> = (
  ^EmptyIterator new
)
) : (
)
class EmptyIterator = Iterator (
) (
public hasNext ^ <Boolean> = (
  ^false
)
public rank ^ <Integer> = (
  ^0
)
public clone = (
)
) : (
)
) : (
)
