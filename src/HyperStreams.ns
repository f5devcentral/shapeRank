Newspeak3
'Root'
class HyperStreams usingPlatform: p <Platform> = (
(*
A module for implementing hyperstreams. The implementation is kept as simple (naive) as possible.

A hyperstream is  either a scalar, or a stream whose elements are hyperstreams. A hyperstream has zero or more dimensions. The number of dimensions of a hyperstream is known as its rank. All elements of a hyperstream must have the same rank. Hyperstreams are represented by subclasses of AbstractHyperStream.

A scalar is itself a hyperstream,  known as a scalar hyperstream, which is represented by class ScalarHyperStream.  A scalar hyperstream has zero dimensions, and therefore has rank 0; otherwise, a hyperstream has 1 + k dimensions, where k is the rank of of its elements. Each dimension has a size, which may be known or unknown. If the size is unknown, it indicated by ?, which is represented by an instance of class UnboundedDimension; otherwise the size is a positive integer.

*)
  |
    (* imports *)
    private List = p collections List.
    
    (* export *)
    
    public HyperStream = HyperStreamFactory new.
  |
) (
class AbstractHyperStream rank: r <Integer> = (
  |
    output <OutputPort>
    window <List[HyperStream]>
    public rank <Integer> = r.
    public dimensions <List[Integer | UnboundedDimension]>
  |
) (
class Iterator = outer HyperStreams Iterator (
  |
  index <Integer> ::= 0.
  |
) (
public next ^ <T> = (
  hasNext ifTrue: [
    index:: index + 1.
    ^at: index
    ].
  Error signal: 'Attempt to access unavailable stream element' 
)
public hasNext ^ <Boolean> = (
  ^(index = window size) not.
)
public rank ^ <Integer> = (
  ^outer AbstractHyperStream rank
)
) : (
)
public addAll: es <List[T]> = (
  es do: [:e <T> | add: e]
)
public iterator ^ <Iterator[T]> = (
  ^Iterator new
)
public  asStream ^ <HyperStream> = (
  ^self
)
public add: e <T> = (
  window add: e
)
public isKindOfAbstractHyperStream ^ <Boolean> = (
  ^true
)
public select: f <[:T | Boolean]> ^ <Stream[T]> = (
  ^filter: f
)
public collect: f <[:T | R]>  ^ <Stream[R]> = (
  ^map: f
)
public isComplete: b <Boolean> = (
  subclassResponsibility
)
public take: n <Integer> ^ <Stream[T]> = (
  subclassResponsibility
)
public isBounded ^ <Boolean> = (
  subclassResponsibility
)
public map: f <[:T | R]>  ^ <Stream[R]> = (
  subclassResponsibility
)
public isComplete  ^ <Boolean> = (
  subclassResponsibility
)
public filter: f <[:T | Boolean]> ^ <Stream[T]> = (
  subclassResponsibility
)
public flatMap: f <[:T | R]>  ^ <Stream[R]> = (
  subclassResponsibility
)
) : (
fromArray: a <Array[T]> ^ <Instance> = (
  ^self new addAll: a; isComplete: true; yourself
)
)
class ConstantStream on: k  dimension: ds <List[Integer | UnboundedDimension]> = AbstractHyperStream rank: ds size (
(* A hyperstream , all of whose elements are equal to some constant  *)
  |
  constant = k.
  |
  dimensions:: ds.
) (
class Iterator = (
) (
public hasNext ^ <Boolean> = (
  ^true
)
public next ^ <T> = (
  ^constant
)
public rank ^ <Integer> = (
  ^0
)
) : (
)
public isComplete  ^ <Boolean> = (
  ^false (* Is this the right answer?*)
)
public add: e <T> = (
  Error signal: 'Attempt to add to a constant stream'
)
public map: f <[:T | R]>  ^ <Stream[R]> = (
  ^class on: (f value: constant)
)
public filter: f <[:T | Boolean]> ^ <Stream[T]> = (
  (f value: constant) ifTrue: [^self] ifFalse: [^EmptyStream].
)
public isComplete: b  <Boolean> = (
   (* Do nothing? *)
)
public take: n <Integer> ^ <Stream[T]> = (
  | l <List> = List new: n. |
  1 to: n do: [:i <Integer> | l add: constant].
  ^BoundedStream fromList: l dimensions: {}
)
public flatMap: f <[:T | R]>  ^ <Stream[R]> = (
  ^map: f
)
) : (
)
public class BoundedHyperStream fromList: l <List[AbstractHyperStream[T]]> dimensions: ds <List[Integer | UnboundedDimension]> = AbstractHyperStream rank: ds size (
(* A hyperstream whose first dimension is a known integer.  The rank of a bounded hyperstream is always at least 1; rank 0 cases are represented by ScalarHyperStream.
Hence, the window and dimensions are never empty, and the window elements elements are always hyperstreams, bottoming out as scalar hyperstreams.
*)
  window: l.
  dimensions: ds.
) (
public isBounded ^ <Boolean> = (
  ^true
)
public isKindOfBoundedHyperStream ^ <Boolean> = (
  ^true
)
public isComplete  ^ <Boolean> = (
  ^true
)
public at: i <Integer> ^ <T> = (
(* What if i is out of bounds? *)
  ^window at: i
)
public isComplete: b <Boolean> = (
  (*  do nothing, but check that no one tries to tell me I'm not complete *)
  assert: [b] message: 'Attempt to assert bunded stream is incomplete!'
)
public take: n <Integer> ^ <Stream[T]> = (
  (* Need to protect against taking more than the window size *)
  assert: [n <= window size] message: 'Attempt to access a bounded stream past its end'.
  ^class fromList: (window copyFrom: 1 to: n) dimensions: dimensions
)
public map: f <[:AbstractHyperStream[T] | R]>  ^ <BoundedHyperStream[R]> = (
  ^class fromList: (window collect: f) dimensions: dimensions (* who says the dimensions are preserved? *)
)
public flatMap: f <[:T | R]>  ^ <AbstractHyperStream[R]> = (
  ^class fromList: (window collect:  [:e <AbstractHyperStream[T]> | e flatMap: f]) dimensions: dimensions
)
public filter: f <[:T | Boolean]> ^ <BoundedHyperStream[T]> = (
  | dtail = dimensions copy from: 2 to: dimensions size. |
  ^class fromList: (window select: [:e <AbstractHyperStream[T]> | e filter: f]) dimensions: {UnboundedDimension new}, dtail 
)
) : (
)
public class UnboundedHyperStream iteratingOver: i <Iterator> = AbstractHyperStream rank: i rank (
  |
  source <Iterator> = i.
  public isComplete ::= false.
  |
) (
public map: f <[:T | R]>  ^ <Stream[R]> = (
  ^class iteratingOver: (iterator map: f)
)
public take: n <Integer> ^ <Stream[T]> = (
  ^class iteratingOver: (iterator take: n)
)
public isKindOfUnboundedHyperStream ^ <Boolean> = (
  ^true
)
public filter: f <[:T | Boolean]> ^ <Stream[T]> = (
  ^class iteratingOver: (iterator filter: f)
)
public isBounded ^ <Boolean> = (
  ^false
)
public flatMap: f <[:T | R]>  ^ <Stream[R]> = (
  ^class iteratingOver: (iterator flatMap: f)
)
) : (
)
public class HyperStreamFactory = (
) (
public  iteratingOver: i <Iterator>  ^ <UnboundedHyperStream> = (
   ^UnboundedHyperStream iteratingOver: i
)
public zipSynchronous: streams <List[Stream]> ^ <Stream> = (
  ^iteratingOver: (SynchronousZipIterator iterators: (streams collect: [:s | s iterator]))
)
public replicate: s <S> ^ <Stream[S]> = (
   s isScalar ifTrue: [^ConstantStream on: s].
   ^iteratingOver: s iterator
)
public fromList: l <List[T]> dimensions: ds <List[Integer | UnboundedDimension]> ^ <BoundedHyperSteam> = (
  ^BoundedHyperStream fromList: l dimensions: dimensions
)
repeat: s  dimension: d = (
   d isKindOfInteger ifTrue: [ 
     (* Bounded case *)
     | l = List new: d. | (* Replicate s d times *)
     1 to: d do: [:i | l add: (HyperStream iteratingOver: s iterator)].
     ^fromList: l dimensions: {}, s dimensions.
   ].
   (* Unbounded case *)
   ^iteratingOver: (ReplicatingIterator replicating: s by: d iterator)
)
public replicate: s  <Stream> dimensions: dims <List[Integer | UnboundedDimension]> ^ <HyperStream> = (
   (* Base case; we've stripped away all the dimensions, and just produce a copy of s *)
   dims isEmpty ifTrue: [^replicate: s].
   (* Recursively replicate for the tail of the dimesniosn, and replicate the result by the first dimension *)
   ^repeat: (replicate: s dimensions: (dims copyFrom: 2 to: dims size)) dimension: dims first
)
public fromScalar: o <Object> ^ <ConstantStream> = (
  ^ScalarHyperStream scalarValue: o
)
public empty ^ <HyperStream> = ( 
  ^EmptyHyperStream new
)
public zipReactive: streams <List[AbstractHyperStream]> ^ <AbstractHyperStream[List]> = (
  ^iteratingOver: (ReactiveZipIterator zipping: (streams collect: [:s <AbstractHyperStream> | s iterator]))
)
) : (
)
class MappedIterator mapping: f <[:T | R]> on: i <Iterator> =  DerivedIterator fromIterator: i (
  |
  function <[:T | R]> = f.
  |
) (
public next ^ <R> = (
  ^function value: iterator next
)
) : (
)
class DerivedIterator fromIterator: i <Iterator> =  Iterator (
  |
  iterator <Iterator>
  |
) (
public hasNext ^ <Boolean> = (
  ^iterator hasNext
)
public rank ^ <Integer> = (
  ^iterator rank
)
) : (
)
class Iterator = (
) (
public hasNext ^ <Boolean> = (
  ^subclassResponsibility
)
public next ^ <T> = (
  ^subclassResponsibility
)
public map: f = (
  ^MappedIterator mapping: f on: self
)
public filter: f <[:T | Boolean]>  = (
  ^FilteredIterator filtering: f on: self
)
public rank ^ <Integer> = (
  ^subclassResponsibility
)
public flatMap: f = (
  ^MappedIterator mapping: f on: self
)
) : (
)
class FilteredIterator mapping: f <[:T | Boolean]> on: i <Iterator> =  DerivedIterator fromIterator: i (
  |
  function <[:T | Boolean]> = f.
    peek <T | Nil>
  |
) (
lookahead = (
  | nextItem <T | Nil> nextIsValid <Boolean>  |
  [iterator hasNext ifTrue: [nextIsValid:: (function value: (nextItem: iterator next))] ifFalse: [true]] whileFalse: [].
  ^nextIsValid ifTrue: [nextItem] ifFalse: [nil].
)
public hasNext ^ <boolean>  = (
   (* We're working on a stream, so even if we had nothing before, we might have something now. *)
   ^peek isNil not or: [peek:: lookahead. peek isNil not]
)
public next ^ <T> = (
(* Iffy. Only works if we assume somone has called hasNext just before calling next. 
   We should probably call hasNext here.  
*)
 | result = peek. |
 peek isNil ifTrue: [Error signal].
 peek:: lookahead.
  ^result
)
) : (
)
class ReactiveZipIterator zipping: iters <List[Iterator]> = Iterator (
(*
Iterator for reactive function calls. Takes a list of iterators on the arguments, and produces an iterator for their zipped values. If any argument has a vaue ready, produce a list of zipped values. Iterators that do not have a next value re-use their previous values, which are kept in the lastValues slot. Of course, this can't work the first time  the iterator is called, since there are no "previous values".  This is a special case, tracked by the firstTime slot.
*)
  |
  iterators <List[Iterator]> = iters.
  firstTime <Boolean> ::= true.
  lastValues <List> = List new: iterators size.
  |
) (
public rank ^ <Integer> = (
  ^iterators first rank
)
first ^ <List> = (
(* Produce  the first value of the iterator.  This is a special case, as noted in the class comment.*)
  iterators do: [:iter <Iterator> |
     (* initially populate lastValues *)  
     lastValues add: (iter hasNext 
       ifTrue: [iter next]
       (* We require that hasNext was call before calling this method, which will ensure that all iter hasNext is true for all iterators. Hence, if it is not the case, we have an error.*)
       ifFalse: [Error signal: 'Called iterator next without verifying if hasNext is true']
    )
  ].
  (* Ok, we are past the first time now *)
  firstTime:: false.
  (* Our results are in lastValues, but we do not want to expose that, so we copy *)
  ^lastValues copyFrom: 1 to: iterators size
)
public hasNext ^ <Boolean> = (
  (* First call is a special case, per class comment. We need initial values for all iterators. *)
  firstTime ifTrue: [^iterators allSatisfy: [:iter <Iterator> | iter hasNext]].
  (* normal case - as long as any iterator has a new value, we are ok. *)
  ^iterators anySatisfy: [:iter <Iterator[T]> | iter hasNext].
)
public next ^ <List> = (
  | result <List> = List new: iterators size. |
  firstTime ifTrue: [^first].
  assert: [hasNext] message: 'Called iterator next without verifying if hasNext is true'.
  (* We require that hasNext was call before calling this method. If it is not the case, we have an error.*)  
  iterators with: lastValues do: [:iter <Iterator> :last <Object> |
     result add: (iter hasNext 
       ifTrue: [iter next]
       ifFalse: [last]
    )
  ].
  ^result
)
) : (
)
class SynchronousZipIterator zipping: iters <List[Iterator]> = Iterator (
  |
  iterators <List[Iterator]> = iters.
  |
) (
public hasNext ^ <Boolean> = (
  ^iterators allSatisfy: [:iter <Iterator[T]> | iter hasNext].
)
public next ^ <List[T]> = (
  ^iterators collect: [:iter <Iterator[T]> | iter next ]
)
public rank ^ <Integer> = (
  ^iterators first rank
)
) : (
)
class ReplicatingIterator replicating: v by: i = DerivedIterator fromIterator: i (
  |
  replicated = v.
  |
) (
public rank ^ <Integer> = (
  ^iterator rank + 1
)
public next = (
  iterator next.
  v isKindOfAbstractHyperStream ifTrue: [^v iterator].
  ^v
)
) : (
)
public class UnboundedDimension = (
  (* The magic object representing an unbounded dimension of a hyperstream *)
) (
public = other ^ <Boolean> = (
  ^other isKindOfUnboundedDimension
)
public hash ^ <Integer> = (
  ^class hash
)
public isKindOfUnboundedDimension ^ <Boolean> = (
  ^true
)
) : (
)
class ScalarHyperStream scalarValue: s =  AbstractHyperStream rank: 0 (
  |
  constant = s.
  |
    window:: List new withAll: {s}.
    dimensions:: List new.
) (
public add: e <T> = (
  Error signal: 'Cannot add elements to a scalar stream'
)
public map: f <[:T | R]>  ^ <ScalarHyperStream[R]> = (
  ^class scalarValue: (f value: constant)
)
public filter: f <[:T | Boolean]> ^ <Stream[T]> = (
  ^(f value: constant) ifTrue: [self] ifFalse: [HyperStream empty]
)
public isBounded ^ <Boolean> = (
  ^true
)
public isComplete ^ <Boolean> = (
  ^true
)
public isComplete: b <Boolean> = (
  (*  do nothing, but check that no one tries to tell me I'm not complete *)
  assert: [b] message: 'Attempt to assert bunded stream is incomplete!'
)
public isKindOfScalarHyperStream ^ <Boolean> = (
  ^true
)
public isScalar ^ <Boolean> = (
  ^true
)
public take: n <Integer> ^ <Stream[T]> = (
  assert: [n < 2] message: 'Attempt to access more than one element of a scalr stream'.
  ^self
)
public flatMap: f <[:T | R]>  ^ <ScalarHyperStream[R]> = (
  ^map: f
)
) : (
)
class EmptyHyperStream = AbstractHyperStream rank: 0(

) (
public isBounded ^ <Boolean> = (
  ^true
)
public isComplete ^ <Boolean> = (
  ^true
)
public isComplete: b <Boolean> = (
  (*  do nothing, but check that no one tries to tell me I'm not complete *)
  assert: [b] message: 'Attempt to assert bunded stream is incomplete!'
)
public isKindOfEmptyHyperStream ^ <Boolean> = (
  ^true
)
public add: e <T> = (
  Error signal: 'Cannot add elements to an empty stream'
)
public filter: f <[:T | Boolean]> ^ <Stream[T]> = (
)
public map: f <[:T | R]>  ^ <Stream[R]> = (
)
public take: n <Integer> ^ <Stream[T]> = (
  assert: [n = 0] message: 'Attempt to element(s) of an empty stream'.
  ^self
)
public flatMap: f <[:T | R]>  ^ <Stream[R]> = (
)
) : (
)
) : (
)
