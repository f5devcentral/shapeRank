Newspeak3
'Root'
class ShapeRankConcreteTypechecker usingPlatform:
platform asts: asts collectionUtils: utils streams: hs <HyperStreams> = (
(*
An abstract interpreter for computing the types of programs.

We can compute the rank, dimensions and basic element type of any ShapeRank program by a simple process of abstract interpretation.  The disadvantage of this approach is that it does not support separate compilation. However, the advantage is that the process is much simpler than the dependent-type based technique. It is clearly decidable, since ShapeRank is not Turing complete. Time complexity is linear in the size of the call graph (not program size) and independent of the size of program data. This typechecker can be used to ensure type safety at compile time, without requiring return type annotations or any use of type, shape and dimension variables.

The most important limitation is that external function calls must be handled specially.
*)
   | 
    private ASTClass <ShapeRankAST class> = asts.
    private Map = platform collections Map.
    private List = platform collections List.
    private Utils = utils.
    private UnboundedDimension = hs UnboundedDimension.
    |
) (
public class TypeInterpreter usingPlatform: p
<Platform> collectionUtils: c = ASTClass usingPlatform: p collectionUtils: c (
  | 
  typeCallStack <List[TypeActivation]> = List new. 
  public unboundedDimension = UnboundedDimension new.
  scopeStack <List[ScopeAST]> = List new.
  typePrimitives <List[FunctionAST]> = List new.
  |
) (
public class TensorAST expressions: es <List[ExprAST]> position: p <{Integer. Integer}> = super TensorAST expressions: es  position: p (
) (
public computeTensorType ^ <ConcreteType>  = (
  | 
  elementType = (expressions collect: [:e <ExprAST> | e computeType])
     reduce: [:t1 <ConcreteType> :t2 <ConcreteType> | 
       | gcs = t1 greatestCommonBaseTypeWith: t2. |
       gcs isNil ifTrue: [Error signal: 'Elements of tensor have incompatible base types'].
       t1 rank = t2 rank ifFalse: [Error signal: 'Elements of tensor have different ranks'].
       t1 dimensions with: t2 dimensions do: [:d1 :d2 | d1 = d2 ifFalse: [Error signal: 'Elements of tensor have different dimensions']].
       ConcreteType dimensions: t1 dimensions baseType: gcs
       ] ifEmpty: [Error signal: 'Empty tensor literal is not legal' ].
 |
 ^ConcreteType dimensions: (List withAll: {expressions size}, elementType dimensions) baseType: elementType baseType 
)
public computeType ^ <ConcreteType>  = (
  ^isShape ifFalse: [computeTensorType] ifTrue: [computeShapeType]
)
public computeShapeType ^ <ConcreteType> = (
  | elementTypes <List[ConcreteType]> = expressions collect: [:e  <ExprAST> | e computeType]. |
  elementTypes allSatisfy: [:e <ConcreteType> | e baseType isKindOfInteger].
  (* How do we track that this intended to be a shape? *)
  #BOGUS. 
  ^ConcreteType dimensions: (elementTypes collect: [:e | e baseType]) baseType: 'Int'
)
) : (
)
public class StructLiteralAST data: data <Map[Symbol, ExprAST]> position: p <{Integer. Integer}> = super StructLiteralAST data: data position: p (
) (
public computeType ^ <ConcreteType> = (
  ^ConcreteType dimensions: List new baseType: (contents collect: [:e | e computeType ])
)
) : (
)
public class ShapeCastAST expression: e <ExprAST> to: s <ShapeAST> position: p <{Integer. Integer}> = 
  super ShapeCastAST expression: e to: s position: p (
) (
public computeType ^ <ConcreteType> = (
  | 
  etype = expression computeType. 
  dims = shape dimensions collect: [:d | d isKindOfDimensionNumberAST ifTrue: [d dimension] ifFalse: [dynamic]].
  result = ConcreteType dimensions: dims baseType: etype baseType.  
  dyn = etype dimensions detect: [:d | d isKindOfInteger not] ifNone: [].
  |
  dyn isNil ifTrue: [Error signal: 'Pointless cast  of non-dynamic tensor type.'].
  (etype hasRank and: [etype rank  ~= shape rank]) ifTrue: [
	Error signal: 'Type error: ', etype printString, ' can never be a subtype of ', result printString.
	].
  etype shape dimensions with: shape dimensions do: [:d1 :d2 |
	(d1 = dynamic and: [d1 ~= d2]) ifTrue: [
		Error signal: 'Type error: ', etype printString, ' can never be a subtype of ', result printString.
		]
	].
  ^result
)
) : (
)
public class IdentifierAST named: n <String> position: p <{Integer. Integer}> = super IdentifierAST named: n  position: p  (
  | cachedType <ConcreteType> |
) (
computeTypeFromScope:  n <Symbol> ^ <ConcreteType> = (
  | decl = (scope lookup: id) at: #ast. |
  decl isKindOfLetAST ifTrue: [^decl expression computeType].
  decl isKindOfExprAST ifTrue: [^decl computeType].
  decl isKindOfFunctionAST ifTrue: [Error signal: 'Higher order functions not supported'].
 ^decl
)
public computeType ^ <ConcreteType> = (
  cachedType isNil ifTrue: [cachedType:: computeTypeFromScratch].
  ^cachedType
)
computeTypeFromScratch ^ <ConcreteType> = (
   typeCallStack isEmpty ifFalse: [^currentTypeActivation at: id ifAbsent: [computeTypeFromScope: id]].
  ^computeTypeFromScope: id.
)
) : (
)
public class BlockAST body: e <ExprAST> position: p <{Integer. Integer}> = super BlockAST body: e position: p (
) (
public computeType ^ <ConcreteType> = (
(* BOGUS?  *)
  | T <ConcreteType> = body computeType.
    unit <TensorTypeAST> = (TypeIdAST named: #Unit position: {0. 0}) asTensorType. |
  ^ConcreteType dimensions: {} baseType: (FunctionTypeAST parameterTypes: {unit} returnType: T position: position) 
)
) : (
public body: e <ExprAST> ^ <Instance> = (
(* sigh, we should find a solution for class method inheritance *)
  ^body: e position: e position
)
)
public class BoolAST value: v <Boolean> position: p <{Integer. Integer}> = super BoolAST value: v position: p (
) (
public computeType ^ <ConcreteType> = (
  ^ConcreteType dimensions: List new baseType: 'Bool'
)
) : (
)
public class CallAST function: f <Symbol> arguments: as <List[ExprAST]> position: p <{Integer. Integer}> =  super CallAST function: f  arguments: as  position: p  (
  | visits <List[CallVisit]> = List new. |
) (
computeArgumentTypes = (
   | result = List new: arguments size. |
   1 to: arguments size do: [:i <Integer> | result add: (computeArgumentType: (arguments at: i) for: (callee parameters at: i))].
   ^result
)
callerVisit ^ <CallVisit | Nil> = (
(* Return the CallVisit representing my caller, or nil if this call is at top level. *)
  | top <TypeActivation | Nil> = typeCallStack isEmpty ifFalse: [typeCallStack last]. | 
  ^top isNil ifFalse:  [top callVisit]
)
computeArgumentType: arg <ConcreteType> for: param <ParameterAST> ^ <ConcreteType | AST> = (
  ^(param isHOF and: [arg isKindOfBlockAST not]) ifTrue: [
        | ast ::= (scope lookup: arg id ifAbsent:
                     [^(currentTypeActivation at: arg id)]) at: #ast. |
        ast isKindOfParameterAST ifTrue: [^(currentTypeActivation at: ast id)].
        ConcreteType dimensions: {} baseType: ast
     ] ifFalse: [arg computeType]
)
computeCallType: callee <FunctionAST> arguments: args <List[ConcreteType]> = (
  | 
  argFrames <List[TypeFrame]> = frameConcreteTypeArguments: args of: callee. (* frame *)
  maxFrame <TypeFrame>
  replicatedFrames <List[TypeFrame]>
  zippedFrame <TypeFrame>
  resultFrame <TypeFrame>
  |
(* replicate *)
  maxFrame:: argFrames reduce: [:f1 <TypeFrame> :f2 <TypeFrame> |
	f1 max: f2
	] ifEmpty: [emptyFrame].
  replicatedFrames:: argFrames collect: [:f <TypeFrame> | f replicateToMatch: maxFrame dimensions].
  zippedFrame:: zipFrame: replicatedFrames. (* zip *)
(* map*)
  resultFrame:: zippedFrame map: [:argVector <List[ConcreteType]> | 
	 | result  <TypeFrame> | 
	 pushTypeActivation:  (TypeActivation of: callee from: argVector visit: visits last).
	 result:: callee body computeType.
	 popTypeActivation.
	 result.
	].
  ^resultFrame asConcreteType.  
)
public computeType ^ <Tensor> = (
  | thisVisit <CallVisit> = CallVisit forCall: self callerVisit: callerVisit. result <ConcreteType> |
  visits add: thisVisit.
  result:: computeCallType: callee arguments: computeArgumentTypes.
  thisVisit type: result.
  ^result
)
) : (
)
public class NumAST value: n <Integer> position: p <{Integer. Integer}> = super NumAST value: n position: p () (
public computeType ^ <ConcreteType> = ( 
   | baseType <String> = val isKindOfInteger ifTrue: [val] ifFalse: ['Float']. |

  ^ConcreteType dimensions: List new baseType: baseType.
)
) : (
)
class PrimitiveBodyAST block: blk <Block> = super PrimitiveBodyAST block: blk (
  | public typeBlock <Block> |
) (
public computeType ^ <ConcreteType> = (
  ^typeBlock valueWithArguments: currentTypeActivation arguments asArray
)
) : (
)
public class ProgramAST header: hdr <ProgramHeaderAST> declarations: ds <List[FunctionAST]> expression: e <ExprAST> position: p <{Integer. Integer}> = 
  super ProgramAST header: hdr declarations: ds expression: e position: p (
  | public visits <List[CallVisit]> = List new. |
) (
public computeType ^ <ConcreteType> = (
  ^expression computeType
)
concreteDimensionFor: d  <DimensionAST> = (
  d isKindOfDimensionNumberAST ifTrue: [^d val].
  Error signal: 'Unsupported dimension specification'
)
computeCallType: callee <FunctionAST> arguments: args <List[ConcreteType]> = (
  | 
  argFrames <List[TypeFrame]> = frameConcreteTypeArguments: args of: callee. (* frame *)
  maxFrame <TypeFrame>
  replicatedFrames <List[TypeFrame]>
  zippedFrame <TypeFrame>
  resultFrame <TypeFrame>
  |
(* replicate *)
  maxFrame:: argFrames reduce: [:f1 <TypeFrame> :f2 <TypeFrame> |
	f1 max: f2
	] ifEmpty: [emptyFrame].
  replicatedFrames:: argFrames collect: [:f <TypeFrame> | f replicateToMatch: maxFrame dimensions].
  zippedFrame:: zipFrame: replicatedFrames. (* zip *)
(* map*)
  resultFrame:: zippedFrame map: [:argVector <List[ConcreteType]> | 
	 | result  <TypeFrame> | 
	 pushTypeActivation:  (TypeActivation of: callee from: argVector visit: visits last).
	 result:: callee body computeType.
	 popTypeActivation.
	 result.
	].
  ^resultFrame asConcreteType.  
)
concreteBaseTypeOf: t <TypeAST> ^ <String | Integer | Map[String, ConcreteType] | FunctionAST> = (
  t isKindOfTypeIdAST ifTrue: [^ t id].
  t isKindOfTensorTypeAST ifTrue: [^concreteBaseTypeOf: t baseType].
  t isKindOfStructAST ifTrue: [^t table collect: [:e <TypeAST> | concreteTypeFromType: e]].
  t isKindOfBoundedTypeAST ifTrue: [^concreteBaseTypeOf: t bound].
  (* An unbounded type variable. Return Any *)
  ^'Any'
)
concreteTypesOfArguments: args <List[HyperStream]> ^ <List[ConcreteType]> = (
  | 
  baseTypes <List[String | Integer | Map[String, ConcreteType] | FunctionAST]> = 
    parameters collect: [:p <ParameterAST> | concreteBaseTypeOf: p type]. 
  dims <List[List[Integer | UnboundedDimension]]> = args collect: [:arg <HyperStream> | arg dimensions].
  result <List[ConcreteType]> = List new.
  |
  baseTypes with: dims do: [:bt <String | Integer | Map[String, ConcreteType] | FunctionAST> :ds <List[Integer | UnboundedDimension]> | result add: (ConcreteType dimensions: ds baseType: bt)].
  ^result
)
concreteTypeFromType: t <TypeAST> = (  
  t isKindOfTensorTypeAST  ifTrue: [
    | dims <List[Integer | UnboundedDimension]> = t dimensions collect: [:d <DimensionAST>  | concreteDimensionFor: d]. |
    ^ConcreteType base: (concreteBaseTypeOf: e) dimensions: dims
    ].
  ^ConcreteType dimensions: {} baseType: (concreteBaseTypeOf: e)
)
public computeTypeWithArguments: args <List[HyperStream]> ^ <ConcreteType> = (
(* 
We treat the typechecking of a parameterized program like typechecking a function invocation.
*)
  | thisVisit <CallVisit> = CallVisit forCall: self callerVisit: nil. result <ConcreteType> |
  visits add: thisVisit. 
  result:: computeCallType: self arguments: (concreteTypesOfArguments: args).
  thisVisit type: result.  
  ^result  
)
) : (
)
public class RerankAST  reranking: fn <String> to: rs <List[Integer]> position: p <{Integer. Integer}>  = 
  super RerankAST reranking: fn to: rs  position: p (
) (
public computeType ^ <ConcreteType> = (
  ^ConcreteType dimensions: {} baseType: etaExpansion
)
) : (
)
public class StructDotAST expr: expr <ExprAST> label: label <Symbol> position: p <{Integer. Integer}> = super StructDotAST expr: expr label: label position: p (
) (
public computeType ^ <ConcreteType> = (
  | 
  structType = expr computeType. 
  fieldType = structType baseType at: label ifAbsent: [Error signal: structType printString, ' does not support field ', label].
  |
  ^ConcreteType dimensions: structType dimensions, fieldType dimensions baseType: fieldType baseType.
)
) : (
)
public class StringAST value: v <String> position: p <{Integer. Integer}> = super StringAST value: v position: p (
) (
public computeType ^ <ConcreteType> = (
  ^ConcreteType dimensions: List new baseType: 'String'
)
) : (
)
public class WhereAST expr1: e1 <ExprAST> ident: id <Symbol> expr2: e2 <ExprAST> position: p <{Integer. Integer}> = super WhereAST expr1: e1 ident: id expr2: e2 position: p (
) (
public computeType ^ <ConcreteType> = ( 
  | result |
  expr2 computeType.
  pushScope: scope.
  result:: expr1 computeType.
  popScope.
  ^result
)
) : (
)
public class ConcreteType dimensions: ds <List[Integer | UnboundedDimension]> baseType: b <String | Integer | Map[String, ConcreteType]> = (
(*
A base type is either a string (denoting an atomic type such as 'String' or 'Boolean'), an integer (identifying a specific number, for dimensional analysis), a map from strings to concrete types  (denoting a record type) or a ShapeRank function repressented as an AST. Dimensions are runtime dimensions: either integers or the unbounded dimension (aka ?).
*)
	|
	public dimensions <List[Integer | UnboundedDimension]> = ds.
	public baseType <String | Integer | Map[String, ConcreteType] | FunctionAST> = b.
	|
) (
public rank ^ <Integer> = (
  ^dimensions size
)
public printString ^ <String> = (
  | dims ::= ''. |
  dimensions do: [:d | dims:: dims, d printString] separatedBy: [dims:: dims, ', '].
  ^'[', dims, ']'
)
public hasRank ^ <Boolean> = (
  ^true
)
public isKindOfConcreteType ^ <Boolean> = (
  (* for compatibility with tests uite *)
  ^true
)
public asTensorType ^ <TensorTypeAST> = (
  ^TensorTypeAST shape: shape type: concreteBaseTypeToTypeAST position: {0. 0}
)
public hash ^ <Integer> = (
  ^dimensions hash bitXor: baseType hash
)
public addTypeVariablesTo: scope <Scope> = (
  (* do nothing. We are concrete - we have no type variables *)
)
public shape ^ <ShapeVectorAST> = (
  | 
  dims = dimensions collect: [:d | d isKindOfInteger ifTrue: [DimensionNumberAST number: d position: {0. 0}] ifFalse: [UnknownDimensionAST position: {0. 0}].].
  |
  ^ShapeVectorAST dimensions: dims position: {0. 0}
)
public isIntegral ^ <Boolean> = (
  ^baseType isKindOfInteger or: [baseType = 'Int']
)
public isNumeric ^ <Boolean> = (
  ^isIntegral or: [baseType = 'Float']
)
public concreteBaseTypeToTypeAST ^ <TypeAST> = (
  baseType isKindOfString ifTrue: [^TypeIdAST named: baseType position: {0. 0}].
  baseType isKindOfInteger ifTrue: [^DimensionNumberAST number: baseType position: {0. 0}].
  baseType isKindOfMap ifTrue: [^TypeStructAST table: (baseType collect: [:e | e asTensorType]) position: {0. 0}].
  ^baseType.
)
public greatestCommonBaseTypeWith: b <ConcreteType>  = (
  isNumeric ifTrue: [^greatestCommonNumericTypeWith: b].
  baseType isKindOfMap ifTrue: [^greatestCommonStructTypeWith: b].
  (* Return nil if no greatest common base type exists*) 
  ^baseType = b baseType ifTrue: [baseType]
)
greatestCommonStructTypeWith: b <ConcreteType> ^ <Map | Nil> = (
  (* Should only be called if the receiver's base type is a struct type *)
  (* If b's base is a struct the result will be a map; otherwise it will be nil *)  
  | result <Map | Nil> = b baseType isKindOfMap ifTrue: [Map new]. |

  result isNil ifFalse: [
    baseType keysAndValuesDo: [:k :v |
       (* The gcs will have a field only if both structs have it *)
       (b baseType includesKey: k) ifTrue: [
         | commonFieldBaseType = v greatestCommonBaseTypeWith: (b baseType at: k). |
           (* If the shapes of b and the receiver are the same and common field must itself has a gcs, the field is defined in the gcs *)
           ((v dimensionsAreEqualTo: (b baseType at: k) dimensions) and: [commonFieldBaseType isNil not]) ifTrue: [
              result at: k put: (ConcreteType dimensions: v dimensions baseType: commonFieldBaseType)]
       ].
    ].
  ].
  ^result
)
public dimensionsAreEqualTo: ds = (
  dimensions size = ds size ifFalse: [^false].
  dimensions with: ds do: [:d1 :d2 | d1 ~= d2 ifTrue: [^false]].
  ^true
)
greatestCommonNumericTypeWith: b <ConcreteType>  = (
  (* Should only be called if the receiver's base type is a numeric type *)
  (* if b is not a numeric, there is no gcs *)
  b isNumeric ifFalse: [^nil].
  baseType = 'Int' ifTrue: [
  (* if b's base type is given as a string, it must be one of {Int, Float, Num} and it dominates the receiver's base type Int.
     Otherwise b's base type and a specific number,  and Int is the gcs *)
    ^b baseType isKindOfString ifTrue: [b baseType] ifFalse: ['Int']
  ].
  baseType = 'Float' ifTrue: [
        (* If b's base is Number, it is the gcs; the receive's base type, Float, dominates any other possibility *)
        ^b baseType = 'Num' ifTrue: ['Num'] ifFalse: ['Float']
  ].
  (* Number is the gcs of all numeric types *)
  baseType = 'Num' ifTrue: [^'Num'].  
  (* The receiver's base type is a specific integer. If b's base is given as a string, it must be one of {Int, Float, Num} and it dominates the receiver's base type. *)
  b baseType isKindOfString ifTrue: [^b baseType].
  (* b's base type is also an integer. If they are the same, that is the gcs, otherwise it is Int.  *)
  ^baseType = b baseType ifTrue: [baseType] ifFalse: ['Int']
)
public = other ^ <Boolean> = (
  other isKindOfConcreteType ifFalse: [^false]. 
  rank = other rank ifFalse: [^false].
  baseType isKindOfMap ifTrue: [
     other baseType isKindOfMap ifFalse: [^false].
     (Utils maps: baseType eq: other baseType) ifFalse: [^false].
  ] ifFalse: [baseType = other baseType ifFalse: [^false]].  
  dimensions with: other dimensions do: [:d1 :d2 |  d1 = d2 ifFalse: [^false]].
  ^true
)
) : (
)
class TypeFrame dimensions: ds <List[Integer]> cells: cs <ConcreteType> = (
(*
A frame, logically, is an array of cells of shape #dimensions. 
In the abstract interpreter, cells is just a concrete type, representing the type of an individual cell.
*)
|
	public dimensions <List[Integer]> = ds.
	public cells <ConcreteType> = cs.
|
) (
public max: t <TypeFrame> ^ <TypeFrame> = (
 (* should check that either my shape is a prefix of t's or vice versa *)
  dimensions size > t dimensions size ifTrue: [^self].
  ^t
)
public printString = (
  ^'TypeFrame of rank: ', rank printString
)
public hasRank ^ <Boolean> = (
   ^true
)
public rank ^ <Integer> = (
  ^dimensions size
)
public map: f <[Object | T def]> ^ <TypeFrame[T]> = (
  ^TypeFrame 
        dimensions: dimensions 
        cells: (f value: cells)
)
public replicateToMatch: dims <List[Integer]> = (
  ^TypeFrame dimensions: dims cells: cells
)
public asConcreteType ^ <ConcreteType> = (
  dimensions isEmpty ifTrue: [^cells].
  ^ConcreteType 
      dimensions: dimensions, cells dimensions 
      baseType: cells baseType
)
) : (
)
class TypeActivation of: f <FunctionAST> from: argVector <List[ConcreteType]> visit: v <CallVisit> = (
|
	function <FunctionAST> = f.
	public arguments <List[ConcreteType]> = argVector.
    public callVisit <CallVisit> = v.
|
) (
public at: k <Symbol> ^ <ConcreteType> = (
  ^at: k ifAbsent: [Error signal: 'Undefined variable ', k]. (* should never happen in a typesafe program *)
)
public at: k <Symbol> ifAbsent: blk <[ConcreteType]> ^ <ConcreteType> = (
  1 to: function parameters size do: [:i <Integer> |
	(function parameters at: i) id = k ifTrue: [^arguments at: i]
	].
^blk value 
)
) : (
public of: f <FunctionAST> from: argVector <List[ConcreteType]> = (
  ^of: f from: argVector visit: nil
)
)
public class AST position: p <{Integer. Integer}> = super AST position: p (
) (
public eval = (
 (* do we really need this? *)
  ^computeType
)
public userType  ^ <TensorTypeAST> = (
  | t <TensorTypeAST> = computeType. |
  t isKindOfFunctionTypeAST ifTrue: [Error signal: 'Functions are not values unless passed to predefined HOFs' ].
  ^t asTensorType
)
) : (
)
public class FunctionAST named: n <String> parameters: ps <List[ParameterAST]> returnType: t <TensorTypeAST> body: b <ExprAST> isSync: isSync <Boolean> position: p <{Integer. Integer}>  = super FunctionAST named: n parameters: ps returnType: t body: b isSync: isSync position: p () (
computeReturnType ^ <ConcreteType> = (
  | result  <ConcreteType> |
   ^currentScope = scope
     ifTrue: [body computeType]
     ifFalse: [
       pushScope: scope.
       result:: body computeType.
       popScope.
       result
     ]
)
public returnType ^ <ConcreteType> = (
  returnTypeSlot isNil ifTrue: [
    returnTypeSlot:: computeReturnType.
    returnTypeSlot addTypeVariablesTo: scope.
  ].
  ^returnTypeSlot
)
) : (
public named: n <String> parameters: ps <List[ParameterAST]> returnType: t <TensorTypeAST> body: b <ExprAST> position: p <{Integer. Integer}> = (
  (* Convenience factory to pass default reactivity *)
  ^named: n parameters: ps returnType: t body: b isSync: false position: p 
)
)
class CallVisit forCall: c <CallAST> callerVisit: cv <CallVisit | Nil> = (
	|
    public type <ConcreteType>
    node <CallAST> = c.
	public callerVisit <CallVisit> = cv.
	|
) (
) : (
)
zipFrame: l <List[TypeFrame]> ^ <TypeFrame>  = (
 |  
  dims <List[Integer]> = l first dimensions.
  zippedCells <List[ConcreteType]> = l collect: [:f <TypeFrame> | f cells] .
|

 l do: [:e | e dimensions with: dims do: [:d1 :d2 | d1 = d2 ifFalse: [Error signal: 'Argument frames of varying rank']]].
  ^TypeFrame dimensions: dims cells: zippedCells.
)
currentActivation ^ <TypeActivation> = (
   ^typeCallStack last
)
public DimensionNumberAST ^ <DimensionNumberAST class> = (
  (* provide access for nested classes *)
  ^super DimensionNumberAST
)
public ShapeVectorAST ^ <ShapeVectorAST class> = (
  (* provide access for nested classes *)
  ^super ShapeVectorAST
)
public TypeIdAST ^ <TypeIdAST class> = (
  (* provide access for nested classes *)
  ^super TypeIdAST
)
public TypeStructAST ^ <TypeStructAST class> = (
  (* provide access for nested classes *)
  ^super TypeStructAST
)
public TensorTypeAST ^ <TensorTypeAST class> = (
  (* provide access for nested classes *)
  ^super TensorTypeAST
)
public UnknownDimensionAST ^ <UnboundedDimensionAST class> = (
  (* provide access for nested classes *)
  ^super UnknownDimensionAST
)
dynamic = (
  (* For now, subtleties between dynamic and ? are ignored *)
  #BOGUS.
  ^unboundedDimension
)
public FunctionTypeAST ^ <FunctionTypeAST class> = (
  (* provide access for nested classes *)
  ^super FunctionTypeAST
)
commonNumericBaseTypeFor: x and: y = (
  | xt = x baseType. yt = y baseType. |
  xt = yt ifTrue: [^yt].
  (xt = 'Float' or: [yt = 'Float']) ifTrue: [^'Float'].
  ^'Int'
)
currentScope ^  <Scope> = (
  scopeStack isEmpty ifTrue: [^programScope].
  ^scopeStack last
)
popScope  = (
  scopeStack removeLast
)
pushScope: s <Scope> = (
  scopeStack add: s
)
public Scope ^ <Scope class> = (
  (* provide access for nested classes *)
  ^super Scope
)
primitiveAppend ^ <FunctionAST> = (
(*  append(a: [$d1]::@S $T, b: [$d2]::@S $T):[$d1 + $d2]::@S $T *)
  | result <FunctionAST> = super primitiveAppend. |
  result body typeBlock: [:a :b | | gcs = a greatestCommonBaseTypeWith: b.  |
    (* verify base type $T is the well defined *)
    gcs isNil ifTrue: [Error signal: 'incompatible element types in call to append()'].
    (* verify $S is the same *)
   2 to: a dimensions size do: [:i <Integer> | (a dimensions at: i) = (b dimensions at: i)].
	ConcreteType dimensions: {(a dimensions at: 1) + (b dimensions at: 1)}, (a dimensions copyFrom: 2 to: a dimensions size) 
	            baseType:  gcs
	]. 
  ^result  
)
primitiveAnd ^ <FunctionAST> = (
  | result <FunctionAST> = super primitiveAnd. |
  result body typeBlock: [:x <ConcreteType> :y <ConcreteType> | 
    x baseType = 'Bool' ifFalse: [Error signal: 'invalid firest parameter for and()'].
    y baseType = 'Bool' ifFalse: [Error signal: 'invalid second parameter for and()'].
    ConcreteType dimensions: {} baseType: 'Bool'
    ]. 
  ^result
)
primitiveArgmax ^ <FunctionAST> = (
(* argmax(v: [$d]$T): Int *)
  | result <FunctionAST> = super primitiveArgmax. |

  result body typeBlock: [:v <ConcreteType> |
    v rank = 1 ifFalse: [Error signal: 'Argmax requires argument of rank > 1'].
    ConcreteType dimensions: {} baseType: 'Int'
  ].

  ^result
)
primitiveContains ^ <FunctionAST> = (
  (* contains(v: @S$T, x: $T): Bool *)
  | result <FunctionAST> = super primitiveContains. |

  result body typeBlock: [:tensor :element | 
    | gcs =  tensor greatestCommonBaseTypeWith: element. |
  (* should we change signature so we do not care about base types? *)
      gcs isNil ifTrue: [Error signal: 'hyperstream base type incompatible element type in call to contains()'].
      ConcreteType dimensions: {} baseType: 'Bool'
	].

  ^result
)
primitiveDivide ^ <FunctionAST> = (
  | result <FunctionAST> = super primitiveDivide. |

  result body typeBlock: [:x <ConcreteType> :y <ConcreteType> | 
    x isNumeric ifFalse: [Error signal: 'invalid first parameter passed to / '].
    y isNumeric ifFalse: [Error signal: 'invalid second parameter passed to /'].
    ConcreteType dimensions: {} baseType: 'Float'
    ]. 
  ^result
)
primitiveEquals ^ <FunctionAST> = (
  | result <FunctionAST> = super primitiveEquals. |

  result body typeBlock: [:x <ConcreteType> :y <ConcreteType> | 
    ConcreteType dimensions: {} baseType: 'Bool'
    ].
  ^result
)
primitiveExp ^ <FunctionAST> = (
  | result <FunctionAST> = super primitiveExp. |

  result body typeBlock: [:v | 
    v baseType = 'Float' ifFalse: [Error signal: 'non-floating point argument passed to exp()'].
    ConcreteType dimensions: {} baseType: 'Float'
  ].
  
  ^result
)
primitiveGeq ^ <FunctionAST> = (
(* >= (p1: $T, p2: $S): Boolean*)
  | result <FunctionAST> = super primitiveGeq. |

  result body typeBlock: [:a :b | 
   a isNumeric
     ifTrue: [b isNumeric ifFalse: [Error signal: 'incompatibly typed arguments for >=']]
     ifFalse: [
       a baseType = b baseType 
          ifFalse: [Error signal: 'incompatibly typed arguments for >=']
       ].   
  ConcreteType dimensions: {} baseType: 'Bool'
    ].
  ^result
)
primitiveGt ^ <FunctionAST> = (
  | result <FunctionAST> = super primitiveGt. |

  result body typeBlock: [:a <ConcreteType> :b <ConcreteType> | 
   a isNumeric
     ifTrue: [b isNumeric ifFalse: [Error signal: 'incompatibly typed arguments for >']]
     ifFalse: [
       a baseType = b baseType 
          ifFalse: [Error signal: 'incompatibly typed arguments for >']
       ].
    ConcreteType dimensions: {} baseType: 'Bool'
    ].
  ^result
)
primitiveIf  ^ <FunctionAST> = (
(* if(c: Bool, t: $T, e: $T): $T *)
  | result <FunctionAST> = super primitiveIf. |

  result body typeBlock: [:c :t :e | 
    | 
    thenType = t baseType returnType.
    elseType = e baseType returnType.
    gcs =  thenType greatestCommonBaseTypeWith: elseType.
    |
    c baseType = 'Bool' ifFalse: [Error signal: 'Non-boolean condition in if expression'].
     thenType rank = elseType rank ifFalse: [Error signal: 'Branches of if expression have different ranks'].
     thenType dimensions with: elseType dimensions do: [:d1 :d2 |
      d1 = d2 ifFalse: [Error signal: 'Branches of if expression have different dimensions']].
     gcs isNil ifTrue: [Error signal: 'Branches of if expression have different element types'].
     ConcreteType dimensions: thenType dimensions baseType: gcs
	].   
  ^result
)
primitiveIota ^ <FunctionAST> = (
(* iota(n: $d): [$d]Int *)
  | result <FunctionAST> = super primitiveIota. |

  result body typeBlock: [:n | 
    | size  = n baseType isKindOfInteger ifTrue: [n baseType] ifFalse: [dynamic]. |
    n isIntegral ifFalse: [Error signal: 'non-integer argument to iota()'].
	ConcreteType dimensions: {size} baseType: 'Int'
	]. 
   ^result
)
primitiveLength ^ <FunctionAST> = (
(* length(v: [$d]$T): $d *)
  | result <FunctionAST> = super primitiveLength. |

  result body typeBlock: [:v <ConcreteType> | 
	ConcreteType dimensions: {} baseType: 'Int' (* make this precise? v dimensions first? *)
	]. 
  ^result
)
primitiveLeq ^ <FunctionAST> = (
  | result <FunctionAST> = super primitiveLeq. |

  result body typeBlock: [:a <ConcreteType> :b <ConcreteType> | 
   a isNumeric
     ifTrue: [b isNumeric ifFalse: [Error signal: 'incompatibly typed arguments for <=']]
     ifFalse: [
       a baseType = b baseType 
          ifFalse: [Error signal: 'incompatibly typed arguments for <=']
       ].
    ConcreteType dimensions: {} baseType: 'Bool'
    ].
  ^result
)
primitiveLog ^ <FunctionAST> = (
  | result <FunctionAST> = super primitiveLog. |

  result body typeBlock: [:v | 
    v baseType = 'Float' ifFalse: [Error signal: 'non-floating point argument passed to log()'].
    ConcreteType dimensions: {} baseType: 'Float'
  ].
  ^result
)
primitiveLt ^ <FunctionAST> = (
  | result <FunctionAST> = super primitiveLt. |

  result body typeBlock: [:a <ConcreteType> :b <ConcreteType> | 
   a isNumeric
     ifTrue: [b isNumeric ifFalse: [Error signal: 'incompatibly typed arguments for <']]
     ifFalse: [
       a baseType = b baseType 
          ifFalse: [Error signal: 'incompatibly typed arguments for <']
       ].  
    ConcreteType dimensions: {} baseType: 'Bool'
    ].
  ^result
)
primitiveMakeTensor ^ <FunctionAST> = (
(* makeTensor(dims: @S, contents: []$T):@S $T *)
  | result <FunctionAST> = super primitiveMakeTensor. |

  result body typeBlock: [:dims :contents | 
      dims baseType = 'Int' ifFalse: [Error signal: 'Dimensions must be integers'].
      ConcreteType dimensions: dims dimensions baseType: contents baseType
	]. 
  ^result
)
primitiveMask = (
(* mask (m: [$d1]Bool, v: [$d1]$T): [dynamic]$T *)
  | result <FunctionAST> = super primitiveMask. |

  result body typeBlock: [:mask :v | 
	ConcreteType dimensions: {dynamic}  baseType: v baseType
	].
  ^result
)
primitiveMinus ^ <FunctionAST> = (
  | result <FunctionAST> = super primitiveMinus. |

  result body typeBlock:  [:x <ConcreteType> :y <ConcreteType> | 
    |  baseType = commonNumericBaseTypeFor: x and: y. | 
    x isNumeric ifFalse: [Error signal: 'invalid first parameter passed to -'].
    y isNumeric ifFalse: [Error signal: 'invalid second parameter passed to -'].
    ConcreteType dimensions: {} baseType: baseType
    ].
  ^result
)
primitiveModulus ^ <FunctionAST> = (
  | result <FunctionAST> = super primitiveModulus. |

  result body typeBlock:  [:x <ConcreteType> :y <ConcreteType> | 
    x isIntegral ifFalse: [Error signal: 'non-integer first parameter passed to %'].
    y isIntegral ifFalse: [Error signal: 'non-integer second parameter passed to %'].
    ConcreteType dimensions: {} baseType: 'Integer'
    ].
  ^result
)
primitiveNegate ^ <FunctionAST> = (
  | result <FunctionAST> = super primitiveNegate. |

  result body typeBlock: [:a <ConcreteType>  | 
    a isNumeric ifFalse: [Error signal: 'non-numeric argument to operator unary -'].
    ConcreteType dimensions: {} baseType: a baseType
    ]. 
  ^result
)
primitiveNot ^ <FunctionAST> = (
  | result <FunctionAST> = super primitiveNot. |

  result body typeBlock: [:x <ConcreteType> | 
    x baseType = 'Bool' ifFalse: [Error signal: 'non-boolean argument to not()'].
    ConcreteType dimensions: {} baseType: 'Bool'
    ]. 
  ^result
)
primitiveOr ^ <FunctionAST> = (
  | result <FunctionAST> = super primitiveOr. |

  result body typeBlock: [:x <ConcreteType> :y <ConcreteType> | 
    x baseType = 'Boolean' ifFalse: [Error signal: 'invalid first parameter for or()'].
    y baseType = 'Boolean' ifFalse: [Error signal: 'invalid second parameter for or()'].
    ConcreteType dimensions: {} baseType: 'Bool']. 
  ^result
)
primitivePlus ^ <FunctionAST> = (
  | result <FunctionAST> = super primitivePlus. |

  result body typeBlock:  [:x <ConcreteType> :y <ConcreteType> | 
    |  baseType = commonNumericBaseTypeFor: x and: y. |  
    x isNumeric ifFalse: [Error signal: 'invalid first parameter passed to +'].
    y isNumeric ifFalse: [Error signal: 'invalid second parameter passed to +'].
    ConcreteType dimensions: {} baseType: baseType
    ].
  ^result
)
primitivePower ^ <FunctionAST> = (
  | result <FunctionAST> = super primitivePower. |

  result body typeBlock: [:x <ConcreteType> :y <ConcreteType> | 
    x isIntegral ifFalse: [Error signal: 'non-integer first parameter passed to power()'].
    y isIntegral ifFalse: [Error signal: 'non-integer second parameter passed to power()'].
    ConcreteType dimensions: {} baseType: 'Integer'
    ]. 
  ^result
)
primitiveShapeOf ^ <FunctionAST> = (
(* shapeOf(t: @S $T): @S *)
  | result <FunctionAST> = super primitiveShapeOf. |

  result body typeBlock: [:tensor | 
	ConcreteType dimensions: {tensor rank} baseType: 'Int'
	]. 
  ^result
)
primitiveTimes ^ <FunctionAST> = (
  | result <FunctionAST> = super primitiveTimes. |

  result body typeBlock: [:x <ConcreteType> :y <ConcreteType> | 
    |  baseType = commonNumericBaseTypeFor: x and: y. |
    x isNumeric ifFalse: [Error signal: 'invalid first parameter passed to * '].
    y isNumeric ifFalse: [Error signal: 'invalid second parameter passed to *'].
    ConcreteType dimensions: {} baseType: baseType
    ].  
  ^result
)
primitiveRotate ^ <FunctionAST> = (
(*  rotate(t: @S $T, n: Int): @S $T *)
  | result <FunctionAST> = super primitiveRotate. |

  result body typeBlock: [:t :n | 
    n isIntegral ifFalse: [Error signal: 'non-integer second argument to rotate()']. 
 	ConcreteType dimensions: t dimensions 
	            baseType:  t baseType
	]. 
  ^result
)
primitiveToList ^ <FunctionAST> = (
(* toList(ts: []$T): [dynamic]$T *)
  | result <FunctionAST> = super primitiveToList. |

  result body typeBlock: [:ts <ConcreteType> | 
      ConcreteType dimensions: {1} baseType: ts baseType
	]. 
  ^result
)
primitiveTranspose ^ <FunctionAST> = (
(* transpose(t: @S$T):@S reversed? $T *)
  | result <FunctionAST> = super primitiveTranspose. |

  result body typeBlock: [:t <ConcreteType> | 
      ConcreteType dimensions: t dimensions reverse baseType: t baseType
	]. 
  ^result
)
frameConcreteTypeArgument: arg <ConcreteType> forParameter: p <ParameterAST> ^ <TypeFrame> = (
  p hasRank ifFalse: [
	^TypeFrame dimensions: {} cells: arg.
	].
  arg rank >= p rank ifTrue: [ 
	| 
	fdims <List[Integer | UnboundedDimension]> = arg dimensions copyFrom: 1 to: arg rank - p rank.
	cdims <List[Integer | UnboundedDimension]> = arg dimensions copyFrom: arg rank - p rank + 1 to: arg rank. 
    |
	^TypeFrame dimensions: fdims cells:  (ConcreteType dimensions: cdims baseType: arg baseType)
	].
   ^Error signal: 'Rank of actual argument ' , arg printString, '(', arg rank printString, ') is less than rank of formal parameter ', p id, ' (', p rank printString, ')'.
)
frameConcreteTypeArguments: args <List[ConcreteType]> of: callee <FunctionAST> ^ <List[TypeFrame]> = (
  | argFrames <List[TypeFrame]> = List new: args size. |
  args with: callee parameters do: [:a <ConcreteType> :p <ParameterAST> |
  argFrames add: (frameConcreteTypeArgument: a forParameter: p)
  ].
  ^argFrames
)
primitiveRange ^ <FunctionAST> = (
(* range(start: $d1, end: $d1 + $d2): [$d2 + 1]Int *)
  | result <FunctionAST> = super primitiveRange. |

  result body typeBlock: [:i :j | 
    | 
    minRange = i baseType. 
    maxRange = j baseType. 
    size = (minRange isKindOfInteger and: [maxRange isKindOfInteger]) 
      ifTrue: [(maxRange - minRange) abs + 1]
      ifFalse: [dynamic].
    |
    i isIntegral ifFalse: [Error signal: 'Non-integral first argument to ..'].    
    j isIntegral ifFalse: [Error signal: 'Non-integral second argument to ..'].
	ConcreteType dimensions: {size} baseType: 'Int'
	]. 
  ^result
)
currentTypeActivation ^ <TypeActivation> = (
   ^typeCallStack last
)
popTypeActivation = (
  typeCallStack removeLast.
)
pushTypeActivation: a <TypeActivation> = (
  typeCallStack add: a
)
primitiveFold ^ <FunctionAST> = (
(*  fold(f: @P$T->@Q$S->@P$T, acc: @P$T, x:[$d]::@R::@Q $S): @R::@P $T *)
  | r <FunctionAST> = super primitiveFold. |

  r body typeBlock: [:f :acc :x |  
    | 
    result 
    fun = f baseType.
    fx = (frameConcreteTypeArgument: x forParameter: (fun parameters last)) cells.
    prevAcc ::= acc.
    callF = [:a :e | | retVal |
      (*check that f is applicable to acc & (properly framed) x *)
      pushTypeActivation:  (TypeActivation of: fun from: {prevAcc. fx}).
      retVal:: fun body computeType.
	  popTypeActivation. 
      retVal
    ].
    | 
     (* need to do fix point computation to figure out true result type *)
     [result:: callF value: prevAcc value: fx. prevAcc = result] whileFalse: [
       | nbase = prevAcc greatestCommonBaseTypeWith: result. |
       nbase isNil ifTrue: [Error signal: 'Function parameter to fold has return type inconsistent with its first argument'].
       prevAcc:: ConcreteType dimensions: acc dimensions baseType: nbase
     ].
      ConcreteType dimensions: (x dimensions copyFrom: 2 to: x rank - fx dimensions size), acc dimensions baseType: result baseType
    ].
  ^r
)
primitiveGradientDescent ^ <FunctionAST> = (
(* gradient_descent(lr: Float, loss: $T -> [$d]$S -> Float, initialParams: $T <: {}, otherParams: [$d]$S): $T*)
  | result <FunctionAST> = super primitiveGradientDescent. |

  result body typeBlock: [:lr :loss :params :otherParams |
      | floatParams |
      
      lr baseType = 'Float' ifFalse: [Error signal: 'Non-floating point first argument to gradientDescent()'].      
      params baseType isKindOfMap ifFalse: [Error signal: 'Third parameter to gradientDescent must be a record.'].
      floatParams:: ConcreteType dimensions: params dimensions baseType: 
        (params baseType collect: [:v <ConcreteType> | 
          v isNumeric ifTrue: [ConcreteType dimensions: v dimensions baseType: 'Float'] 
            ifFalse: [Error signal: 'Third parameter to gradientDescent must be record with all fields being Floats.'] 
          ]
        ). 
      pushTypeActivation:  (TypeActivation of: loss baseType from: {floatParams. otherParams}).
      loss baseType body computeType baseType = 'Float' ifFalse: [Error signal: 'loss function must return a Float in gradientDescent()'].
	  popTypeActivation.      
      ConcreteType dimensions: {} baseType: floatParams baseType
    ].
  ^result
)
primitiveInnerProduct ^ <FunctionAST> = (
(* 
innerProduct(a: @X:: [$n]$T, b: [$n]::@Y$S,  f: $R -> $R -> $Q $, g: $T -> $S -> $R): @X::@Y$Q
*)
  | result <FunctionAST> = super primitiveInnerProduct. |

  result body typeBlock: [:a :b :f :g |  
  | r q |
    (* get scalar version of base types from a and b, feed them to a call of g, get result type R *)
	 pushTypeActivation:  (TypeActivation of: g baseType from: {ConcreteType dimensions: {} baseType: a baseType. ConcreteType dimensions: {} baseType: b baseType}).
	 r:: g baseType body computeType.
	 popTypeActivation.   
     (* Feed two copies of R into f to get Q. *)
	 pushTypeActivation:  (TypeActivation of: f baseType from: {r. r}).
	 q:: f baseType body computeType baseType.
	 popTypeActivation.
     (* Peel last dim off of dims of a and first dim off of dims of b to get X & Y *)
	ConcreteType dimensions: (a dimensions copyFrom: 1 to: a dimensions size -1), (b dimensions copyFrom: 2 to: b dimensions size)
	            baseType: q
	]. 
  ^result
)
primitiveOuterProduct ^ <FunctionAST> = (
(*  outerProduct(f: @S1 $T1 -> @S2 T2 -> @S3 $T3, a: [d1]::@S4::@S1 $T1, b: [d2]::@S5::@S2 $T2): [d1]::@S4::[d2]::@S5::@S3 $T3 *)
  | result <FunctionAST> = super primitiveOuterProduct. |

  result body typeBlock: [:f <ConcreteType> :a <ConcreteType> :b <ConcreteType> |  
    | 
    fun <FunctionAST> = f baseType.
    call  (*  hard part - how to make the call to f? Frame each arg separately. Then use their cells as args to f. *)
    (* Remember to peal off first dim from incoming tensors, as it is the tensor elements that are fed to f. *)
    frames <List[TypeFrame]> = frameConcreteTypeArguments: {ConcreteType dimensions: (a dimensions copyFrom: 2 to: a rank) baseType: a baseType. ConcreteType dimensions: (b dimensions copyFrom: 2 to: b rank) baseType: b baseType} of: fun.
    argVector <List[ConcreteType]> = frames collect: [:frame <TypeFrame> | frame cells].
    |
    a rank < 1 ifTrue: [Error signal: 'Second argument to outerProduct must be of rank > 0'].
    b rank < 1 ifTrue: [Error signal: 'Third argument to outerProduct must be of rank > 0'].    
    fun isKindOfFunctionAST ifFalse: [Error signal: 'First parameter to outerProduct must be a function '].
    pushTypeActivation: (TypeActivation of: fun from: argVector).
    call:: fun body computeType.
    popTypeActivation.
	ConcreteType dimensions: {a dimensions first}, frames first dimensions, {b dimensions first}, frames last dimensions, call dimensions baseType: call baseType
	]. 
  ^result
)
primitiveReduce ^ <FunctionAST> = (
(*  reduce(f: @S $T->@S $T->@S $T, acc: @S $T, x:[]::@R::@S $T): @R::@S $T *)
  | r <FunctionAST> = super primitiveReduce. |

  r body typeBlock: [:f :acc :x |  
    | 
    result 
    gcs = acc greatestCommonBaseTypeWith: x.
    fun = f baseType.    
    fx = (frameConcreteTypeArgument: x forParameter: (fun parameters last)) cells.
    prevAcc ::= acc.
    callF = [:a :e | | retVal |
      (*check that f is applicable to acc & (properly framed) x *)
      pushTypeActivation:  (TypeActivation of: fun from: {prevAcc. fx}).
      retVal:: fun body computeType.
	  popTypeActivation. 
      retVal
    ].    
    |
    (* no need to check that x is of rank > 0. Call semantics ensure that *)
    gcs isNil ifTrue: [Error signal: 'Tensor and accumulator parameters element types disagree in reduce'].
     (* need to do fix point computation to figure out true result type *)
     [result:: callF value: prevAcc value: fx. prevAcc = result] whileFalse: [
       | nbase = prevAcc greatestCommonBaseTypeWith: result. |
       nbase isNil ifTrue: [Error signal: 'Function parameter to reduce has return type inconsistent with its first argument'].
       prevAcc:: ConcreteType dimensions: acc dimensions baseType: nbase
     ].     
    ConcreteType dimensions: (x dimensions copyFrom: 2 to: x rank), acc dimensions baseType: result baseType
	]. 
  ^r
)
primitiveScan ^ <FunctionAST> = (
(*  scan(f: @S $T-> @S $T-> @S $T, acc: @S $T, x:[d]::@R::@S $T):[d]::@R::@S $T *)
  | r <FunctionAST> = super primitiveScan. |

  r body typeBlock: [:f :acc :x |
    | 
    result 
    gcs = acc greatestCommonBaseTypeWith: x.
    fun = f baseType.    
    fx = (frameConcreteTypeArgument: x forParameter: (fun parameters last)) cells.
    prevAcc ::= acc.
    callF = [:a :e | | retVal |
      (*check that f is applicable to acc & (properly framed) x *)
      pushTypeActivation:  (TypeActivation of: fun from: {prevAcc. fx}).
      retVal:: fun body computeType.
	  popTypeActivation. 
      retVal
    ].      
    |
   (* no need to check that x is of rank > 0. Call semantics ensure that *)
    gcs isNil ifTrue: [Error signal: 'Tensor and accumulator parameters disagree in scan'].
     (* need to do fix point computation to figure out true result type *)
     [result:: callF value: prevAcc value: fx. prevAcc = result] whileFalse: [
       | nbase = prevAcc greatestCommonBaseTypeWith: result. |
       nbase isNil ifTrue: [Error signal: 'Function parameter to scan has return type inconsistent with its first argument'].
       prevAcc:: ConcreteType dimensions: acc dimensions baseType: nbase
     ].     
    ConcreteType dimensions: x dimensions, acc dimensions baseType: result baseType
	]. 
  ^r
)
primitiveApply ^ <FunctionAST> = (
(* apply(f: @R$X -> @S$Y, x: @R$X): @S$Y *)
  | r <FunctionAST> = super primitiveApply. |

  r body typeBlock: [:f <ConcreteType> :x <ConcreteType> |
    |
    result
    fun = f baseType.
    fx = (frameConcreteTypeArgument: x forParameter: (fun parameters first)) cells.
    |
    pushTypeActivation:  (TypeActivation of: fun from: {fx}).
    result:: fun body computeType.
	popTypeActivation. 
    result   
  ].
  ^r
)
) : (
)
) : (
)
