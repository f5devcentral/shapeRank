Newspeak3
'Root'
class ShapeRankConcreteTypechecker usingPlatform:
platform asts: asts collectionUtils: utils streams: hs <HyperStreams> = (
(*
An abstract interpreter for computing the types of programs.

We can compute the rank, dimensions and basic element type of any ShapeRank program by a simple process of abstract interpretation.  The disadvantage of this approach is that it does not support separate compilation. However, the advantage is that the process is much simpler than the dependent-type based technique. It is clearly decidable, since ShapeRank is not Turing complete. Time complexity is linear in the size of the call graph (not program size) and independent of the size of program data. This typechecker can be used to ensure type safety at compile time, without requiring return type annotations or any use of type, shape and dimension variables.

The most important limitation is that external function calls must be handled specially.
*)
   | 
    private ASTClass <ShapeRankAST class> = asts.
    private Map = platform collections Map.
    private List = platform collections List.
    private Utils = utils.
    private UnboundedDimension = hs UnboundedDimension.
    |
) (
public class TypeInterpreter usingPlatform: p
<Platform> collectionUtils: c = ASTClass usingPlatform: p collectionUtils: c (
  | 
  typeCallStack <List[Activation]> = List new. 
  unboundedDimension = UnboundedDimension new.
  scopeStack <List[ScopeAST]> = List new.
  |
) (
public class TensorAST expressions: es <List[ExprAST]> position: p <{Integer. Integer}> = super TensorAST expressions: es  position: p (
) (
public computeTensorType ^ <ConcreteType>  = (
  | 
  elementType = (expressions collect: [:e <ExprAST> | e computeType])
     reduce: [:t1 <ConcreteType> :t2 <ConcreteType> | 
       | gcs = t1 greatestCommonBaseTypeWith: t2. |
       gcs isNil ifTrue: [Error signal: 'Elements of tensor have incompatible base types'].
       t1 rank = t2 rank ifFalse: [Error signal: 'Elements of tensor have different ranks'].
       t1 dimensions with: t2 dimensions do: [:d1 :d2 | d1 = d2 ifFalse: [Error signal: 'Elements of tensor have different dimensions']].
       ConcreteType dimensions: t1 dimensions baseType: gcs
       ] ifEmpty: [Error signal: 'Empty tensor literal is not legal' ].
 |
 ^ConcreteType dimensions: (List withAll: {expressions size}, elementType dimensions) baseType: elementType baseType 
)
public computeType ^ <ConcreteType>  = (
  ^isShape ifFalse: [computeTensorType] ifTrue: [computeShapeType]
)
public computeShapeType ^ <ConcreteType> = (
  | elementTypes <List[ConcreteType]> = expressions collect: [:e  <ExprAST> | e computeType]. |
  elementTypes allSatisfy: [:e <ConcreteType> | e baseType isKindOfInteger].
  (* How do we track that this intended to be a shape? *)
  #BOGUS. 
  ^ConcreteType dimensions: (elementTypes collect: [:e | e baseType]) baseType: 'Int'
)
) : (
)
public class StructLiteralAST data: data <Map[Symbol, ExprAST]> position: p <{Integer. Integer}> = super StructLiteralAST data: data position: p (
) (
public computeType ^ <ConcreteType> = (
  ^ConcreteType dimensions: List new baseType: (contents collect: [:e | e computeType ])
)
) : (
)
public class ShapeCastAST expression: e <ExprAST> to: s <ShapeAST> position: p <{Integer. Integer}> = 
  super ShapeCastAST expression: e to: s position: p (
) (
public computeType ^ <ConcreteType> = (
  | 
  etype = expression computeType. 
  dims = shape dimensions collect: [:d | d isKindOfDimensionNumber ifTrue: [d val] ifFalse: [dynamic]].
  result = ConcreteType dimensions: dims baseType: etype baseType.  
  dyn = etype dimensions detect: [:d | d isKindOfInteger not] ifNone: [].
  |
  dyn isNil ifTrue: [Error signal: 'Pointless cast  of non-dynamic tensor type.'].
  (etype hasRank and: [etype rank  ~= shape rank]) ifTrue: [
	Error signal: 'Type error: ', etype printString, ' can never be a subtype of ', result printString.
	].
  etype shape dimensions with: shape dimensions do: [:d1 :d2 |
	(d1 isKindOfDynamicTypeAST not and: [d1 ~= d2]) ifTrue: [
		Error signal: 'Type error: ', etype printString, ' can never be a subtype of ', result printString.
		]
	].
  ^result
)
) : (
)
public class IdentifierAST named: n <String> position: p <{Integer. Integer}> = super IdentifierAST named: n  position: p  (
) (
public computeType ^ <ConcreteType> = (
   typeCallStack isEmpty ifFalse: [^currentActivation at: id ifAbsent: [computeTypeFromScope: id]].
  ^computeTypeFromScope: id.
)
computeTypeFromScope:  n <Symbol> ^ <ConcreteType> = (
  | decl = (scope lookup: id) at: #ast. |
  decl isKindOfLetAST ifTrue: [^decl expression computeType].
  decl isKindOfExprAST ifTrue: [^decl computeType].
  decl isKindOfFunctionAST ifTrue: [Error signal: 'Higher order functions not supported'].
 ^decl
)
) : (
)
public class BlockAST body: e <ExprAST> position: p <{Integer. Integer}> = super BlockAST body: e position: p (
) (
public computeType ^ <ConcreteType> = (
(* BOGUS?  *)
  | T <ConcreteType> = body computeType.
    unit <TensorTypeAST> = (TypeIdAST named: #Unit position: {0. 0}) asTensorType. |
  ^ConcreteType dimensions: {} baseType: (FunctionTypeAST parameterTypes: {unit} returnType: T position: position) 
)
) : (
public body: e <ExprAST> ^ <Instance> = (
(* sigh, we should find a solution for class method inheritance *)
  ^body: e position: e position
)
)
public class BoolAST value: v <Boolean> position: p <{Integer. Integer}> = super BoolAST value: v position: p (
) (
public computeType ^ <ConcreteType> = (
  ^ConcreteType dimensions: List new baseType: 'Bool'
)
) : (
)
public class CallAST function: f <Symbol> arguments: as <List[ExprAST]> position: p <{Integer. Integer}> =  super CallAST function: f  arguments: as  position: p  (
) (
public computeType ^ <Tensor> = (
  ^computeCall: callee arguments: computeArgumentTypes
)
computeArgumentTypes = (
   | result = List new: arguments size. |
   1 to: arguments size do: [:i <Integer> | result add: (computeArgumentType: (arguments at: i) for: (callee parameters at: i))].
   ^result
)
computeArgumentType: arg <ConcreteType> for: param <ParameterAST> ^ <ConcreteType | AST> = (
  ^(param isHOF and: [arg isKindOfBlockAST not]) ifTrue: [
        | ast ::= (scope lookup: arg id ifAbsent:
                     [^(currentActivation at: arg id)]) at: #ast. |
        ast isKindOfParameterAST ifTrue: [^(currentActivation at: ast id)].
        ConcreteType dimensions: {} baseType: ast
     ] ifFalse: [arg computeType]
)
) : (
)
public class NumAST value: n <Integer> position: p <{Integer. Integer}> = super NumAST value: n position: p () (
public computeType ^ <ConcreteType> = ( 
   | baseType <String> = val isKindOfInteger ifTrue: [val] ifFalse: ['Float']. |

  ^ConcreteType dimensions: List new baseType: baseType.
)
) : (
)
class PrimitiveBodyAST block: blk <Block> = super PrimitiveBodyAST block: blk (
) (
public computeType ^ <ConcreteType> = (
  ^block valueWithArguments: currentActivation arguments asArray
)
) : (
)
public class ProgramAST header: hdr <ProgramHeaderAST> declarations: ds <List[FunctionAST]> expression: e <ExprAST> position: p <{Integer. Integer}> = 
  super ProgramAST header: hdr declarations: ds expression: e position: p (
) (
public computeType ^ <ConcreteType> = (
  ^expression computeType
)
) : (
)
public class RerankAST  reranking: fn <String> to: rs <List[Integer]> position: p <{Integer. Integer}>  = 
  super RerankAST reranking: fn to: rs  position: p (
) (
public computeType ^ <ConcreteType> = (
  ^ConcreteType dimensions: {} baseType: etaExpansion
)
) : (
)
public class StructDotAST expr: expr <ExprAST> label: label <Symbol> position: p <{Integer. Integer}> = super StructDotAST expr: expr label: label position: p (
) (
public computeType ^ <ConcreteType> = (
  | structType = expr computeType. |
  ^structType baseType at: label ifAbsent: [Error signal: structType printString, ' does not support field ', label] 
)
) : (
)
public class StringAST value: v <String> position: p <{Integer. Integer}> = super StringAST value: v position: p (
) (
public computeType ^ <ConcreteType> = (
  ^ConcreteType dimensions: List new baseType: 'String'
)
) : (
)
public class WhereAST expr1: e1 <ExprAST> ident: id <Symbol> expr2: e2 <ExprAST> position: p <{Integer. Integer}> = super WhereAST expr1: e1 ident: id expr2: e2 position: p (
) (
public computeType ^ <ConcreteType> = (
 | 
 result  localScope = Scope new. |
  localScope at: ident putNode: expr2 computeType.
  pushScope: localScope.
  result:: expr1 computeType.
  popScope.
  ^result
)
) : (
)
class ConcreteType dimensions: ds <List[Integer | UnboundedDimension]> baseType: b <String | Integer | Map[String, ConcreteType]> = (
(*
A base type is either a string (denoting an atomic type such as 'String' or 'Boolean'), an integer (identifying a specific number, for dimensional analysis), a map from strings to concrete types  (denoting a record type) or a ShapeRank function repressented as an AST. Dimensions are runtime dimensions: either integers or the unbounded dimension (aka ?).
*)
	|
	public dimensions <List[Integer | UnboundedDimension]> = ds.
	public baseType <String | Integer | Map[String, ConcreteType] | FunctionAST> = b.
	|
) (
public rank ^ <Integer> = (
  ^dimensions size
)
public printString ^ <String> = (
  | dims ::= ''. |
  dimensions do: [:d | dims:: dims, d printString] separatedBy: [dims:: dims, ', '].
  ^'[', dims, ']'
)
public hasRank ^ <Boolean> = (
  ^true
)
public isKindOfConcreteType ^ <Boolean> = (
  (* for compatibility with tests uite *)
  ^true
)
public asTensorType ^ <TensorTypeAST> = (
  ^TensorTypeAST shape: shape type: concreteBaseTypeToTypeAST position: {0. 0}
)
public = other ^ <Boolean> = (
  other isKindOfConcreteType ifFalse: [^false]. 
  rank = other rank ifFalse: [^false].
  baseType = other baseType ifFalse: [^false]. (* make sure this works for structs *)  
  dimensions with: other dimensions do: [:d1 :d2 |  d1 = d2 ifFalse: [^false]].
  ^true
)
public hash ^ <Integer> = (
  ^dimensions hash bitXor: baseType hash
)
public addTypeVariablesTo: scope <Scope> = (
  (* do nothing. We are concrete - we have no type variables *)
)
public shape ^ <ShapeVectorAST> = (
  | 
  dims = dimensions collect: [:d | d isKindOfInteger ifTrue: [DimensionNumberAST number: d position: {0. 0}] ifFalse: [UnknownDimensionAST position: {0. 0}].].
  |
  ^ShapeVectorAST dimensions: dims position: {0. 0}
)
public isIntegral ^ <Boolean> = (
  ^baseType isKindOfInteger or: [baseType = 'Int']
)
public isNumeric ^ <Boolean> = (
  ^isIntegral or: [baseType = 'Float']
)
public concreteBaseTypeToTypeAST ^ <TypeAST> = (
  baseType isKindOfString ifTrue: [^TypeIdAST named: baseType position: {0. 0}].
  baseType isKindOfInteger ifTrue: [^DimensionNumberAST number: baseType position: {0. 0}].
  baseType isKindOfMap ifTrue: [^TypeStructAST table: (baseType collect: [:e | e asTensorType]) position: {0. 0}].
  ^baseType.
)
public greatestCommonBaseTypeWith: b <ConcreteType>  = (
  isNumeric ifTrue: [^greatestCommonNumericTypeWith: b].
  baseType isKindOfMap ifTrue: [^greatestCommonStructTypeWith: b].
  (* Return nil if no greatest common base type exists*) 
  ^baseType = b baseType ifTrue: [baseType]
)
greatestCommonStructTypeWith: b <ConcreteType> ^ <Map | Nil> = (
  (* Should only be called if the receiver's base type is a struct type *)
  (* If b's base is a struct the result will be a map; otherwise it will be nil *)  
  | result <Map | Nil> = b baseType isKindOfMap ifTrue: [Map new]. |

  result isNil ifFalse: [
    baseType keysAndValuesDo: [:k :v |
       (* The gcs will have a field only if both structs have it *)
       (b baseType includesKey: k) ifTrue: [
         | commonFieldBaseType = v greatestCommonBaseTypeWith: (b baseType at: k). |
           (* If the shapes of b and the receiver are the same and common field must itself has a gcs, the field is defined in the gcs *)
           ((v dimensionsAreEqualTo: (b baseType at: k) dimensions) and: [commonFieldBaseType isNil not]) ifTrue: [
              result at: k put: (ConcreteType dimensions: v dimensions baseType: commonFieldBaseType)]
       ].
    ].
  ].
  ^result
)
public dimensionsAreEqualTo: ds = (
  dimensions size = ds size ifFalse: [^false].
  dimensions with: ds do: [:d1 :d2 | d1 ~= d2 ifTrue: [^false]].
  ^true
)
greatestCommonNumericTypeWith: b <ConcreteType>  = (
  (* Should only be called if the receiver's base type is a numeric type *)
  (* if b is not a numeric, there is no gcs *)
  b isNumeric ifFalse: [^nil].
  baseType = 'Int' ifTrue: [
  (* if b's base type is given as a string, it must be one of {Int, Float, Num} and it dominates the receiver's base type Int.
     Otherwise b's base type and a specific number,  and Int is the gcs *)
    ^b baseType isKindOfString ifTrue: [b baseType] ifFalse: ['Int']
  ].
  baseType = 'Float' ifTrue: [
        (* If b's base is Number, it is the gcs; the receive's base type, Float, dominates any other possibility *)
        ^b baseType = 'Num' ifTrue: ['Num'] ifFalse: ['Float']
  ].
  (* Number is the gcs of all numeric types *)
  baseType = 'Num' ifTrue: [^'Num'].  
  (* The receiver's base type is a specific integer. If b's base is given as a string, it must be one of {Int, Float, Num} and it dominates the receiver's base type. *)
  b baseType isKindOfString ifTrue: [^b baseType].
  (* b's base type is also an integer. If they are the same, that is the gcs, otherwise it is Int.  *)
  ^baseType = b baseType ifTrue: [baseType] ifFalse: ['Int']
)
) : (
)
class Frame dimensions: ds <List[Integer]> cells: cs <ConcreteType> = (
(*
A frame, logically, is an array of cells of shape #dimensions. 
In the abstract interpreter, cells is just a concrete type, representing the type of an individual cell.
*)
|
	public dimensions <List[Integer]> = ds.
	public cells <ConcreteType> = cs.
|
) (
public max: t <Frame> ^ <Frame> = (
 (* should check that either my shape is a prefix of t's or vice versa *)
  dimensions size > t dimensions size ifTrue: [^self].
  ^t
)
public printString = (
  ^'Frame of rank: ', rank printString
)
public hasRank ^ <Boolean> = (
   ^true
)
public rank ^ <Integer> = (
  ^dimensions size
)
public map: f <[Object | T def]> ^ <Frame[T]> = (
  ^Frame 
        dimensions: dimensions 
        cells: (f value: cells)
)
public replicateToMatch: dims <List[Integer]> = (
  ^Frame dimensions: dims cells: cells
)
public asConcreteType ^ <ConcreteType> = (
  dimensions isEmpty ifTrue: [^cells].
  ^ConcreteType 
      dimensions: dimensions, cells dimensions 
      baseType: cells baseType
)
) : (
)
class Activation of: f <FunctionAST> from: argVector <List[ConcreteType]> = (
|
	function <FunctionAST> = f.
	public arguments <List[ConcreteType]> = argVector.
|
) (
public at: k <Symbol> ^ <ConcreteType> = (
  ^at: k ifAbsent: [Error signal: 'Undefined variable ', k]. (* should never happen in a typesafe program *)
)
public at: k <Symbol> ifAbsent: blk <[ConcreteType]> ^ <ConcreteType> = (
  1 to: function parameters size do: [:i <Integer> |
	(function parameters at: i) id = k ifTrue: [^arguments at: i]
	].
^blk value 
)
) : (
)
public class AST position: p <{Integer. Integer}> = super AST position: p (
) (
public eval = (
 (* do we really need this? *)
  ^computeType
)
public userType  ^ <TensorTypeAST> = (
  | t <TensorTypeAST> = computeType. |
  t isKindOfFunctionTypeAST ifTrue: [Error signal: 'Functions are not values unless passed to predefined HOFs' ].
  ^t asTensorType
)
) : (
)
public class FunctionAST named: n <String> parameters: ps <List[ParameterAST]> returnType: t <TensorTypeAST> body: b <ExprAST> isSync: isSync <Boolean> position: p <{Integer. Integer}>  = super FunctionAST named: n parameters: ps returnType: t body: b isSync: isSync position: p () (
computeReturnType ^ <ConcreteType> = (
  | result  <ConcreteType> |
   ^currentScope = scope
     ifTrue: [body computeType]
     ifFalse: [
       pushScope: scope.
       result:: body computeType.
       popScope.
       result
     ]
)
public returnType ^ <ConcreteType> = (
  returnTypeSlot isNil ifTrue: [
    returnTypeSlot:: computeReturnType.
    returnTypeSlot addTypeVariablesTo: scope.
  ].
  ^returnTypeSlot
)
) : (
public named: n <String> parameters: ps <List[ParameterAST]> returnType: t <TensorTypeAST> body: b <ExprAST> position: p <{Integer. Integer}> = (
  (* Convenience factory to pass default reactivity *)
  ^named: n parameters: ps returnType: t body: b isSync: false position: p 
)
)
frameArguments: args <List[ConcreteType]> of: callee <FunctionAST> ^ <List[Frame]> = (
  | argFrames <List[Frame]> = List new: args size. |
  args with: callee parameters do: [:a <ConcreteType> :p <ParameterAST> |
  argFrames add: (frameArgument: a forParameter: p)
  ].
  ^argFrames
)
computeCall: callee <FunctionAST> arguments: args <List[ConcreteType]> = (
  | 
  argFrames <List[Frame]> = frameArguments: args of: callee. (* frame *)
  maxFrame <Frame>
  replicatedFrames <List[Frame]>
  zippedFrame <Frame>
  resultFrame <Frame>
  |
(* replicate *)
  maxFrame:: argFrames reduce: [:f1 <Frame> :f2 <Frame> |
	f1 max: f2
	] ifEmpty: [emptyFrame].
  replicatedFrames:: argFrames collect: [:f <Frame> | f replicateToMatch: maxFrame dimensions].
  zippedFrame:: zipFrame: replicatedFrames. (* zip *)
(* map*)
  resultFrame:: zippedFrame map: [:argVector <List[ConcreteType]> | 
	 | result  <Frame> | 
	 pushActivation:  (Activation of: callee from: argVector).
	 result:: callee body computeType.
	 popActivation.
	 result.
	].
  ^resultFrame asConcreteType.  
)
zipFrame: l <List[Frame]> ^ <Frame>  = (
 |  
  dims <List[Integer]> = l first dimensions.
  zippedCells <List[ConcreteType]> = l collect: [:f <Frame> | f cells] .
|

 l do: [:e | e dimensions with: dims do: [:d1 :d2 | d1 = d2 ifFalse: [Error signal: 'Argument frames of varying rank']]].
  ^Frame dimensions: dims cells: zippedCells.
)
primitiveNegate ^ <FunctionAST> = (
  | 
  ps <List[ParameterAST]> = {makeNumBoundedParamNamed: #a typeVar: #T}.
  body = PrimitiveBodyAST block: [:a <ConcreteType>  | 
    a isNumeric ifFalse: [Error signal: 'non-numeric argument to operator unary -'].
    ConcreteType dimensions: {} baseType: a baseType
    ]. 
  |
  ^FunctionAST  named: #negate parameters: ps returnType: (tyVNamed: #T) asTensorType body: body position: {0. 0}
)
primitiveLog ^ <FunctionAST> = (
  | 
  ps <List[ParameterAST]> = {makeFloatParameterNamed: #v}.
  body = PrimitiveBodyAST block: [:v | 
    v baseType = 'Float' ifFalse: [Error signal: 'non-floating point argument passed to log()'].
    ConcreteType dimensions: {} baseType: 'Float'
  ].
  |
  ^FunctionAST  named: #log parameters: ps returnType: floatType asTensorType body: body position: {0. 0}
)
primitiveExp ^ <FunctionAST> = (
  | 
  ps <List[ParameterAST]> = {makeFloatParameterNamed: #v}.
  body = PrimitiveBodyAST block: [:v | 
    v baseType = 'Float' ifFalse: [Error signal: 'non-floating point argument passed to exp()'].
    ConcreteType dimensions: {} baseType: 'Float'
  ].
  |
  ^FunctionAST  named: #exp parameters: ps returnType: floatType asTensorType body: body position: {0. 0}
)
primitiveToList ^ <FunctionAST> = (
(* toList(ts: []$T): [dynamic]$T *)
  | 
  d = DimensionVariableReferenceAST named: #'$d' position: {0. 0}.
  dynamic = DynamicTypeAST position: {0. 0}.
  rs = ShapeVectorAST dimensions: {dynamic} position: {0. 0}.
  s = ShapeVectorAST dimensions: {d} position: {0. 0}.
  T = TypeVariableReferenceAST named: #T position: {0. 0}.
  t1 = TensorTypeAST shape: s type: T position: {0. 0}.
  p = ParameterAST named: #t type: t1 position: {0. 0}.
  body = PrimitiveBodyAST block: [:ts <ConcreteType> | 
      ConcreteType dimensions: {1} baseType: ts baseType
	]. 
  returnType = TensorTypeAST shape: rs type: T position: {0. 0}.
  |
  ^FunctionAST named: #toList parameters: {p} returnType: returnType body: body position: {0. 0}
)
primitiveTranspose ^ <FunctionAST> = (
(* transpose(t: @S$T):@S reversed? $T *)
  | 
  s = ShapeVariableReferenceAST named: #S position: {0. 0}.
  T = TypeVariableReferenceAST named: #T position: {0. 0}.
  t1 = TensorTypeAST shape: s type: T position: {0. 0}.
  p = ParameterAST named: #tensor type: t1 position: {0. 0}.
  body = PrimitiveBodyAST block: [:t <ConcreteType> | 
      ConcreteType dimensions: t dimensions reverse baseType: t baseType
	]. 
  returnType = TensorTypeAST shape: s type: T position: {0. 0}.
  |
  ^FunctionAST named: #transpose parameters: {p} returnType: returnType body: body position: {0. 0}
)
currentActivation ^ <Activation> = (
   ^typeCallStack last
)
pushActivation: a <Activation> = (
  typeCallStack add: a
)
popActivation = (
  typeCallStack removeLast.
)
public DimensionNumberAST ^ <DimensionNumberAST class> = (
  (* provide access for nested classes *)
  ^super DimensionNumberAST
)
public ShapeVectorAST ^ <ShapeVectorAST class> = (
  (* provide access for nested classes *)
  ^super ShapeVectorAST
)
public TypeIdAST ^ <TypeIdAST class> = (
  (* provide access for nested classes *)
  ^super TypeIdAST
)
public TypeStructAST ^ <TypeStructAST class> = (
  (* provide access for nested classes *)
  ^super TypeStructAST
)
public TensorTypeAST ^ <TensorTypeAST class> = (
  (* provide access for nested classes *)
  ^super TensorTypeAST
)
primitiveEquals ^ <FunctionAST> = (
  | 
  T = TypeVariableReferenceAST named: #T position: {0. 0}.
  s1 = ShapeVariableReferenceAST named: #S1 position: {0. 0}.
  t1 = TensorTypeAST shape: s1 type: T position: {0. 0}.
  S = TypeVariableReferenceAST named: #S position: {0. 0}.
  t2 = TensorTypeAST shape: s1 type: S position: {0. 0}.
  p1 <ParameterAST> = ParameterAST named: #p1 type: T position: {0. 0}.
  p2 <ParameterAST> = ParameterAST named: #p2 type: S position: {0. 0}.
  ps <List[ParameterAST]> = {p1. p2}.
  body = PrimitiveBodyAST block: [:x <ConcreteType> :y <ConcreteType> | 
    ConcreteType dimensions: {} baseType: 'Bool'
    ].
  |
  ^FunctionAST  named: #== parameters: ps returnType: booleanType asTensorType body: body position: {0. 0}
)
primitiveOr ^ <FunctionAST> = (
  | 
  ps <List[ParameterAST]> = {makeBoolParameterNamed: #x. makeBoolParameterNamed: #y}.
  body = PrimitiveBodyAST block: [:x <ConcreteType> :y <ConcreteType> | 
    x baseType = 'Boolean' ifFalse: [Error signal: 'invalid first parameter for or()'].
    y baseType = 'Boolean' ifFalse: [Error signal: 'invalid second parameter for or()'].
    ConcreteType dimensions: {} baseType: 'Bool']. 
  |
  ^FunctionAST  named: #or parameters: ps returnType: booleanType asTensorType body: body position: {0. 0}
)
primitiveShapeOf ^ <FunctionAST> = (
(* shapeOf(t: @S $T): @S *)
  | 
  s = ShapeVariableReferenceAST  named: #S position: {0. 0}.
  T = TypeVariableReferenceAST named: #T position: {0. 0}.
  t = TensorTypeAST shape: s type: T position: {0. 0}.
  ps <List[ParameterAST]> = {ParameterAST named: #t type: t position: {0. 0}}.
  body = PrimitiveBodyAST block: [:tensor | 
	ConcreteType dimensions: {tensor rank} baseType: 'Int'
	]. 
  |
  ^FunctionAST  named: #shapeOf parameters: ps returnType: s body: body position: {0. 0}
)
primitiveMask = (
(* mask (m: [$d1]Bool, v: [$d1]$T): [dynamic]$T *)
|
  d1 = DimensionVariableReferenceAST named: #d1 position: {0. 0}.
  d2 = DynamicTypeAST position: {0. 0}.
  T = TypeVariableReferenceAST named: #T position: {0. 0}.
  s = ShapeVectorAST dimensions: {d1} position: {0. 0}.
  rs = ShapeVectorAST dimensions: {d2} position: {0. 0}.
  t1 = TensorTypeAST shape: s type: booleanType position: {0. 0}.
  t2 = TensorTypeAST shape: s type: T position: {0. 0}.
  p1 = ParameterAST named: #m type: t1 position: {0. 0}.
  p2 = ParameterAST named: #v type: t2 position: {0. 0}.
  ps <List[ParameterAST]> = {p1. p2}.
  body = PrimitiveBodyAST block: [:mask :v | 
	ConcreteType dimensions: {dynamic}  baseType: v baseType
	].
  returnType = TensorTypeAST shape: rs type: T position: {0. 0}.
|
  ^FunctionAST  named: #mask parameters: ps returnType: returnType body: body position: {0. 0}
)
primitiveGt ^ <FunctionAST> = (
  | 
  T = TypeVariableReferenceAST named: #T position: {0. 0}.
  S = TypeVariableReferenceAST named: #S position: {0. 0}.
  p1 <ParameterAST> = ParameterAST named: #p1 type: T position: {0. 0}.
  p2 <ParameterAST> = ParameterAST named: #p2 type: S position: {0. 0}.
  ps <List[ParameterAST]> = {p1. p2}.
  body = PrimitiveBodyAST block: [:a <ConcreteType> :b <ConcreteType> | 
   a isNumeric
     ifTrue: [b isNumeric ifFalse: [Error signal: 'incompatibly typed arguments for >']]
     ifFalse: [
       a baseType = b baseType 
          ifFalse: [Error signal: 'incompatibly typed arguments for >']
       ].
    ConcreteType dimensions: {} baseType: 'Bool'
    ].
  |
  ^FunctionAST  named: #> parameters: ps returnType: booleanType asTensorType body: body position: {0. 0}
)
primitiveLt ^ <FunctionAST> = (
  |
  T = TypeVariableReferenceAST named: #T position: {0. 0}.
  S = TypeVariableReferenceAST named: #S position: {0. 0}.
  p1 <ParameterAST> = ParameterAST named: #p1 type: T position: {0. 0}.
  p2 <ParameterAST> = ParameterAST named: #p2 type: S position: {0. 0}.
  ps <List[ParameterAST]> = {p1. p2}.
  body = PrimitiveBodyAST block: [:a <ConcreteType> :b <ConcreteType> | 
   a isNumeric
     ifTrue: [b isNumeric ifFalse: [Error signal: 'incompatibly typed arguments for <']]
     ifFalse: [
       a baseType = b baseType 
          ifFalse: [Error signal: 'incompatibly typed arguments for <']
       ].  
    ConcreteType dimensions: {} baseType: 'Bool'
    ].
  |
  ^FunctionAST  named: #< parameters: ps returnType: booleanType asTensorType body: body position: {0. 0}
)
primitiveLeq ^ <FunctionAST> = (
  | 
  T = TypeVariableReferenceAST named: #T position: {0. 0}.
  S = TypeVariableReferenceAST named: #S position: {0. 0}.
  p1 <ParameterAST> = ParameterAST named: #p1 type: T position: {0. 0}.
  p2 <ParameterAST> = ParameterAST named: #p2 type: S position: {0. 0}.
  ps <List[ParameterAST]> = {p1. p2}.
  body = PrimitiveBodyAST block: [:a <ConcreteType> :b <ConcreteType> | 
   a isNumeric
     ifTrue: [b isNumeric ifFalse: [Error signal: 'incompatibly typed arguments for <=']]
     ifFalse: [
       a baseType = b baseType 
          ifFalse: [Error signal: 'incompatibly typed arguments for <=']
       ].
    ConcreteType dimensions: {} baseType: 'Bool'
    ].
  |
  ^FunctionAST  named: #<= parameters: ps returnType: booleanType asTensorType body: body position: {0. 0}
)
primitiveGeq ^ <FunctionAST> = (
(* >= (p1: $T, p2: $S): Boolean*)
  | 
  T = TypeVariableReferenceAST named: #T position: {0. 0}.
  S = TypeVariableReferenceAST named: #S position: {0. 0}.
  p1 <ParameterAST> = ParameterAST named: #p1 type: T position: {0. 0}.
  p2 <ParameterAST> = ParameterAST named: #p2 type: S position: {0. 0}.
  ps <List[ParameterAST]> = {p1. p2}.
  body = PrimitiveBodyAST block: [:a :b | 
   a isNumeric
     ifTrue: [b isNumeric ifFalse: [Error signal: 'incompatibly typed arguments for >=']]
     ifFalse: [
       a baseType = b baseType 
          ifFalse: [Error signal: 'incompatibly typed arguments for >=']
       ].   
  ConcreteType dimensions: {} baseType: 'Bool'
    ].
  |
  ^FunctionAST  named: #>= parameters: ps returnType: booleanType asTensorType body: body position: {0. 0}
)
public UnknownDimensionAST ^ <UnboundedDimensionAST class> = (
  (* provide access for nested classes *)
  ^super UnknownDimensionAST
)
dynamic = (
  (* For now, subtleties between dynamic and ? are ignored *)
  #BOGUS.
  ^unboundedDimension
)
frameArgument: arg <ConcreteType> forParameter: p <ParameterAST> ^ <Frame> = (
  p hasRank ifFalse: [
	^Frame dimensions: {} cells: arg.
	].
  arg rank >= p rank ifTrue: [ 
	| 
	fdims <List[Integer | UnboundedDimension]> = arg dimensions copyFrom: 1 to: arg rank - p rank.
	cdims <List[Integer | UnboundedDimension]> = arg dimensions copyFrom: arg rank - p rank + 1 to: arg rank. 
    |
	^Frame dimensions: fdims cells:  (ConcreteType dimensions: cdims baseType: arg baseType)
	].
   ^Error signal: 'Rank of actual argument ' , arg printString, '(', arg rank printString, ') is less than rank of formal parameter ', p id, ' (', p rank printString, ')'.
)
primitivePlus ^ <FunctionAST> = (
  | 
  ps <List[ParameterAST]> = {makeNumBoundedParamNamed: #a typeVar: #T.
                             makeParamNamed: #b typeVar: #T}.
  body = PrimitiveBodyAST block:  [:x <ConcreteType> :y <ConcreteType> | 
    |  baseType = commonNumericBaseTypeFor: x and: y. |  
    x isNumeric ifFalse: [Error signal: 'invalid first parameter passed to +'].
    y isNumeric ifFalse: [Error signal: 'invalid second parameter passed to +'].
    ConcreteType dimensions: {} baseType: baseType
    ].
  |
  ^FunctionAST  named: #+ parameters: ps returnType: (tyVNamed: #T) asTensorType body: body position: {0. 0}
)
primitiveTimes ^ <FunctionAST> = (
  | 
  ps <List[ParameterAST]> = {makeNumBoundedParamNamed: #a typeVar: #T.
                             makeParamNamed: #b typeVar: #T}.
  body = PrimitiveBodyAST block: [:x <ConcreteType> :y <ConcreteType> | 
    |  baseType = commonNumericBaseTypeFor: x and: y. |
    x isNumeric ifFalse: [Error signal: 'invalid first parameter passed to * '].
    y isNumeric ifFalse: [Error signal: 'invalid second parameter passed to *'].
    ConcreteType dimensions: {} baseType: baseType
    ].  
  |
  ^FunctionAST  named: #* parameters: ps returnType: (tyVNamed: #T) asTensorType body: body position: {0. 0}
)
primitiveModulus ^ <FunctionAST> = (
  | 
  ps <List[ParameterAST]> = {makeIntParameterNamed: #a. makeIntParameterNamed: #b}.
  body = PrimitiveBodyAST block:  [:x <ConcreteType> :y <ConcreteType> | 
    x isIntegral ifFalse: [Error signal: 'non-integer first parameter passed to %'].
    y isIntegral ifFalse: [Error signal: 'non-integer second parameter passed to %'].
    ConcreteType dimensions: {} baseType: 'Integer'
    ].
  |
  ^FunctionAST  named: #% parameters: ps returnType: integerType asTensorType body: body position: {0. 0}
)
primitiveLength ^ <FunctionAST> = (
(* length(v: [$d]$T): $d *)
  | 
  d = DimensionVariableReferenceAST named: #d position: {0. 0}.
  T = TypeVariableReferenceAST named: #T position: {0. 0}.
  s = ShapeVectorAST dimensions: {d} position: {0. 0}.
  t = TensorTypeAST shape: s type: T position: {0. 0}.
  ps <List[ParameterAST]> = {ParameterAST named: #v type: t position: {0. 0}}.
  body = PrimitiveBodyAST block: [:v <ConcreteType> | 
	ConcreteType dimensions: {} baseType: 'Int' (* make this precise? v dimensions first? *)
	]. 
  |
  ^FunctionAST  named: #length parameters: ps returnType: d body: body position: {0. 0}
)
primitiveMinus ^ <FunctionAST> = (
  | 
  ps <List[ParameterAST]> = {makeNumBoundedParamNamed: #a typeVar: #T.
                             makeParamNamed: #b typeVar: #T}.
  body = PrimitiveBodyAST block:  [:x <ConcreteType> :y <ConcreteType> | 
    |  baseType = commonNumericBaseTypeFor: x and: y. | 
    x isNumeric ifFalse: [Error signal: 'invalid first parameter passed to -'].
    y isNumeric ifFalse: [Error signal: 'invalid second parameter passed to -'].
    ConcreteType dimensions: {} baseType: baseType
    ].
  |
  ^FunctionAST  named: #- parameters: ps returnType: (tyVNamed: #T) asTensorType body: body position: {0. 0}
)
public FunctionTypeAST ^ <FunctionTypeAST class> = (
  (* provide access for nested classes *)
  ^super FunctionTypeAST
)
commonNumericBaseTypeFor: x and: y = (
  | xt = x baseType. yt = y baseType. |
  xt = yt ifTrue: [^yt].
  (xt = 'Float' or: [yt = 'Float']) ifTrue: [^'Float'].
  ^'Int'
)
primitiveInnerProduct ^ <FunctionAST> = (
(* 
innerProduct(a: @X:: [$n]$T, b: [$n]::@Y$S,  f: $R -> $R -> $Q $, g: $T -> $S -> $R): @X::@Y$Q
*)
  | 
  T = TypeVariableReferenceAST named: #T position: {0. 0}.
  S = TypeVariableReferenceAST named: #S position: {0. 0}.
  R = TypeVariableReferenceAST named: #R position: {0. 0}.
  Q = TypeVariableReferenceAST named: #Q position: {0. 0}.
  F <FunctionAST> = alpha: R toBeta: R toGamma: Q.
  G <FunctionAST> = alpha: T toBeta: S toGamma: R.
  s1 = ShapeVariableReferenceAST named: #X position: {0. 0}.
  s2 = ShapeVariableReferenceAST named: #Y position: {0. 0}.
  n = DimensionVariableReferenceAST named: #n position: {0. 0}.
  commonDim = ShapeVectorAST dimensions: {n} position: {0. 0}.
  sv1 = ShapeAppendAST shape: s1 to: commonDim  position: {0. 0}.
  sv2 = ShapeAppendAST shape: commonDim to: s2  position: {0. 0}.
  rs = ShapeAppendAST shape: s1 to: s2  position: {0. 0}.
  t1 = TensorTypeAST shape: sv1 type: T position: {0. 0}.
  t2 = TensorTypeAST shape: sv2 type: S position: {0. 0}.
  p1 = ParameterAST named: #a type: t1 position: {0. 0}.
  p2 = ParameterAST named: #b type: t2 position: {0. 0}.
  p3 = ParameterAST named: #f type: F asTensorType position: {0. 0}.
  p4 = ParameterAST named: #g type: G asTensorType position: {0. 0}.
  ps <List[ParameterAST]> = {p1. p2. p3. p4}.
  body = PrimitiveBodyAST block: [:a :b :f :g |  
  | r q |
    (* get scalar version of base types from a and b, feed them to a call of g, get result type R *)
	 pushActivation:  (Activation of: g baseType from: {ConcreteType dimensions: {} baseType: a baseType. ConcreteType dimensions: {} baseType: b baseType}).
	 r:: g baseType body computeType.
	 popActivation.   
     (* Feed two copies of R into f to get Q. *)
	 pushActivation:  (Activation of: f baseType from: {r. r}).
	 q:: f baseType body computeType baseType.
	 popActivation.
     (* Peel last dim off of dims of a and first dim off of dims of b to get X & Y *)
	ConcreteType dimensions: (a dimensions copyFrom: 1 to: a dimensions size -1), (b dimensions copyFrom: 2 to: b dimensions size)
	            baseType: q
	]. 
   returnType = TensorTypeAST shape: rs type: Q position: {0. 0}.
  |
  ^FunctionAST named: #innerProduct parameters: ps returnType: returnType body: body position: {0. 0}  
)
primitiveArgmax ^ <FunctionAST> = (
(* argmax(v: [$d]$T): Int *)
  |
  d = DimensionVariableReferenceAST named: #d position: {0. 0}.
  T = TypeVariableReferenceAST named: #T position: {0. 0}.
  s = ShapeVectorAST dimensions: {d} position: {0. 0}.
  t = TensorTypeAST shape: s type: T position: {0. 0}.
  ps <List[ParameterAST]> = {ParameterAST named: #v type: t position: {0. 0}}.
  body = PrimitiveBodyAST block: [:v <ConcreteType> |
    v rank = 1 ifFalse: [Error signal: 'Argmax requires argument of rank > 1'].
    ConcreteType dimensions: {} baseType: 'Int'
  ].
  |
  ^FunctionAST named: #argmax parameters: ps returnType: integerType asTensorType body: body position: {0. 0}
)
primitiveRange ^ <FunctionAST> = (
(* range(start: $d1, end: $d1 + $d2): [$d2 + 1]Int *)
  | 
  d1 = DimensionVariableReferenceAST named: #d1 position: {0. 0}.
  d2 = DimensionVariableReferenceAST named: #d2 position: {0. 0}.
  dsum1 = DimensionSumAST of: d1 and: d2 position: {0. 0}.
  n1 = DimensionNumberAST number: 1 position: {0. 0}.
  dsum2 = DimensionSumAST of: d2 and: n1 position: {0. 0}.
  s = ShapeVectorAST dimensions: {dsum2} position: {0. 0}.
  t = TensorTypeAST shape: s type: integerType position: {0. 0}.
  start = ParameterAST named: #start type: d1 asTensorType position: {0. 0}.
  end = ParameterAST named: #end type: dsum1 asTensorType position: {0. 0}.
  ps <List[ParameterAST]> = {start. end}.
  body = PrimitiveBodyAST block: [:i :j | 
    | 
    minRange = i baseType. 
    maxRange = j baseType. 
    size = (minRange isKindOfInteger and: [maxRange isKindOfInteger]) 
      ifTrue: [maxRange - minRange + 1]
      ifFalse: [dynamic].
    |
    i isIntegral ifFalse: [Error signal: 'Non-integral first argument to ..'].    
    j isIntegral ifFalse: [Error signal: 'Non-integral second argument to ..'].
	ConcreteType dimensions: {size} baseType: 'Int'
	]. 
  |
  ^FunctionAST  named: '..' parameters: ps returnType: t body: body position: {0. 0}
)
primitiveNot ^ <FunctionAST> = (
  | 
  ps <List[ParameterAST]> = {makeBoolParameterNamed: #x}.
  body = PrimitiveBodyAST block: [:x <ConcreteType> | 
    x baseType = 'Bool' ifFalse: [Error signal: 'non-boolean argument to not()'].
    ConcreteType dimensions: {} baseType: 'Bool'
    ]. 
  |
  ^FunctionAST  named: #not parameters: ps returnType: booleanType asTensorType body: body position: {0. 0}
)
primitiveApply ^ <FunctionAST> = (
(* apply(f: @R$X -> @S$Y, x: @R$X): @S$Y *)
  | 
  R = ShapeVariableReferenceAST named: #R position: {0. 0}.
  S = ShapeVariableReferenceAST named: #S position: {0. 0}.
  X = TypeVariableReferenceAST named: #X position: {0. 0}.
  Y = TypeVariableReferenceAST named: #Y position: {0. 0}.
  RX = TensorTypeAST shape: R type: X position: {0. 0}.
  SY = TensorTypeAST shape: S type: Y position: {0. 0}.
  F = alpha: RX toBeta: SY.
  p1 = ParameterAST named: #f type: F asTensorType position: {0. 0}.
  p2 = ParameterAST named: #x type: RX asTensorType position: {0. 0}.
  rt = SY asTensorType.
  body = PrimitiveBodyAST block: [:f <ConcreteType> :x <ConcreteType> |
        | result <ConcreteType> |
       (*check that f is applicable to x *)
  	   pushActivation:  (Activation of: f baseType from: {x}).
	   result:: f baseType body computeType.
	   popActivation.
       result    
    ].
  |
  ^FunctionAST named: #apply parameters: {p1. p2} returnType: rt body: body position: {0. 0}
)
primitiveAnd ^ <FunctionAST> = (
  | 
  ps <List[ParameterAST]> = {makeBoolParameterNamed: #x. makeBoolParameterNamed: #y}.
  body = PrimitiveBodyAST block: [:x <ConcreteType> :y <ConcreteType> | 
    x baseType = 'Bool' ifFalse: [Error signal: 'invalid firest parameter for and()'].
    y baseType = 'Bool' ifFalse: [Error signal: 'invalid second parameter for and()'].
    ConcreteType dimensions: {} baseType: 'Bool'
    ]. 
  |
  ^FunctionAST  named: #and parameters: ps returnType: booleanType asTensorType body: body position: {0. 0}
)
primitivePower ^ <FunctionAST> = (
  | 
  ps <List[ParameterAST]> = {makeIntParameterNamed: #a. makeIntParameterNamed: #b}.
  body = PrimitiveBodyAST block: [:x <ConcreteType> :y <ConcreteType> | 
    x isIntegral ifFalse: [Error signal: 'non-integer first parameter passed to power()'].
    y isIntegral ifFalse: [Error signal: 'non-integer second parameter passed to power()'].
    ConcreteType dimensions: {} baseType: 'Integer'
    ]. 
  |
  ^FunctionAST  named: #power parameters: ps returnType: integerType asTensorType body: body position: {0. 0}
)
primitiveAppend ^ <FunctionAST> = (
(*  append(a: [$d1]::@S $T, b: [$d2]::@S $T):[$d1 + $d2]::@S $T *)
  | 
  d1 = DimensionVariableReferenceAST named: #d1 position: {0. 0}.
  d2 = DimensionVariableReferenceAST named: #d2 position: {0. 0}.
  rdim = DimensionSumAST of: d1 and: d2 position: {0. 0}.
  S = ShapeVariableReferenceAST named: #S position: {0. 0}.
  T = TypeVariableReferenceAST named: #T position: {0. 0}.
  sv1 = ShapeVectorAST dimensions: {d1} position: {0. 0}.
  s1 = ShapeAppendAST shape: sv1 to: S  position: {0. 0}.
  sv2 = ShapeVectorAST dimensions: {d2} position: {0. 0}.
  s2 = ShapeAppendAST shape: sv2 to: S  position: {0. 0}.
  rv = ShapeVectorAST dimensions: {rdim} position: {0. 0}.
  rshape = ShapeAppendAST shape: rv to: S position: {0. 0}.
  t1 = TensorTypeAST shape: s1 type: T position: {0. 0}.
  t2 = TensorTypeAST shape: s2 type: T position: {0. 0}.
  p1 = ParameterAST named: #a type: t1 position: {0. 0}.
  p2 = ParameterAST named: #b type: t2 position: {0. 0}.
  ps <List[ParameterAST]> = {p1. p2}.
  body = PrimitiveBodyAST block: [:a :b | | gcs = a greatestCommonBaseTypeWith: b.  |
    (* verify base type $T is the well defined *)
    gcs isNil ifTrue: [Error signal: 'incompatible element types in call to append()'].
    (* verify $S is the same *)
   2 to: a dimensions size do: [:i <Integer> | (a dimensions at: i) = (b dimensions at: i)].
	ConcreteType dimensions: {(a dimensions at: 1) + (b dimensions at: 1)}, (a dimensions copyFrom: 2 to: a dimensions size) 
	            baseType:  gcs
	]. 
  returnType = TensorTypeAST shape: rshape type: T position: {0. 0}.
  |
  ^FunctionAST named: #append parameters: ps returnType: returnType body: body position: {0. 0}  
)
primitiveDivide ^ <FunctionAST> = (
  | 
  ps <List[ParameterAST]> = {makeNumBoundedParamNamed: #a typeVar: #T.
                             makeParamNamed: #b typeVar: #T}.
  body = PrimitiveBodyAST block: [:x <ConcreteType> :y <ConcreteType> | 
    x isNumeric ifFalse: [Error signal: 'invalid first parameter passed to / '].
    y isNumeric ifFalse: [Error signal: 'invalid second parameter passed to /'].
    ConcreteType dimensions: {} baseType: 'Num'
    ]. 
  |
  ^FunctionAST  named: #/ parameters: ps returnType: floatType asTensorType asTensorType body: body position: {0. 0}
)
primitiveIota ^ <FunctionAST> = (
(* iota(n: $d): [$d]Int *)
  | 
  d = DimensionVariableReferenceAST named: #d position: {0. 0}.
  ps <List[ParameterAST]> = {ParameterAST named: #n type: d position: {0. 0}.}.
  body = PrimitiveBodyAST block: [:n | 
    | size  = n baseType isKindOfInteger ifTrue: [n baseType] ifFalse: [dynamic]. |
    n isIntegral ifFalse: [Error signal: 'non-integer argument to iota()'].
	ConcreteType dimensions: {size} baseType: 'Int'
	]. 
   returnType = integerVectorTypeOfLength: d.
  |
  ^FunctionAST  named: #iota parameters: ps returnType: returnType body: body position: {0. 0}
)
primitiveRotate ^ <FunctionAST> = (
(*  rotate(t: @S $T, n: Int): @S $T *)
  | 
  S = ShapeVariableReferenceAST named: #S position: {0. 0}.
  T = TypeVariableReferenceAST named: #T position: {0. 0}.
  t1 = TensorTypeAST shape: S type: T position: {0. 0}.
  p1 = ParameterAST named: #t type: t1 position: {0. 0}.
  p2 = ParameterAST named: #n type: integerType position: {0. 0}.
  ps <List[ParameterAST]> = {p1. p2}.
  body = PrimitiveBodyAST block: [:t :n | 
    n isIntegral ifFalse: [Error signal: 'non-integer second argument to rotate()']. 
 	ConcreteType dimensions: t dimensions 
	            baseType:  t baseType
	]. 
  returnType = TensorTypeAST shape: S type: T position: {0. 0}.
  |
  ^FunctionAST named: #rotate parameters: ps returnType: returnType body: body position: {0. 0}  
)
primitiveIf  ^ <FunctionAST> = (
(* if(c: Bool, t: $T, e: $T): $T *)
  | 
  T = TypeVariableReferenceAST named: #T position: {0. 0}.
  p1 <ParameterAST> = makeBoolParameterNamed: #c. 
  unitToT <FunctionAST> = unitTo: T.
  p2 <ParameterAST> = ParameterAST named: #t type: unitToT position: {0. 0}.
  p3 <ParameterAST> = ParameterAST named: #e type: unitToT position: {0. 0}.
  ps <List[ParameterAST]> = {p1. p2. p3}.
  body = PrimitiveBodyAST block: [:c :t :e | 
    | 
    thenType = t baseType returnType.
    elseType = e baseType returnType.
    gcs =  thenType greatestCommonBaseTypeWith: elseType.
    |
    c baseType = 'Bool' ifFalse: [Error signal: 'Non-boolean condition in if expression'].
     thenType rank = elseType rank ifFalse: [Error signal: 'Branches of if expression have different ranks'].
     thenType dimensions with: elseType dimensions do: [:d1 :d2 |
      d1 = d2 ifFalse: [Error signal: 'Branches of if expression have different dimensions']].
     gcs isNil ifTrue: [Error signal: 'Branches of if expression have different element types'].
     ConcreteType dimensions: thenType dimensions baseType: gcs
	]. 
  |
  
  ^FunctionAST named: #if parameters: ps returnType: T body: body position: {0. 0} 
)
primitiveContains ^ <FunctionAST> = (
  (* contains(v: @S$T, x: $T): Bool *)
|
  T = TypeVariableReferenceAST named: #T position: {0. 0}.
  S = ShapeVariableReferenceAST  named: #S position: {0. 0}.
  t1 = TensorTypeAST shape: S type: T position: {0. 0}.
  p1 = ParameterAST named: #v type: t1 position: {0. 0}.
  p2 = ParameterAST named: #x type: T asTensorType position: {0. 0}.
  ps <List[ParameterAST]> = {p1. p2}.
  body = PrimitiveBodyAST block: [:tensor :element | 
    | gcs =  tensor greatestCommonBaseTypeWith: element. |
  (* should we change signature so we do not care about base types? *)
      gcs isNil ifTrue: [Error signal: 'hyperstream base type incompatible element type in call to contains()'].
      ConcreteType dimensions: {} baseType: 'Bool'
	].
|
  ^FunctionAST  named: #contains parameters: ps returnType: booleanType asTensorType body: body position: {0. 0}
)
primitiveReduce ^ <FunctionAST> = (
(*  reduce(f: @S $T->@S $T->@S $T, acc: @S $T, x:[]::@R::@S $T): @R::@S $T *)
  | 
  d3 = DimensionVariableReferenceAST named: #d3 position: {0. 0}.
  T = TypeVariableReferenceAST named: #T position: {0. 0}.
  S = ShapeVariableReferenceAST named: #S position: {0. 0}.
  R = ShapeVariableReferenceAST named: #R position: {0. 0}. 
  t2 = TensorTypeAST shape: S type: T position: {0. 0}.
  F <FunctionAST> = reducibleFunction_s.
  s2 = ShapeAppendAST shape: R to: S  position: {0. 0}.
  sv3 = ShapeVectorAST dimensions: {d3} position: {0. 0}.  
  s3 = ShapeAppendAST shape: sv3 to: s2  position: {0. 0}.
  t3 = TensorTypeAST shape: s3 type: T position: {0. 0}.
  p1 = ParameterAST named: #f type: F asTensorType position: {0. 0}.
  p2 = ParameterAST named: #acc type: t2 position: {0. 0}.
  p3 = ParameterAST named: #x type: t3 position: {0. 0}.
  ps <List[ParameterAST]> = {p1. p2. p3}.
  rt = TensorTypeAST shape: s2 type: T position: {0. 0}.
  body = PrimitiveBodyAST block: [:f :acc :x |  
    | 
    result 
    gcs = acc greatestCommonBaseTypeWith: x.
    arg = ConcreteType dimensions: acc dimensions baseType: gcs.
    |
    (* no need to check that x is of rank > 0. Call semantics ensure that *)
    gcs isNil ifTrue: [Error signal: 'Tensor and accumulator parameters disagree in reduce'].
  (*check that f is applicable to its arguments *)
  	 pushActivation:  (Activation of: f baseType from: {arg. arg}).
	 result:: f baseType body computeType.
     result = arg ifFalse: [Error signal: 'reduce'].
     (* Also need to verify that x dimensions has a tail that matches acc dimensions *)
	 popActivation.
    ConcreteType dimensions: (x dimensions copyFrom: 2 to: x rank), acc dimensions baseType: gcs
	]. 
  |
  ^FunctionAST  named: #reduce parameters: ps returnType: rt asTensorType body: body position: {0. 0}  
)
primitiveScan ^ <FunctionAST> = (
(*  scan(f: @S $T-> @S $T-> @S $T, acc: @S $T, x:[d]::@R::@S $T):[d]::@R::@S $T *)
  | 
  d = DimensionVariableReferenceAST named: #d position: {0. 0}.
  F <FunctionAST> = reducibleFunction_s.
  T = TypeVariableReferenceAST named: #T position: {0. 0}.
  S = ShapeVariableReferenceAST named: #S position: {0. 0}.
  R = ShapeVariableReferenceAST named: #R position: {0. 0}. 
  t2 = TensorTypeAST shape: S type: T position: {0. 0}. 
  s2 = ShapeAppendAST shape: R to: S  position: {0. 0}.  
  sv3 = ShapeVectorAST dimensions: {d} position: {0. 0}.
  s3 = ShapeAppendAST shape: sv3 to: s2  position: {0. 0}.  
  t3 = TensorTypeAST shape: s3 type: T position: {0. 0}.
  p1 = ParameterAST named: #f type: F asTensorType position: {0. 0}.
  p2 = ParameterAST named: #acc type: t2 position: {0. 0}.
  p3 = ParameterAST named: #x type: t3 position: {0. 0}.
  ps <List[ParameterAST]> = {p1. p2. p3}.
  body = PrimitiveBodyAST block: [:f :acc :x |
    | 
    result 
    gcs = acc greatestCommonBaseTypeWith: x.
    arg = ConcreteType dimensions: acc dimensions baseType: gcs.    
    |
   (* no need to check that x is of rank > 0. Call semantics ensure that *)
    gcs isNil ifTrue: [Error signal: 'Tensor and accumulator parameters disagree in scan'].
  (*check that f is applicable to its arguments *)
  	 pushActivation:  (Activation of: f baseType from: {arg. arg}).
	 result:: f baseType body computeType.
     result = arg ifFalse: [Error signal: 'Function and accumulator parameters disagree in scan'].
     (* Also need to verify that x dimensions has a tail that matches acc dimensions *)
	 popActivation.
     ConcreteType dimensions: x dimensions, acc dimensions baseType: gcs    
	]. 
  |
  ^FunctionAST  named: #scan parameters: ps returnType: t3 body: body position: {0. 0}  
)
primitiveFold ^ <FunctionAST> = (
(*  fold(f: @P$T->@Q$S->@P$T, acc: @P$T, x:[$d]::@R::@Q $S): @R::@P $T *)
  |
  P = ShapeVariableReferenceAST named: #P position: {0. 0}.
  Q = ShapeVariableReferenceAST named: #Q position: {0. 0}.
  T = TypeVariableReferenceAST named: #T position: {0. 0}.
  S = TypeVariableReferenceAST named: #S position: {0. 0}.
  PT = TensorTypeAST shape: P type: T position: {0. 0}.
  QS = TensorTypeAST shape: Q type: S position: {0. 0}.
  F <FunctionAST> = alpha: PT toBeta: QS toGamma: PT.
  R = ShapeVariableReferenceAST named: #R position: {0. 0}.
  dx = DimensionVariableReferenceAST named: #d position: {0. 0}.
  sdx = ShapeVectorAST dimensions: {dx} position: {0. 0}.
  RQ = ShapeAppendAST shape: R to: Q position: {0. 0}.
  dxRQ = ShapeAppendAST shape: sdx to: RQ position: {0. 0}.
  tx = TensorTypeAST shape: dxRQ type: S position: {0. 0}.
  p1 = ParameterAST named: #f type: F asTensorType position: {0. 0}.
  p2 = ParameterAST named: #acc type: PT asTensorType position: {0. 0}.
  p3 = ParameterAST named: #x type: tx position: {0. 0}.
  ps <List[ParameterAST]> = {p1. p2. p3}.
  RP = ShapeAppendAST shape: R to: P position: {0. 0}.
  rt = TensorTypeAST shape: RP type: T position: {0. 0}.
  body = PrimitiveBodyAST block: [:f :acc :x |  
    | 
    result 
    fun = f baseType.
    fx = (frameArgument: x forParameter: (fun parameters last)) cells.
    gcs = fx greatestCommonBaseTypeWith: x. 
    arg = ConcreteType dimensions: acc dimensions baseType: gcs. 
    | 
  (*check that f is applicable to acc & (properly framed) x *)
  	 pushActivation:  (Activation of: fun from: {arg. fx}).
	 result:: fun body computeType.
     result = arg ifFalse: [Error signal: 'Function and accumulator parameters disagree in fold'].
     (* Also need to verify that x dimensions has a tail that matches acc dimensions *)
	 popActivation.
      ConcreteType dimensions: (x dimensions copyFrom: 2 to: x rank), acc dimensions baseType: result baseType
    ].
  |
  ^FunctionAST named: #fold parameters: ps returnType: rt asTensorType body: body position: {0. 0}  
)
primitiveGradientDescent ^ <FunctionAST> = (
(* gradient_descent(lr: Float, loss: $T -> [$d]$S -> Float, initialParams: $T <: {}, otherParams: [$d]$S): $T*)
  | T = TypeVariableReferenceAST named: #T position: {0. 0}.
    emptyStructType = TypeStructAST table: (Map new) position: {0. 0}.
    boundedT = BoundedTypeAST base: T bound: emptyStructType position: {0. 0}.
    d = DimensionVariableReferenceAST named: #d position: {0. 0}.
    s = ShapeVectorAST dimensions: {d} position: {0. 0}.
    S = TypeVariableReferenceAST named: #S position: {0. 0}.
    dS = TensorTypeAST shape: s type: S position: {0. 0}.
    F <FunctionAST> = alpha: T toBeta: dS toGamma: floatType.
    p1 = ParameterAST named: #lr type: floatType position: {0. 0}.
    p2 = ParameterAST named: #loss type: F position: {0. 0}.
    p3 = ParameterAST named: #initialParams type: boundedT position: {0. 0}.
    p4 = ParameterAST named: #otherParams type: dS position: {0. 0}.
    ps <List[ParameterAST]> = {p1. p2. p3. p4}.
    rt = T.
    body = PrimitiveBodyAST block: [:lr :loss :params :otherParams |
      | gcs = params greatestCommonBaseTypeWith: otherParams. |
      
      lr baseType = 'Float' ifFalse: [Error signal: 'Non-floating point first argument to gradientDescent()'].      
      params baseType isKindOfMap ifFalse: [Error signal].
      gcs isNil ifTrue: [Error signal: 'Second and third parameters to gradientDescent are of mismatched types'].
      pushActivation:  (Activation of: loss baseType from: {params. otherParams}).
      loss baseType body computeType baseType = 'Float' ifFalse: [Error signal: 'loss function must return a Float in gradientDescent()']
	  popActivation.      
      ConcreteType dimensions: {} baseType: gcs
    ].
  |
  ^FunctionAST named: #gradientDescent parameters: ps returnType: rt body: body position: {0. 0}
)
primitiveOuterProduct ^ <FunctionAST> = (
(*  outerProduct(f: @S1 $T1 -> @S2 T2 -> @S3 $T3, a: [d1]::@S4::@S1 $T1, b: [d2]::@S5::@S2 $T2): [d1]::@S4::[d2]::@S5::@S3 $T3 *)
  | 
  T1 = TypeVariableReferenceAST named: #T1 position: {0. 0}.
  T2 = TypeVariableReferenceAST named: #T2 position: {0. 0}.
  T3 = TypeVariableReferenceAST named: #T3 position: {0. 0}.
  s1 = ShapeVariableReferenceAST named: #S1 position: {0. 0}.
  s2 = ShapeVariableReferenceAST named: #S2 position: {0. 0}.
  s3 = ShapeVariableReferenceAST named: #S3 position: {0. 0}.
  tpf1 = TensorTypeAST shape: s1 type: T1 position: {0. 0}.  
  tpf2 = TensorTypeAST shape: s2 type: T2 position: {0. 0}.
  tpf3 = TensorTypeAST shape: s3 type: T3 position: {0. 0}.
  F <FunctionAST> = alpha: tpf1 toBeta: tpf2 toGamma: tpf3.
  d1 = DimensionVariableReferenceAST named: #d1 position: {0. 0}.
  d2 = DimensionVariableReferenceAST named: #d2 position: {0. 0}.
  sv1 = ShapeVectorAST dimensions: {d1} position: {0. 0}.  
  sv2 = ShapeVectorAST dimensions: {d2} position: {0. 0}.
  s4 = ShapeVariableReferenceAST named: #S4 position: {0. 0}.
  s5 = ShapeVariableReferenceAST named: #S5 position: {0. 0}.
  sa1 = ShapeAppendAST shape: sv1 to: s4 position: {0. 0}.
  as = ShapeAppendAST shape: sa1 to: s1 position: {0. 0}.
  sa2 = ShapeAppendAST shape: sv2 to: s5 position: {0. 0}.
  bs = ShapeAppendAST shape: sa2 to: s2 position: {0. 0}.  
  rs = ShapeAppendAST shape: sa1 to: (ShapeAppendAST shape: sa2 to: s3 position: {0. 0})  position: {0. 0}.
  t1 = TensorTypeAST shape: as type: T1 position: {0. 0}.
  t2 = TensorTypeAST shape: bs type: T2 position: {0. 0}.
  p1 = ParameterAST named: #f type: F asTensorType position: {0. 0}.
  p2 = ParameterAST named: #a type: t1 position: {0. 0}.
  p3 = ParameterAST named: #b type: t2 position: {0. 0}.
  ps <List[ParameterAST]> = {p1. p2. p3}.
  body = PrimitiveBodyAST block: [:f <ConcreteType> :a <ConcreteType> :b <ConcreteType> |  
    | 
    fun <FunctionAST> = f baseType.
    call  (*  hard part - how to make the call to f? Frame each arg separately. Then use their cells as args to f. *)
    (* Remember to peal off first dim from incoming tensors, as it is the tensor elements that are fed to f. *)
    frames <List[Frame]> = frameArguments: {ConcreteType dimensions: (a dimensions copyFrom: 2 to: a rank) baseType: a baseType. ConcreteType dimensions: (b dimensions copyFrom: 2 to: b rank) baseType: b baseType} of: fun.
    argVector <List[ConcreteType]> = frames collect: [:frame <Frame> | frame cells].
    |
    a rank < 1 ifTrue: [Error signal: 'Second argument to outerProduct must be of rank > 0'].
    b rank < 1 ifTrue: [Error signal: 'Third argument to outerProduct must be of rank > 0'].    
    fun isKindOfFunctionAST ifFalse: [Error signal: 'First parameter to outerProduct must be a function '].
    pushActivation: (Activation of: fun from: argVector).
    call:: fun body computeType.
    popActivation.
	ConcreteType dimensions: {a dimensions first}, frames first dimensions, {b dimensions first}, frames last dimensions, call dimensions baseType: call baseType
	]. 
   returnType = TensorTypeAST shape: rs type: T3 position: {0. 0}.
  |
  ^FunctionAST  named: #outerProduct parameters: ps returnType: returnType body: body position: {0. 0}  
)
currentScope ^  <Scope> = (
  scopeStack isEmpty ifTrue: [^programScope].
  ^scopeStack last
)
popScope  = (
  scopeStack removeLast
)
pushScope: s <Scope> = (
  scopeStack add: s
)
public Scope ^ <Scope class> = (
  (* provide access for nested classes *)
  ^super Scope
)
primitiveMakeTensor ^ <FunctionAST> = (
(* makeTensor(dims: @S, contents: []$T):@S $T *)
  | 
  s = ShapeVariableReferenceAST  named: #S position: {0. 0}.
  t1 = TensorTypeAST shape: s type: integerType position: {0. 0}.
  d = DimensionVariableReferenceAST named: #'$d' position: {0. 0}.
  T = TypeVariableReferenceAST named: #T position: {0. 0}.
  s2 = ShapeVectorAST dimensions: {d} position: {0. 0}.
  t2 = TensorTypeAST shape: s2 type: T position: {0. 0}.
  p1 = ParameterAST named: #dims type: t1 position: {0. 0}.
  p2 = ParameterAST named: #contents type: t2 position: {0. 0}.
  ps <List[ParameterAST]> = {p1. p2}.
  body = PrimitiveBodyAST block: [:dims :contents | 
      dims baseType = 'Int' ifFalse: [Error signal: 'Dimensions must be integers'].
      ConcreteType dimensions: dims dimensions baseType: contents baseType
	]. 
  returnType = TensorTypeAST shape: s type: integerType position: {0. 0}.
  |
  ^FunctionAST named: #makeTensor parameters: ps returnType: returnType body: body position: {0. 0}
)
) : (
)
) : (
)
